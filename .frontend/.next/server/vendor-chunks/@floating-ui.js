"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@floating-ui";
exports.ids = ["vendor-chunks/@floating-ui"];
exports.modules = {

/***/ "(ssr)/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrow: () => (/* binding */ arrow),\n/* harmony export */   autoPlacement: () => (/* binding */ autoPlacement),\n/* harmony export */   autoUpdate: () => (/* binding */ autoUpdate),\n/* harmony export */   computePosition: () => (/* binding */ computePosition),\n/* harmony export */   detectOverflow: () => (/* binding */ detectOverflow),\n/* harmony export */   flip: () => (/* binding */ flip),\n/* harmony export */   getOverflowAncestors: () => (/* reexport safe */ _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getOverflowAncestors),\n/* harmony export */   hide: () => (/* binding */ hide),\n/* harmony export */   inline: () => (/* binding */ inline),\n/* harmony export */   limitShift: () => (/* binding */ limitShift),\n/* harmony export */   offset: () => (/* binding */ offset),\n/* harmony export */   platform: () => (/* binding */ platform),\n/* harmony export */   shift: () => (/* binding */ shift),\n/* harmony export */   size: () => (/* binding */ size)\n/* harmony export */ });\n/* harmony import */ var _floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @floating-ui/utils */ \"(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs\");\n/* harmony import */ var _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @floating-ui/core */ \"(ssr)/./node_modules/@floating-ui/dom/node_modules/@floating-ui/core/dist/floating-ui.core.mjs\");\n/* harmony import */ var _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/utils/dom */ \"(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs\");\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n\n\nfunction getCssDimensions(element) {\n  const css = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(element);\n  // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.round)(width) !== offsetWidth || (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.round)(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\nfunction unwrapElement(element) {\n  return !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(element) ? element.contextElement : element;\n}\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(domElement)) {\n    return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.round)(rect.width) : rect.width) / width;\n  let y = ($ ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.round)(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\nconst noOffsets = /*#__PURE__*/(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(0);\nfunction getVisualOffsets(element) {\n  const win = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getWindow)(element);\n  if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isWebKit)() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getWindow)(element)) {\n    return false;\n  }\n  return isFixed;\n}\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getWindow)(domElement);\n    const offsetWin = offsetParent && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(offsetParent) ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getWindow)(offsetParent) : offsetParent;\n    let currentWin = win;\n    let currentIFrame = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getFrameElement)(currentWin);\n    while (currentIFrame && offsetParent && offsetWin !== currentWin) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentWin = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getWindow)(currentIFrame);\n      currentIFrame = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getFrameElement)(currentWin);\n    }\n  }\n  return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.rectToClientRect)({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\n// If <html> has a CSS width greater than the viewport, then this will be\n// incorrect for RTL.\nfunction getWindowScrollBarX(element, rect) {\n  const leftScroll = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getNodeScroll)(element).scrollLeft;\n  if (!rect) {\n    return getBoundingClientRect((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(element)).left + leftScroll;\n  }\n  return rect.left + leftScroll;\n}\nfunction getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {\n  if (ignoreScrollbarX === void 0) {\n    ignoreScrollbarX = false;\n  }\n  const htmlRect = documentElement.getBoundingClientRect();\n  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 :\n  // RTL <body> scrollbar.\n  getWindowScrollBarX(documentElement, htmlRect));\n  const y = htmlRect.top + scroll.scrollTop;\n  return {\n    x,\n    y\n  };\n}\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isFixed = strategy === 'fixed';\n  const documentElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(offsetParent);\n  const topLayer = elements ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isTopLayer)(elements.floating) : false;\n  if (offsetParent === documentElement || topLayer && isFixed) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(1);\n  const offsets = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(0);\n  const isOffsetParentAnElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(offsetParent);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getNodeName)(offsetParent) !== 'body' || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isOverflowElement)(documentElement)) {\n      scroll = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getNodeScroll)(offsetParent);\n    }\n    if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(0);\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y\n  };\n}\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(element);\n  const scroll = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getNodeScroll)(element);\n  const body = element.ownerDocument.body;\n  const width = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.max)(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.max)(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(body).direction === 'rtl') {\n    x += (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.max)(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getViewportRect(element, strategy) {\n  const win = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getWindow)(element);\n  const html = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isWebKit)();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nconst absoluteOrFixed = /*#__PURE__*/new Set(['absolute', 'fixed']);\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) ? getScale(element) : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(element));\n  } else if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y,\n      width: clippingAncestor.width,\n      height: clippingAncestor.height\n    };\n  }\n  return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.rectToClientRect)(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getParentNode)(element);\n  if (parentNode === stopNode || !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(parentNode) || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isLastTraversableNode)(parentNode)) {\n    return false;\n  }\n  return (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getOverflowAncestors)(element, [], false).filter(el => (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(el) && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getNodeName)(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(element).position === 'fixed';\n  let currentNode = elementIsFixed ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getParentNode)(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(currentNode) && !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isLastTraversableNode)(currentNode)) {\n    const computedStyle = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(currentNode);\n    const currentNodeIsContaining = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isContainingBlock)(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isOverflowElement)(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getParentNode)(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isTopLayer)(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.max)(rect.top, accRect.top);\n    accRect.right = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.min)(rect.right, accRect.right);\n    accRect.bottom = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.min)(rect.bottom, accRect.bottom);\n    accRect.left = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.max)(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\nfunction getDimensions(element) {\n  const {\n    width,\n    height\n  } = getCssDimensions(element);\n  return {\n    width,\n    height\n  };\n}\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(offsetParent);\n  const documentElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(offsetParent);\n  const isFixed = strategy === 'fixed';\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(0);\n\n  // If the <body> scrollbar appears on the left (e.g. RTL systems). Use\n  // Firefox with layout.scrollbar.side = 3 in about:config to test this.\n  function setLeftRTLScrollbarOffset() {\n    offsets.x = getWindowScrollBarX(documentElement);\n  }\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getNodeName)(offsetParent) !== 'body' || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isOverflowElement)(documentElement)) {\n      scroll = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getNodeScroll)(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      setLeftRTLScrollbarOffset();\n    }\n  }\n  if (isFixed && !isOffsetParentAnElement && documentElement) {\n    setLeftRTLScrollbarOffset();\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(0);\n  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;\n  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;\n  return {\n    x,\n    y,\n    width: rect.width,\n    height: rect.height\n  };\n}\nfunction isStaticPositioned(element) {\n  return (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(element).position === 'static';\n}\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  let rawOffsetParent = element.offsetParent;\n\n  // Firefox returns the <html> element as the offsetParent if it's non-static,\n  // while Chrome and Safari return the <body> element. The <body> element must\n  // be used to perform the correct calculations even if the <html> element is\n  // non-static.\n  if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(element) === rawOffsetParent) {\n    rawOffsetParent = rawOffsetParent.ownerDocument.body;\n  }\n  return rawOffsetParent;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const win = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getWindow)(element);\n  if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isTopLayer)(element)) {\n    return win;\n  }\n  if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element)) {\n    let svgOffsetParent = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getParentNode)(element);\n    while (svgOffsetParent && !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isLastTraversableNode)(svgOffsetParent)) {\n      if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {\n        return svgOffsetParent;\n      }\n      svgOffsetParent = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getParentNode)(svgOffsetParent);\n    }\n    return win;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isTableElement)(offsetParent) && isStaticPositioned(offsetParent)) {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isLastTraversableNode)(offsetParent) && isStaticPositioned(offsetParent) && !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isContainingBlock)(offsetParent)) {\n    return win;\n  }\n  return offsetParent || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getContainingBlock)(element) || win;\n}\nconst getElementRects = async function (data) {\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n  const getDimensionsFn = this.getDimensions;\n  const floatingDimensions = await getDimensionsFn(data.floating);\n  return {\n    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      width: floatingDimensions.width,\n      height: floatingDimensions.height\n    }\n  };\n};\nfunction isRTL(element) {\n  return (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(element).direction === 'rtl';\n}\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement: _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement: _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement,\n  isRTL\n};\nfunction rectsAreEqual(a, b) {\n  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;\n}\n\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(element);\n  function cleanup() {\n    var _io;\n    clearTimeout(timeoutId);\n    (_io = io) == null || _io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const elementRectForRootMargin = element.getBoundingClientRect();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = elementRectForRootMargin;\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.floor)(top);\n    const insetRight = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.floor)(root.clientWidth - (left + width));\n    const insetBottom = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.floor)(root.clientHeight - (top + height));\n    const insetLeft = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.floor)(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.max)(0, (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.min)(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          // If the reference is clipped, the ratio is 0. Throttle the refresh\n          // to prevent an infinite loop of updates.\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 1000);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {\n        // It's possible that even though the ratio is reported as 1, the\n        // element is not actually fully within the IntersectionObserver's root\n        // area anymore. This can happen under performance constraints. This may\n        // be a bug in the browser's IntersectionObserver implementation. To\n        // work around this, we compare the element's bounding rect now with\n        // what it was at the time we created the IntersectionObserver. If they\n        // are not equal then the element moved, so we refresh.\n        refresh();\n      }\n      isFirstUpdate = false;\n    }\n\n    // Older browsers don't support a `document` as the root and will throw an\n    // error.\n    try {\n      io = new IntersectionObserver(handleObserve, _objectSpread(_objectSpread({}, options), {}, {\n        // Handle <iframe>s\n        root: root.ownerDocument\n      }));\n    } catch (_e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === 'function',\n    layoutShift = typeof IntersectionObserver === 'function',\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getOverflowAncestors)(referenceEl) : []), ...(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getOverflowAncestors)(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(_ref => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        // Prevent update loops when using the `size` middleware.\n        // https://github.com/floating-ui/floating-ui/issues/1740\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          var _resizeObserver;\n          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    var _resizeObserver2;\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    cleanupIo == null || cleanupIo();\n    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nconst detectOverflow = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.detectOverflow;\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.offset;\n\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.autoPlacement;\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.shift;\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.flip;\n\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.size;\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.hide;\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.arrow;\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.inline;\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.limitShift;\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = _objectSpread({\n    platform\n  }, options);\n  const platformWithCache = _objectSpread(_objectSpread({}, mergedOptions.platform), {}, {\n    _c: cache\n  });\n  return (0,_floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.computePosition)(reference, floating, _objectSpread(_objectSpread({}, mergedOptions), {}, {\n    platform: platformWithCache\n  }));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL2RvbS9kaXN0L2Zsb2F0aW5nLXVpLmRvbS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF5VDtBQUMvTztBQUNrUDtBQUM5UDtBQUU5RCxTQUFTNkMsZ0JBQWdCQSxDQUFDQyxPQUFPLEVBQUU7RUFDakMsTUFBTUMsR0FBRyxHQUFHbkIsd0VBQWdCLENBQUNrQixPQUFPLENBQUM7RUFDckM7RUFDQTtFQUNBLElBQUlFLEtBQUssR0FBR0MsVUFBVSxDQUFDRixHQUFHLENBQUNDLEtBQUssQ0FBQyxJQUFJLENBQUM7RUFDdEMsSUFBSUUsTUFBTSxHQUFHRCxVQUFVLENBQUNGLEdBQUcsQ0FBQ0csTUFBTSxDQUFDLElBQUksQ0FBQztFQUN4QyxNQUFNQyxTQUFTLEdBQUd0QixxRUFBYSxDQUFDaUIsT0FBTyxDQUFDO0VBQ3hDLE1BQU1NLFdBQVcsR0FBR0QsU0FBUyxHQUFHTCxPQUFPLENBQUNNLFdBQVcsR0FBR0osS0FBSztFQUMzRCxNQUFNSyxZQUFZLEdBQUdGLFNBQVMsR0FBR0wsT0FBTyxDQUFDTyxZQUFZLEdBQUdILE1BQU07RUFDOUQsTUFBTUksY0FBYyxHQUFHL0IseURBQUssQ0FBQ3lCLEtBQUssQ0FBQyxLQUFLSSxXQUFXLElBQUk3Qix5REFBSyxDQUFDMkIsTUFBTSxDQUFDLEtBQUtHLFlBQVk7RUFDckYsSUFBSUMsY0FBYyxFQUFFO0lBQ2xCTixLQUFLLEdBQUdJLFdBQVc7SUFDbkJGLE1BQU0sR0FBR0csWUFBWTtFQUN2QjtFQUNBLE9BQU87SUFDTEwsS0FBSztJQUNMRSxNQUFNO0lBQ05LLENBQUMsRUFBRUQ7RUFDTCxDQUFDO0FBQ0g7QUFFQSxTQUFTRSxhQUFhQSxDQUFDVixPQUFPLEVBQUU7RUFDOUIsT0FBTyxDQUFDaEIsaUVBQVMsQ0FBQ2dCLE9BQU8sQ0FBQyxHQUFHQSxPQUFPLENBQUNXLGNBQWMsR0FBR1gsT0FBTztBQUMvRDtBQUVBLFNBQVNZ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QUV2QjtBQUNBO0FBQ0E7QUFDQSxNQUFNQyxVQUFVLEdBQUdDLHlEQUFZOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU1PLGVBQWUsR0FBR0EsQ0FBQzRKLFNBQVMsRUFBRXZFLFFBQVEsRUFBRStGLE9BQU8sS0FBSztFQUN4RDtFQUNBO0VBQ0E7RUFDQSxNQUFNbEUsS0FBSyxHQUFHLElBQUl5RyxHQUFHLENBQUMsQ0FBQztFQUN2QixNQUFNQyxhQUFhLEdBQUFoQyxhQUFBO0lBQ2pCOUI7RUFBUSxHQUNMc0IsT0FBTyxDQUNYO0VBQ0QsTUFBTXlDLGlCQUFpQixHQUFBakMsYUFBQSxDQUFBQSxhQUFBLEtBQ2xCZ0MsYUFBYSxDQUFDOUQsUUFBUTtJQUN6QnpCLEVBQUUsRUFBRW5CO0VBQUssRUFDVjtFQUNELE9BQU9qSCxrRUFBaUIsQ0FBQzJKLFNBQVMsRUFBRXZFLFFBQVEsRUFBQXVHLGFBQUEsQ0FBQUEsYUFBQSxLQUN2Q2dDLGFBQWE7SUFDaEI5RCxRQUFRLEVBQUUrRDtFQUFpQixFQUM1QixDQUFDO0FBQ0osQ0FBQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxFcmZhblxcRGVza3RvcFxcMtm+2LHZiNqY2Ycg24wg2YXYrdmF2K8g2LnYsdmB2KfZhiDYsdi22KfbjNuMXFxFcmZhbmRldlxcLmZyb250ZW5kXFxub2RlX21vZHVsZXNcXEBmbG9hdGluZy11aVxcZG9tXFxkaXN0XFxmbG9hdGluZy11aS5kb20ubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJlY3RUb0NsaWVudFJlY3QsIGFycm93IGFzIGFycm93JDEsIGF1dG9QbGFjZW1lbnQgYXMgYXV0b1BsYWNlbWVudCQxLCBkZXRlY3RPdmVyZmxvdyBhcyBkZXRlY3RPdmVyZmxvdyQxLCBmbGlwIGFzIGZsaXAkMSwgaGlkZSBhcyBoaWRlJDEsIGlubGluZSBhcyBpbmxpbmUkMSwgbGltaXRTaGlmdCBhcyBsaW1pdFNoaWZ0JDEsIG9mZnNldCBhcyBvZmZzZXQkMSwgc2hpZnQgYXMgc2hpZnQkMSwgc2l6ZSBhcyBzaXplJDEsIGNvbXB1dGVQb3NpdGlvbiBhcyBjb21wdXRlUG9zaXRpb24kMSB9IGZyb20gJ0BmbG9hdGluZy11aS9jb3JlJztcbmltcG9ydCB7IHJvdW5kLCBjcmVhdGVDb29yZHMsIG1heCwgbWluLCBmbG9vciB9IGZyb20gJ0BmbG9hdGluZy11aS91dGlscyc7XG5pbXBvcnQgeyBnZXRDb21wdXRlZFN0eWxlLCBpc0hUTUxFbGVtZW50LCBpc0VsZW1lbnQsIGdldFdpbmRvdywgaXNXZWJLaXQsIGdldEZyYW1lRWxlbWVudCwgZ2V0Tm9kZVNjcm9sbCwgZ2V0RG9jdW1lbnRFbGVtZW50LCBpc1RvcExheWVyLCBnZXROb2RlTmFtZSwgaXNPdmVyZmxvd0VsZW1lbnQsIGdldE92ZXJmbG93QW5jZXN0b3JzLCBnZXRQYXJlbnROb2RlLCBpc0xhc3RUcmF2ZXJzYWJsZU5vZGUsIGlzQ29udGFpbmluZ0Jsb2NrLCBpc1RhYmxlRWxlbWVudCwgZ2V0Q29udGFpbmluZ0Jsb2NrIH0gZnJvbSAnQGZsb2F0aW5nLXVpL3V0aWxzL2RvbSc7XG5leHBvcnQgeyBnZXRPdmVyZmxvd0FuY2VzdG9ycyB9IGZyb20gJ0BmbG9hdGluZy11aS91dGlscy9kb20nO1xuXG5mdW5jdGlvbiBnZXRDc3NEaW1lbnNpb25zKGVsZW1lbnQpIHtcbiAgY29uc3QgY3NzID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgLy8gSW4gdGVzdGluZyBlbnZpcm9ubWVudHMsIHRoZSBgd2lkdGhgIGFuZCBgaGVpZ2h0YCBwcm9wZXJ0aWVzIGFyZSBlbXB0eVxuICAvLyBzdHJpbmdzIGZvciBTVkcgZWxlbWVudHMsIHJldHVybmluZyBOYU4uIEZhbGxiYWNrIHRvIGAwYCBpbiB0aGlzIGNhc2UuXG4gIGxldCB3aWR0aCA9IHBhcnNlRmxvYXQoY3NzLndpZHRoKSB8fCAwO1xuICBsZXQgaGVpZ2h0ID0gcGFyc2VGbG9hdChjc3MuaGVpZ2h0KSB8fCAwO1xuICBjb25zdCBoYXNPZmZzZXQgPSBpc0hUTUxFbGVtZW50KGVsZW1lbnQpO1xuICBjb25zdCBvZmZzZXRXaWR0aCA9IGhhc09mZnNldCA/IGVsZW1lbnQub2Zmc2V0V2lkdGggOiB3aWR0aDtcbiAgY29uc3Qgb2Zmc2V0SGVpZ2h0ID0gaGFzT2Zmc2V0ID8gZWxlbWVudC5vZmZzZXRIZWlnaHQgOiBoZWlnaHQ7XG4gIGNvbnN0IHNob3VsZEZhbGxiYWNrID0gcm91bmQod2lkdGgpICE9PSBvZmZzZXRXaWR0aCB8fCByb3VuZChoZWlnaHQpICE9PSBvZmZzZXRIZWlnaHQ7XG4gIGlmIChzaG91bGRGYWxsYmFjaykge1xuICAgIHdpZHRoID0gb2Zmc2V0V2lkdGg7XG4gICAgaGVpZ2h0ID0gb2Zmc2V0SGVpZ2h0O1xuICB9XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgICQ6IHNob3VsZEZhbGxiYWNrXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVud3JhcEVsZW1lbnQoZWxlbWVudCkge1xuICByZXR1cm4gIWlzRWxlbWVudChlbGVtZW50KSA/IGVsZW1lbnQuY29udGV4dEVsZW1lbnQgOiBlbGVtZW50O1xufVxuXG5mdW5jdGlvbiBnZXRTY2FsZShlbGVtZW50KSB7XG4gIGNvbnN0IGRvbUVsZW1lbnQgPSB1bndyYXBFbGVtZW50KGVsZW1lbnQpO1xuICBpZiAoIWlzSFRNTEVsZW1lbnQoZG9tRWxlbWVudCkpIHtcbiAgICByZXR1cm4gY3JlYXRlQ29vcmRzKDEpO1xuICB9XG4gIGNvbnN0IHJlY3QgPSBkb21FbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBjb25zdCB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgICRcbiAgfSA9IGdldENzc0RpbWVuc2lvbnMoZG9tRWxlbWVudCk7XG4gIGxldCB4ID0gKCQgPyByb3VuZChyZWN0LndpZHRoKSA6IHJlY3Qud2lkdGgpIC8gd2lkdGg7XG4gIGxldCB5ID0gKCQgPyByb3VuZChyZWN0LmhlaWdodCkgOiByZWN0LmhlaWdodCkgLyBoZWlnaHQ7XG5cbiAgLy8gMCwgTmFOLCBvciBJbmZpbml0eSBzaG91bGQgYWx3YXlzIGZhbGxiYWNrIHRvIDEuXG5cbiAgaWYgKCF4IHx8ICFOdW1iZXIuaXNGaW5pdGUoeCkpIHtcbiAgICB4ID0gMTtcbiAgfVxuICBpZiAoIXkgfHwgIU51bWJlci5pc0Zpbml0ZSh5KSkge1xuICAgIHkgPSAxO1xuICB9XG4gIHJldHVybiB7XG4gICAgeCxcbiAgICB5XG4gIH07XG59XG5cbmNvbnN0IG5vT2Zmc2V0cyA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb29yZHMoMCk7XG5mdW5jdGlvbiBnZXRWaXN1YWxPZmZzZXRzKGVsZW1lbnQpIHtcbiAgY29uc3Qgd2luID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICBpZiAoIWlzV2ViS2l0KCkgfHwgIXdpbi52aXN1YWxWaWV3cG9ydCkge1xuICAgIHJldHVybiBub09mZnNldHM7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4OiB3aW4udmlzdWFsVmlld3BvcnQub2Zmc2V0TGVmdCxcbiAgICB5OiB3aW4udmlzdWFsVmlld3BvcnQub2Zmc2V0VG9wXG4gIH07XG59XG5mdW5jdGlvbiBzaG91bGRBZGRWaXN1YWxPZmZzZXRzKGVsZW1lbnQsIGlzRml4ZWQsIGZsb2F0aW5nT2Zmc2V0UGFyZW50KSB7XG4gIGlmIChpc0ZpeGVkID09PSB2b2lkIDApIHtcbiAgICBpc0ZpeGVkID0gZmFsc2U7XG4gIH1cbiAgaWYgKCFmbG9hdGluZ09mZnNldFBhcmVudCB8fCBpc0ZpeGVkICYmIGZsb2F0aW5nT2Zmc2V0UGFyZW50ICE9PSBnZXRXaW5kb3coZWxlbWVudCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzRml4ZWQ7XG59XG5cbmZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCBpbmNsdWRlU2NhbGUsIGlzRml4ZWRTdHJhdGVneSwgb2Zmc2V0UGFyZW50KSB7XG4gIGlmIChpbmNsdWRlU2NhbGUgPT09IHZvaWQgMCkge1xuICAgIGluY2x1ZGVTY2FsZSA9IGZhbHNlO1xuICB9XG4gIGlmIChpc0ZpeGVkU3RyYXRlZ3kgPT09IHZvaWQgMCkge1xuICAgIGlzRml4ZWRTdHJhdGVneSA9IGZhbHNlO1xuICB9XG4gIGNvbnN0IGNsaWVudFJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBjb25zdCBkb21FbGVtZW50ID0gdW53cmFwRWxlbWVudChlbGVtZW50KTtcbiAgbGV0IHNjYWxlID0gY3JlYXRlQ29vcmRzKDEpO1xuICBpZiAoaW5jbHVkZVNjYWxlKSB7XG4gICAgaWYgKG9mZnNldFBhcmVudCkge1xuICAgICAgaWYgKGlzRWxlbWVudChvZmZzZXRQYXJlbnQpKSB7XG4gICAgICAgIHNjYWxlID0gZ2V0U2NhbGUob2Zmc2V0UGFyZW50KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2NhbGUgPSBnZXRTY2FsZShlbGVtZW50KTtcbiAgICB9XG4gIH1cbiAgY29uc3QgdmlzdWFsT2Zmc2V0cyA9IHNob3VsZEFkZFZpc3VhbE9mZnNldHMoZG9tRWxlbWVudCwgaXNGaXhlZFN0cmF0ZWd5LCBvZmZzZXRQYXJlbnQpID8gZ2V0VmlzdWFsT2Zmc2V0cyhkb21FbGVtZW50KSA6IGNyZWF0ZUNvb3JkcygwKTtcbiAgbGV0IHggPSAoY2xpZW50UmVjdC5sZWZ0ICsgdmlzdWFsT2Zmc2V0cy54KSAvIHNjYWxlLng7XG4gIGxldCB5ID0gKGNsaWVudFJlY3QudG9wICsgdmlzdWFsT2Zmc2V0cy55KSAvIHNjYWxlLnk7XG4gIGxldCB3aWR0aCA9IGNsaWVudFJlY3Qud2lkdGggLyBzY2FsZS54O1xuICBsZXQgaGVpZ2h0ID0gY2xpZW50UmVjdC5oZWlnaHQgLyBzY2FsZS55O1xuICBpZiAoZG9tRWxlbWVudCkge1xuICAgIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhkb21FbGVtZW50KTtcbiAgICBjb25zdCBvZmZzZXRXaW4gPSBvZmZzZXRQYXJlbnQgJiYgaXNFbGVtZW50KG9mZnNldFBhcmVudCkgPyBnZXRXaW5kb3cob2Zmc2V0UGFyZW50KSA6IG9mZnNldFBhcmVudDtcbiAgICBsZXQgY3VycmVudFdpbiA9IHdpbjtcbiAgICBsZXQgY3VycmVudElGcmFtZSA9IGdldEZyYW1lRWxlbWVudChjdXJyZW50V2luKTtcbiAgICB3aGlsZSAoY3VycmVudElGcmFtZSAmJiBvZmZzZXRQYXJlbnQgJiYgb2Zmc2V0V2luICE9PSBjdXJyZW50V2luKSB7XG4gICAgICBjb25zdCBpZnJhbWVTY2FsZSA9IGdldFNjYWxlKGN1cnJlbnRJRnJhbWUpO1xuICAgICAgY29uc3QgaWZyYW1lUmVjdCA9IGN1cnJlbnRJRnJhbWUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBjc3MgPSBnZXRDb21wdXRlZFN0eWxlKGN1cnJlbnRJRnJhbWUpO1xuICAgICAgY29uc3QgbGVmdCA9IGlmcmFtZVJlY3QubGVmdCArIChjdXJyZW50SUZyYW1lLmNsaWVudExlZnQgKyBwYXJzZUZsb2F0KGNzcy5wYWRkaW5nTGVmdCkpICogaWZyYW1lU2NhbGUueDtcbiAgICAgIGNvbnN0IHRvcCA9IGlmcmFtZVJlY3QudG9wICsgKGN1cnJlbnRJRnJhbWUuY2xpZW50VG9wICsgcGFyc2VGbG9hdChjc3MucGFkZGluZ1RvcCkpICogaWZyYW1lU2NhbGUueTtcbiAgICAgIHggKj0gaWZyYW1lU2NhbGUueDtcbiAgICAgIHkgKj0gaWZyYW1lU2NhbGUueTtcbiAgICAgIHdpZHRoICo9IGlmcmFtZVNjYWxlLng7XG4gICAgICBoZWlnaHQgKj0gaWZyYW1lU2NhbGUueTtcbiAgICAgIHggKz0gbGVmdDtcbiAgICAgIHkgKz0gdG9wO1xuICAgICAgY3VycmVudFdpbiA9IGdldFdpbmRvdyhjdXJyZW50SUZyYW1lKTtcbiAgICAgIGN1cnJlbnRJRnJhbWUgPSBnZXRGcmFtZUVsZW1lbnQoY3VycmVudFdpbik7XG4gICAgfVxuICB9XG4gIHJldHVybiByZWN0VG9DbGllbnRSZWN0KHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgeCxcbiAgICB5XG4gIH0pO1xufVxuXG4vLyBJZiA8aHRtbD4gaGFzIGEgQ1NTIHdpZHRoIGdyZWF0ZXIgdGhhbiB0aGUgdmlld3BvcnQsIHRoZW4gdGhpcyB3aWxsIGJlXG4vLyBpbmNvcnJlY3QgZm9yIFJUTC5cbmZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCwgcmVjdCkge1xuICBjb25zdCBsZWZ0U2Nyb2xsID0gZ2V0Tm9kZVNjcm9sbChlbGVtZW50KS5zY3JvbGxMZWZ0O1xuICBpZiAoIXJlY3QpIHtcbiAgICByZXR1cm4gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSkubGVmdCArIGxlZnRTY3JvbGw7XG4gIH1cbiAgcmV0dXJuIHJlY3QubGVmdCArIGxlZnRTY3JvbGw7XG59XG5cbmZ1bmN0aW9uIGdldEhUTUxPZmZzZXQoZG9jdW1lbnRFbGVtZW50LCBzY3JvbGwsIGlnbm9yZVNjcm9sbGJhclgpIHtcbiAgaWYgKGlnbm9yZVNjcm9sbGJhclggPT09IHZvaWQgMCkge1xuICAgIGlnbm9yZVNjcm9sbGJhclggPSBmYWxzZTtcbiAgfVxuICBjb25zdCBodG1sUmVjdCA9IGRvY3VtZW50RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3QgeCA9IGh0bWxSZWN0LmxlZnQgKyBzY3JvbGwuc2Nyb2xsTGVmdCAtIChpZ25vcmVTY3JvbGxiYXJYID8gMCA6XG4gIC8vIFJUTCA8Ym9keT4gc2Nyb2xsYmFyLlxuICBnZXRXaW5kb3dTY3JvbGxCYXJYKGRvY3VtZW50RWxlbWVudCwgaHRtbFJlY3QpKTtcbiAgY29uc3QgeSA9IGh0bWxSZWN0LnRvcCArIHNjcm9sbC5zY3JvbGxUb3A7XG4gIHJldHVybiB7XG4gICAgeCxcbiAgICB5XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0KF9yZWYpIHtcbiAgbGV0IHtcbiAgICBlbGVtZW50cyxcbiAgICByZWN0LFxuICAgIG9mZnNldFBhcmVudCxcbiAgICBzdHJhdGVneVxuICB9ID0gX3JlZjtcbiAgY29uc3QgaXNGaXhlZCA9IHN0cmF0ZWd5ID09PSAnZml4ZWQnO1xuICBjb25zdCBkb2N1bWVudEVsZW1lbnQgPSBnZXREb2N1bWVudEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgY29uc3QgdG9wTGF5ZXIgPSBlbGVtZW50cyA/IGlzVG9wTGF5ZXIoZWxlbWVudHMuZmxvYXRpbmcpIDogZmFsc2U7XG4gIGlmIChvZmZzZXRQYXJlbnQgPT09IGRvY3VtZW50RWxlbWVudCB8fCB0b3BMYXllciAmJiBpc0ZpeGVkKSB7XG4gICAgcmV0dXJuIHJlY3Q7XG4gIH1cbiAgbGV0IHNjcm9sbCA9IHtcbiAgICBzY3JvbGxMZWZ0OiAwLFxuICAgIHNjcm9sbFRvcDogMFxuICB9O1xuICBsZXQgc2NhbGUgPSBjcmVhdGVDb29yZHMoMSk7XG4gIGNvbnN0IG9mZnNldHMgPSBjcmVhdGVDb29yZHMoMCk7XG4gIGNvbnN0IGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ID0gaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICBpZiAoaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgfHwgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmICFpc0ZpeGVkKSB7XG4gICAgaWYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgIT09ICdib2R5JyB8fCBpc092ZXJmbG93RWxlbWVudChkb2N1bWVudEVsZW1lbnQpKSB7XG4gICAgICBzY3JvbGwgPSBnZXROb2RlU2Nyb2xsKG9mZnNldFBhcmVudCk7XG4gICAgfVxuICAgIGlmIChpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCkpIHtcbiAgICAgIGNvbnN0IG9mZnNldFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qob2Zmc2V0UGFyZW50KTtcbiAgICAgIHNjYWxlID0gZ2V0U2NhbGUob2Zmc2V0UGFyZW50KTtcbiAgICAgIG9mZnNldHMueCA9IG9mZnNldFJlY3QueCArIG9mZnNldFBhcmVudC5jbGllbnRMZWZ0O1xuICAgICAgb2Zmc2V0cy55ID0gb2Zmc2V0UmVjdC55ICsgb2Zmc2V0UGFyZW50LmNsaWVudFRvcDtcbiAgICB9XG4gIH1cbiAgY29uc3QgaHRtbE9mZnNldCA9IGRvY3VtZW50RWxlbWVudCAmJiAhaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgJiYgIWlzRml4ZWQgPyBnZXRIVE1MT2Zmc2V0KGRvY3VtZW50RWxlbWVudCwgc2Nyb2xsLCB0cnVlKSA6IGNyZWF0ZUNvb3JkcygwKTtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogcmVjdC53aWR0aCAqIHNjYWxlLngsXG4gICAgaGVpZ2h0OiByZWN0LmhlaWdodCAqIHNjYWxlLnksXG4gICAgeDogcmVjdC54ICogc2NhbGUueCAtIHNjcm9sbC5zY3JvbGxMZWZ0ICogc2NhbGUueCArIG9mZnNldHMueCArIGh0bWxPZmZzZXQueCxcbiAgICB5OiByZWN0LnkgKiBzY2FsZS55IC0gc2Nyb2xsLnNjcm9sbFRvcCAqIHNjYWxlLnkgKyBvZmZzZXRzLnkgKyBodG1sT2Zmc2V0LnlcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2xpZW50UmVjdHMoZWxlbWVudCkge1xuICByZXR1cm4gQXJyYXkuZnJvbShlbGVtZW50LmdldENsaWVudFJlY3RzKCkpO1xufVxuXG4vLyBHZXRzIHRoZSBlbnRpcmUgc2l6ZSBvZiB0aGUgc2Nyb2xsYWJsZSBkb2N1bWVudCBhcmVhLCBldmVuIGV4dGVuZGluZyBvdXRzaWRlXG4vLyBvZiB0aGUgYDxodG1sPmAgYW5kIGA8Ym9keT5gIHJlY3QgYm91bmRzIGlmIGhvcml6b250YWxseSBzY3JvbGxhYmxlLlxuZnVuY3Rpb24gZ2V0RG9jdW1lbnRSZWN0KGVsZW1lbnQpIHtcbiAgY29uc3QgaHRtbCA9IGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KTtcbiAgY29uc3Qgc2Nyb2xsID0gZ2V0Tm9kZVNjcm9sbChlbGVtZW50KTtcbiAgY29uc3QgYm9keSA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5ib2R5O1xuICBjb25zdCB3aWR0aCA9IG1heChodG1sLnNjcm9sbFdpZHRoLCBodG1sLmNsaWVudFdpZHRoLCBib2R5LnNjcm9sbFdpZHRoLCBib2R5LmNsaWVudFdpZHRoKTtcbiAgY29uc3QgaGVpZ2h0ID0gbWF4KGh0bWwuc2Nyb2xsSGVpZ2h0LCBodG1sLmNsaWVudEhlaWdodCwgYm9keS5zY3JvbGxIZWlnaHQsIGJvZHkuY2xpZW50SGVpZ2h0KTtcbiAgbGV0IHggPSAtc2Nyb2xsLnNjcm9sbExlZnQgKyBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpO1xuICBjb25zdCB5ID0gLXNjcm9sbC5zY3JvbGxUb3A7XG4gIGlmIChnZXRDb21wdXRlZFN0eWxlKGJvZHkpLmRpcmVjdGlvbiA9PT0gJ3J0bCcpIHtcbiAgICB4ICs9IG1heChodG1sLmNsaWVudFdpZHRoLCBib2R5LmNsaWVudFdpZHRoKSAtIHdpZHRoO1xuICB9XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHgsXG4gICAgeVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRWaWV3cG9ydFJlY3QoZWxlbWVudCwgc3RyYXRlZ3kpIHtcbiAgY29uc3Qgd2luID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICBjb25zdCBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICBjb25zdCB2aXN1YWxWaWV3cG9ydCA9IHdpbi52aXN1YWxWaWV3cG9ydDtcbiAgbGV0IHdpZHRoID0gaHRtbC5jbGllbnRXaWR0aDtcbiAgbGV0IGhlaWdodCA9IGh0bWwuY2xpZW50SGVpZ2h0O1xuICBsZXQgeCA9IDA7XG4gIGxldCB5ID0gMDtcbiAgaWYgKHZpc3VhbFZpZXdwb3J0KSB7XG4gICAgd2lkdGggPSB2aXN1YWxWaWV3cG9ydC53aWR0aDtcbiAgICBoZWlnaHQgPSB2aXN1YWxWaWV3cG9ydC5oZWlnaHQ7XG4gICAgY29uc3QgdmlzdWFsVmlld3BvcnRCYXNlZCA9IGlzV2ViS2l0KCk7XG4gICAgaWYgKCF2aXN1YWxWaWV3cG9ydEJhc2VkIHx8IHZpc3VhbFZpZXdwb3J0QmFzZWQgJiYgc3RyYXRlZ3kgPT09ICdmaXhlZCcpIHtcbiAgICAgIHggPSB2aXN1YWxWaWV3cG9ydC5vZmZzZXRMZWZ0O1xuICAgICAgeSA9IHZpc3VhbFZpZXdwb3J0Lm9mZnNldFRvcDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgeCxcbiAgICB5XG4gIH07XG59XG5cbmNvbnN0IGFic29sdXRlT3JGaXhlZCA9IC8qI19fUFVSRV9fKi9uZXcgU2V0KFsnYWJzb2x1dGUnLCAnZml4ZWQnXSk7XG4vLyBSZXR1cm5zIHRoZSBpbm5lciBjbGllbnQgcmVjdCwgc3VidHJhY3Rpbmcgc2Nyb2xsYmFycyBpZiBwcmVzZW50LlxuZnVuY3Rpb24gZ2V0SW5uZXJCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgc3RyYXRlZ3kpIHtcbiAgY29uc3QgY2xpZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCB0cnVlLCBzdHJhdGVneSA9PT0gJ2ZpeGVkJyk7XG4gIGNvbnN0IHRvcCA9IGNsaWVudFJlY3QudG9wICsgZWxlbWVudC5jbGllbnRUb3A7XG4gIGNvbnN0IGxlZnQgPSBjbGllbnRSZWN0LmxlZnQgKyBlbGVtZW50LmNsaWVudExlZnQ7XG4gIGNvbnN0IHNjYWxlID0gaXNIVE1MRWxlbWVudChlbGVtZW50KSA/IGdldFNjYWxlKGVsZW1lbnQpIDogY3JlYXRlQ29vcmRzKDEpO1xuICBjb25zdCB3aWR0aCA9IGVsZW1lbnQuY2xpZW50V2lkdGggKiBzY2FsZS54O1xuICBjb25zdCBoZWlnaHQgPSBlbGVtZW50LmNsaWVudEhlaWdodCAqIHNjYWxlLnk7XG4gIGNvbnN0IHggPSBsZWZ0ICogc2NhbGUueDtcbiAgY29uc3QgeSA9IHRvcCAqIHNjYWxlLnk7XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHgsXG4gICAgeVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0Q2xpZW50UmVjdEZyb21DbGlwcGluZ0FuY2VzdG9yKGVsZW1lbnQsIGNsaXBwaW5nQW5jZXN0b3IsIHN0cmF0ZWd5KSB7XG4gIGxldCByZWN0O1xuICBpZiAoY2xpcHBpbmdBbmNlc3RvciA9PT0gJ3ZpZXdwb3J0Jykge1xuICAgIHJlY3QgPSBnZXRWaWV3cG9ydFJlY3QoZWxlbWVudCwgc3RyYXRlZ3kpO1xuICB9IGVsc2UgaWYgKGNsaXBwaW5nQW5jZXN0b3IgPT09ICdkb2N1bWVudCcpIHtcbiAgICByZWN0ID0gZ2V0RG9jdW1lbnRSZWN0KGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSk7XG4gIH0gZWxzZSBpZiAoaXNFbGVtZW50KGNsaXBwaW5nQW5jZXN0b3IpKSB7XG4gICAgcmVjdCA9IGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGNsaXBwaW5nQW5jZXN0b3IsIHN0cmF0ZWd5KTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB2aXN1YWxPZmZzZXRzID0gZ2V0VmlzdWFsT2Zmc2V0cyhlbGVtZW50KTtcbiAgICByZWN0ID0ge1xuICAgICAgeDogY2xpcHBpbmdBbmNlc3Rvci54IC0gdmlzdWFsT2Zmc2V0cy54LFxuICAgICAgeTogY2xpcHBpbmdBbmNlc3Rvci55IC0gdmlzdWFsT2Zmc2V0cy55LFxuICAgICAgd2lkdGg6IGNsaXBwaW5nQW5jZXN0b3Iud2lkdGgsXG4gICAgICBoZWlnaHQ6IGNsaXBwaW5nQW5jZXN0b3IuaGVpZ2h0XG4gICAgfTtcbiAgfVxuICByZXR1cm4gcmVjdFRvQ2xpZW50UmVjdChyZWN0KTtcbn1cbmZ1bmN0aW9uIGhhc0ZpeGVkUG9zaXRpb25BbmNlc3RvcihlbGVtZW50LCBzdG9wTm9kZSkge1xuICBjb25zdCBwYXJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcbiAgaWYgKHBhcmVudE5vZGUgPT09IHN0b3BOb2RlIHx8ICFpc0VsZW1lbnQocGFyZW50Tm9kZSkgfHwgaXNMYXN0VHJhdmVyc2FibGVOb2RlKHBhcmVudE5vZGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKHBhcmVudE5vZGUpLnBvc2l0aW9uID09PSAnZml4ZWQnIHx8IGhhc0ZpeGVkUG9zaXRpb25BbmNlc3RvcihwYXJlbnROb2RlLCBzdG9wTm9kZSk7XG59XG5cbi8vIEEgXCJjbGlwcGluZyBhbmNlc3RvclwiIGlzIGFuIGBvdmVyZmxvd2AgZWxlbWVudCB3aXRoIHRoZSBjaGFyYWN0ZXJpc3RpYyBvZlxuLy8gY2xpcHBpbmcgKG9yIGhpZGluZykgY2hpbGQgZWxlbWVudHMuIFRoaXMgcmV0dXJucyBhbGwgY2xpcHBpbmcgYW5jZXN0b3JzXG4vLyBvZiB0aGUgZ2l2ZW4gZWxlbWVudCB1cCB0aGUgdHJlZS5cbmZ1bmN0aW9uIGdldENsaXBwaW5nRWxlbWVudEFuY2VzdG9ycyhlbGVtZW50LCBjYWNoZSkge1xuICBjb25zdCBjYWNoZWRSZXN1bHQgPSBjYWNoZS5nZXQoZWxlbWVudCk7XG4gIGlmIChjYWNoZWRSZXN1bHQpIHtcbiAgICByZXR1cm4gY2FjaGVkUmVzdWx0O1xuICB9XG4gIGxldCByZXN1bHQgPSBnZXRPdmVyZmxvd0FuY2VzdG9ycyhlbGVtZW50LCBbXSwgZmFsc2UpLmZpbHRlcihlbCA9PiBpc0VsZW1lbnQoZWwpICYmIGdldE5vZGVOYW1lKGVsKSAhPT0gJ2JvZHknKTtcbiAgbGV0IGN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlID0gbnVsbDtcbiAgY29uc3QgZWxlbWVudElzRml4ZWQgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uID09PSAnZml4ZWQnO1xuICBsZXQgY3VycmVudE5vZGUgPSBlbGVtZW50SXNGaXhlZCA/IGdldFBhcmVudE5vZGUoZWxlbWVudCkgOiBlbGVtZW50O1xuXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9Db250YWluaW5nX2Jsb2NrI2lkZW50aWZ5aW5nX3RoZV9jb250YWluaW5nX2Jsb2NrXG4gIHdoaWxlIChpc0VsZW1lbnQoY3VycmVudE5vZGUpICYmICFpc0xhc3RUcmF2ZXJzYWJsZU5vZGUoY3VycmVudE5vZGUpKSB7XG4gICAgY29uc3QgY29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoY3VycmVudE5vZGUpO1xuICAgIGNvbnN0IGN1cnJlbnROb2RlSXNDb250YWluaW5nID0gaXNDb250YWluaW5nQmxvY2soY3VycmVudE5vZGUpO1xuICAgIGlmICghY3VycmVudE5vZGVJc0NvbnRhaW5pbmcgJiYgY29tcHV0ZWRTdHlsZS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgICAgY3VycmVudENvbnRhaW5pbmdCbG9ja0NvbXB1dGVkU3R5bGUgPSBudWxsO1xuICAgIH1cbiAgICBjb25zdCBzaG91bGREcm9wQ3VycmVudE5vZGUgPSBlbGVtZW50SXNGaXhlZCA/ICFjdXJyZW50Tm9kZUlzQ29udGFpbmluZyAmJiAhY3VycmVudENvbnRhaW5pbmdCbG9ja0NvbXB1dGVkU3R5bGUgOiAhY3VycmVudE5vZGVJc0NvbnRhaW5pbmcgJiYgY29tcHV0ZWRTdHlsZS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycgJiYgISFjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZSAmJiBhYnNvbHV0ZU9yRml4ZWQuaGFzKGN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlLnBvc2l0aW9uKSB8fCBpc092ZXJmbG93RWxlbWVudChjdXJyZW50Tm9kZSkgJiYgIWN1cnJlbnROb2RlSXNDb250YWluaW5nICYmIGhhc0ZpeGVkUG9zaXRpb25BbmNlc3RvcihlbGVtZW50LCBjdXJyZW50Tm9kZSk7XG4gICAgaWYgKHNob3VsZERyb3BDdXJyZW50Tm9kZSkge1xuICAgICAgLy8gRHJvcCBub24tY29udGFpbmluZyBibG9ja3MuXG4gICAgICByZXN1bHQgPSByZXN1bHQuZmlsdGVyKGFuY2VzdG9yID0+IGFuY2VzdG9yICE9PSBjdXJyZW50Tm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlY29yZCBsYXN0IGNvbnRhaW5pbmcgYmxvY2sgZm9yIG5leHQgaXRlcmF0aW9uLlxuICAgICAgY3VycmVudENvbnRhaW5pbmdCbG9ja0NvbXB1dGVkU3R5bGUgPSBjb21wdXRlZFN0eWxlO1xuICAgIH1cbiAgICBjdXJyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoY3VycmVudE5vZGUpO1xuICB9XG4gIGNhY2hlLnNldChlbGVtZW50LCByZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBHZXRzIHRoZSBtYXhpbXVtIGFyZWEgdGhhdCB0aGUgZWxlbWVudCBpcyB2aXNpYmxlIGluIGR1ZSB0byBhbnkgbnVtYmVyIG9mXG4vLyBjbGlwcGluZyBhbmNlc3RvcnMuXG5mdW5jdGlvbiBnZXRDbGlwcGluZ1JlY3QoX3JlZikge1xuICBsZXQge1xuICAgIGVsZW1lbnQsXG4gICAgYm91bmRhcnksXG4gICAgcm9vdEJvdW5kYXJ5LFxuICAgIHN0cmF0ZWd5XG4gIH0gPSBfcmVmO1xuICBjb25zdCBlbGVtZW50Q2xpcHBpbmdBbmNlc3RvcnMgPSBib3VuZGFyeSA9PT0gJ2NsaXBwaW5nQW5jZXN0b3JzJyA/IGlzVG9wTGF5ZXIoZWxlbWVudCkgPyBbXSA6IGdldENsaXBwaW5nRWxlbWVudEFuY2VzdG9ycyhlbGVtZW50LCB0aGlzLl9jKSA6IFtdLmNvbmNhdChib3VuZGFyeSk7XG4gIGNvbnN0IGNsaXBwaW5nQW5jZXN0b3JzID0gWy4uLmVsZW1lbnRDbGlwcGluZ0FuY2VzdG9ycywgcm9vdEJvdW5kYXJ5XTtcbiAgY29uc3QgZmlyc3RDbGlwcGluZ0FuY2VzdG9yID0gY2xpcHBpbmdBbmNlc3RvcnNbMF07XG4gIGNvbnN0IGNsaXBwaW5nUmVjdCA9IGNsaXBwaW5nQW5jZXN0b3JzLnJlZHVjZSgoYWNjUmVjdCwgY2xpcHBpbmdBbmNlc3RvcikgPT4ge1xuICAgIGNvbnN0IHJlY3QgPSBnZXRDbGllbnRSZWN0RnJvbUNsaXBwaW5nQW5jZXN0b3IoZWxlbWVudCwgY2xpcHBpbmdBbmNlc3Rvciwgc3RyYXRlZ3kpO1xuICAgIGFjY1JlY3QudG9wID0gbWF4KHJlY3QudG9wLCBhY2NSZWN0LnRvcCk7XG4gICAgYWNjUmVjdC5yaWdodCA9IG1pbihyZWN0LnJpZ2h0LCBhY2NSZWN0LnJpZ2h0KTtcbiAgICBhY2NSZWN0LmJvdHRvbSA9IG1pbihyZWN0LmJvdHRvbSwgYWNjUmVjdC5ib3R0b20pO1xuICAgIGFjY1JlY3QubGVmdCA9IG1heChyZWN0LmxlZnQsIGFjY1JlY3QubGVmdCk7XG4gICAgcmV0dXJuIGFjY1JlY3Q7XG4gIH0sIGdldENsaWVudFJlY3RGcm9tQ2xpcHBpbmdBbmNlc3RvcihlbGVtZW50LCBmaXJzdENsaXBwaW5nQW5jZXN0b3IsIHN0cmF0ZWd5KSk7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IGNsaXBwaW5nUmVjdC5yaWdodCAtIGNsaXBwaW5nUmVjdC5sZWZ0LFxuICAgIGhlaWdodDogY2xpcHBpbmdSZWN0LmJvdHRvbSAtIGNsaXBwaW5nUmVjdC50b3AsXG4gICAgeDogY2xpcHBpbmdSZWN0LmxlZnQsXG4gICAgeTogY2xpcHBpbmdSZWN0LnRvcFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXREaW1lbnNpb25zKGVsZW1lbnQpIHtcbiAgY29uc3Qge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodFxuICB9ID0gZ2V0Q3NzRGltZW5zaW9ucyhlbGVtZW50KTtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHRcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVjdFJlbGF0aXZlVG9PZmZzZXRQYXJlbnQoZWxlbWVudCwgb2Zmc2V0UGFyZW50LCBzdHJhdGVneSkge1xuICBjb25zdCBpc09mZnNldFBhcmVudEFuRWxlbWVudCA9IGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgY29uc3QgZG9jdW1lbnRFbGVtZW50ID0gZ2V0RG9jdW1lbnRFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIGNvbnN0IGlzRml4ZWQgPSBzdHJhdGVneSA9PT0gJ2ZpeGVkJztcbiAgY29uc3QgcmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCB0cnVlLCBpc0ZpeGVkLCBvZmZzZXRQYXJlbnQpO1xuICBsZXQgc2Nyb2xsID0ge1xuICAgIHNjcm9sbExlZnQ6IDAsXG4gICAgc2Nyb2xsVG9wOiAwXG4gIH07XG4gIGNvbnN0IG9mZnNldHMgPSBjcmVhdGVDb29yZHMoMCk7XG5cbiAgLy8gSWYgdGhlIDxib2R5PiBzY3JvbGxiYXIgYXBwZWFycyBvbiB0aGUgbGVmdCAoZS5nLiBSVEwgc3lzdGVtcykuIFVzZVxuICAvLyBGaXJlZm94IHdpdGggbGF5b3V0LnNjcm9sbGJhci5zaWRlID0gMyBpbiBhYm91dDpjb25maWcgdG8gdGVzdCB0aGlzLlxuICBmdW5jdGlvbiBzZXRMZWZ0UlRMU2Nyb2xsYmFyT2Zmc2V0KCkge1xuICAgIG9mZnNldHMueCA9IGdldFdpbmRvd1Njcm9sbEJhclgoZG9jdW1lbnRFbGVtZW50KTtcbiAgfVxuICBpZiAoaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgfHwgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmICFpc0ZpeGVkKSB7XG4gICAgaWYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgIT09ICdib2R5JyB8fCBpc092ZXJmbG93RWxlbWVudChkb2N1bWVudEVsZW1lbnQpKSB7XG4gICAgICBzY3JvbGwgPSBnZXROb2RlU2Nyb2xsKG9mZnNldFBhcmVudCk7XG4gICAgfVxuICAgIGlmIChpc09mZnNldFBhcmVudEFuRWxlbWVudCkge1xuICAgICAgY29uc3Qgb2Zmc2V0UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChvZmZzZXRQYXJlbnQsIHRydWUsIGlzRml4ZWQsIG9mZnNldFBhcmVudCk7XG4gICAgICBvZmZzZXRzLnggPSBvZmZzZXRSZWN0LnggKyBvZmZzZXRQYXJlbnQuY2xpZW50TGVmdDtcbiAgICAgIG9mZnNldHMueSA9IG9mZnNldFJlY3QueSArIG9mZnNldFBhcmVudC5jbGllbnRUb3A7XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIHNldExlZnRSVExTY3JvbGxiYXJPZmZzZXQoKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzRml4ZWQgJiYgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmIGRvY3VtZW50RWxlbWVudCkge1xuICAgIHNldExlZnRSVExTY3JvbGxiYXJPZmZzZXQoKTtcbiAgfVxuICBjb25zdCBodG1sT2Zmc2V0ID0gZG9jdW1lbnRFbGVtZW50ICYmICFpc09mZnNldFBhcmVudEFuRWxlbWVudCAmJiAhaXNGaXhlZCA/IGdldEhUTUxPZmZzZXQoZG9jdW1lbnRFbGVtZW50LCBzY3JvbGwpIDogY3JlYXRlQ29vcmRzKDApO1xuICBjb25zdCB4ID0gcmVjdC5sZWZ0ICsgc2Nyb2xsLnNjcm9sbExlZnQgLSBvZmZzZXRzLnggLSBodG1sT2Zmc2V0Lng7XG4gIGNvbnN0IHkgPSByZWN0LnRvcCArIHNjcm9sbC5zY3JvbGxUb3AgLSBvZmZzZXRzLnkgLSBodG1sT2Zmc2V0Lnk7XG4gIHJldHVybiB7XG4gICAgeCxcbiAgICB5LFxuICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgIGhlaWdodDogcmVjdC5oZWlnaHRcbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNTdGF0aWNQb3NpdGlvbmVkKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24gPT09ICdzdGF0aWMnO1xufVxuXG5mdW5jdGlvbiBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQsIHBvbHlmaWxsKSB7XG4gIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHBvbHlmaWxsKSB7XG4gICAgcmV0dXJuIHBvbHlmaWxsKGVsZW1lbnQpO1xuICB9XG4gIGxldCByYXdPZmZzZXRQYXJlbnQgPSBlbGVtZW50Lm9mZnNldFBhcmVudDtcblxuICAvLyBGaXJlZm94IHJldHVybnMgdGhlIDxodG1sPiBlbGVtZW50IGFzIHRoZSBvZmZzZXRQYXJlbnQgaWYgaXQncyBub24tc3RhdGljLFxuICAvLyB3aGlsZSBDaHJvbWUgYW5kIFNhZmFyaSByZXR1cm4gdGhlIDxib2R5PiBlbGVtZW50LiBUaGUgPGJvZHk+IGVsZW1lbnQgbXVzdFxuICAvLyBiZSB1c2VkIHRvIHBlcmZvcm0gdGhlIGNvcnJlY3QgY2FsY3VsYXRpb25zIGV2ZW4gaWYgdGhlIDxodG1sPiBlbGVtZW50IGlzXG4gIC8vIG5vbi1zdGF0aWMuXG4gIGlmIChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkgPT09IHJhd09mZnNldFBhcmVudCkge1xuICAgIHJhd09mZnNldFBhcmVudCA9IHJhd09mZnNldFBhcmVudC5vd25lckRvY3VtZW50LmJvZHk7XG4gIH1cbiAgcmV0dXJuIHJhd09mZnNldFBhcmVudDtcbn1cblxuLy8gR2V0cyB0aGUgY2xvc2VzdCBhbmNlc3RvciBwb3NpdGlvbmVkIGVsZW1lbnQuIEhhbmRsZXMgc29tZSBlZGdlIGNhc2VzLFxuLy8gc3VjaCBhcyB0YWJsZSBhbmNlc3RvcnMgYW5kIGNyb3NzIGJyb3dzZXIgYnVncy5cbmZ1bmN0aW9uIGdldE9mZnNldFBhcmVudChlbGVtZW50LCBwb2x5ZmlsbCkge1xuICBjb25zdCB3aW4gPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIGlmIChpc1RvcExheWVyKGVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIHdpbjtcbiAgfVxuICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICBsZXQgc3ZnT2Zmc2V0UGFyZW50ID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcbiAgICB3aGlsZSAoc3ZnT2Zmc2V0UGFyZW50ICYmICFpc0xhc3RUcmF2ZXJzYWJsZU5vZGUoc3ZnT2Zmc2V0UGFyZW50KSkge1xuICAgICAgaWYgKGlzRWxlbWVudChzdmdPZmZzZXRQYXJlbnQpICYmICFpc1N0YXRpY1Bvc2l0aW9uZWQoc3ZnT2Zmc2V0UGFyZW50KSkge1xuICAgICAgICByZXR1cm4gc3ZnT2Zmc2V0UGFyZW50O1xuICAgICAgfVxuICAgICAgc3ZnT2Zmc2V0UGFyZW50ID0gZ2V0UGFyZW50Tm9kZShzdmdPZmZzZXRQYXJlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gd2luO1xuICB9XG4gIGxldCBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQsIHBvbHlmaWxsKTtcbiAgd2hpbGUgKG9mZnNldFBhcmVudCAmJiBpc1RhYmxlRWxlbWVudChvZmZzZXRQYXJlbnQpICYmIGlzU3RhdGljUG9zaXRpb25lZChvZmZzZXRQYXJlbnQpKSB7XG4gICAgb2Zmc2V0UGFyZW50ID0gZ2V0VHJ1ZU9mZnNldFBhcmVudChvZmZzZXRQYXJlbnQsIHBvbHlmaWxsKTtcbiAgfVxuICBpZiAob2Zmc2V0UGFyZW50ICYmIGlzTGFzdFRyYXZlcnNhYmxlTm9kZShvZmZzZXRQYXJlbnQpICYmIGlzU3RhdGljUG9zaXRpb25lZChvZmZzZXRQYXJlbnQpICYmICFpc0NvbnRhaW5pbmdCbG9jayhvZmZzZXRQYXJlbnQpKSB7XG4gICAgcmV0dXJuIHdpbjtcbiAgfVxuICByZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGdldENvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB8fCB3aW47XG59XG5cbmNvbnN0IGdldEVsZW1lbnRSZWN0cyA9IGFzeW5jIGZ1bmN0aW9uIChkYXRhKSB7XG4gIGNvbnN0IGdldE9mZnNldFBhcmVudEZuID0gdGhpcy5nZXRPZmZzZXRQYXJlbnQgfHwgZ2V0T2Zmc2V0UGFyZW50O1xuICBjb25zdCBnZXREaW1lbnNpb25zRm4gPSB0aGlzLmdldERpbWVuc2lvbnM7XG4gIGNvbnN0IGZsb2F0aW5nRGltZW5zaW9ucyA9IGF3YWl0IGdldERpbWVuc2lvbnNGbihkYXRhLmZsb2F0aW5nKTtcbiAgcmV0dXJuIHtcbiAgICByZWZlcmVuY2U6IGdldFJlY3RSZWxhdGl2ZVRvT2Zmc2V0UGFyZW50KGRhdGEucmVmZXJlbmNlLCBhd2FpdCBnZXRPZmZzZXRQYXJlbnRGbihkYXRhLmZsb2F0aW5nKSwgZGF0YS5zdHJhdGVneSksXG4gICAgZmxvYXRpbmc6IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgd2lkdGg6IGZsb2F0aW5nRGltZW5zaW9ucy53aWR0aCxcbiAgICAgIGhlaWdodDogZmxvYXRpbmdEaW1lbnNpb25zLmhlaWdodFxuICAgIH1cbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGlzUlRMKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZGlyZWN0aW9uID09PSAncnRsJztcbn1cblxuY29uc3QgcGxhdGZvcm0gPSB7XG4gIGNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0LFxuICBnZXREb2N1bWVudEVsZW1lbnQsXG4gIGdldENsaXBwaW5nUmVjdCxcbiAgZ2V0T2Zmc2V0UGFyZW50LFxuICBnZXRFbGVtZW50UmVjdHMsXG4gIGdldENsaWVudFJlY3RzLFxuICBnZXREaW1lbnNpb25zLFxuICBnZXRTY2FsZSxcbiAgaXNFbGVtZW50LFxuICBpc1JUTFxufTtcblxuZnVuY3Rpb24gcmVjdHNBcmVFcXVhbChhLCBiKSB7XG4gIHJldHVybiBhLnggPT09IGIueCAmJiBhLnkgPT09IGIueSAmJiBhLndpZHRoID09PSBiLndpZHRoICYmIGEuaGVpZ2h0ID09PSBiLmhlaWdodDtcbn1cblxuLy8gaHR0cHM6Ly9zYW10aG9yLmF1LzIwMjEvb2JzZXJ2aW5nLWRvbS9cbmZ1bmN0aW9uIG9ic2VydmVNb3ZlKGVsZW1lbnQsIG9uTW92ZSkge1xuICBsZXQgaW8gPSBudWxsO1xuICBsZXQgdGltZW91dElkO1xuICBjb25zdCByb290ID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIHZhciBfaW87XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgKF9pbyA9IGlvKSA9PSBudWxsIHx8IF9pby5kaXNjb25uZWN0KCk7XG4gICAgaW8gPSBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIHJlZnJlc2goc2tpcCwgdGhyZXNob2xkKSB7XG4gICAgaWYgKHNraXAgPT09IHZvaWQgMCkge1xuICAgICAgc2tpcCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGhyZXNob2xkID09PSB2b2lkIDApIHtcbiAgICAgIHRocmVzaG9sZCA9IDE7XG4gICAgfVxuICAgIGNsZWFudXAoKTtcbiAgICBjb25zdCBlbGVtZW50UmVjdEZvclJvb3RNYXJnaW4gPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IHtcbiAgICAgIGxlZnQsXG4gICAgICB0b3AsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBlbGVtZW50UmVjdEZvclJvb3RNYXJnaW47XG4gICAgaWYgKCFza2lwKSB7XG4gICAgICBvbk1vdmUoKTtcbiAgICB9XG4gICAgaWYgKCF3aWR0aCB8fCAhaGVpZ2h0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGluc2V0VG9wID0gZmxvb3IodG9wKTtcbiAgICBjb25zdCBpbnNldFJpZ2h0ID0gZmxvb3Iocm9vdC5jbGllbnRXaWR0aCAtIChsZWZ0ICsgd2lkdGgpKTtcbiAgICBjb25zdCBpbnNldEJvdHRvbSA9IGZsb29yKHJvb3QuY2xpZW50SGVpZ2h0IC0gKHRvcCArIGhlaWdodCkpO1xuICAgIGNvbnN0IGluc2V0TGVmdCA9IGZsb29yKGxlZnQpO1xuICAgIGNvbnN0IHJvb3RNYXJnaW4gPSAtaW5zZXRUb3AgKyBcInB4IFwiICsgLWluc2V0UmlnaHQgKyBcInB4IFwiICsgLWluc2V0Qm90dG9tICsgXCJweCBcIiArIC1pbnNldExlZnQgKyBcInB4XCI7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIHJvb3RNYXJnaW4sXG4gICAgICB0aHJlc2hvbGQ6IG1heCgwLCBtaW4oMSwgdGhyZXNob2xkKSkgfHwgMVxuICAgIH07XG4gICAgbGV0IGlzRmlyc3RVcGRhdGUgPSB0cnVlO1xuICAgIGZ1bmN0aW9uIGhhbmRsZU9ic2VydmUoZW50cmllcykge1xuICAgICAgY29uc3QgcmF0aW8gPSBlbnRyaWVzWzBdLmludGVyc2VjdGlvblJhdGlvO1xuICAgICAgaWYgKHJhdGlvICE9PSB0aHJlc2hvbGQpIHtcbiAgICAgICAgaWYgKCFpc0ZpcnN0VXBkYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIHJlZnJlc2goKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJhdGlvKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIHJlZmVyZW5jZSBpcyBjbGlwcGVkLCB0aGUgcmF0aW8gaXMgMC4gVGhyb3R0bGUgdGhlIHJlZnJlc2hcbiAgICAgICAgICAvLyB0byBwcmV2ZW50IGFuIGluZmluaXRlIGxvb3Agb2YgdXBkYXRlcy5cbiAgICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHJlZnJlc2goZmFsc2UsIDFlLTcpO1xuICAgICAgICAgIH0sIDEwMDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlZnJlc2goZmFsc2UsIHJhdGlvKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHJhdGlvID09PSAxICYmICFyZWN0c0FyZUVxdWFsKGVsZW1lbnRSZWN0Rm9yUm9vdE1hcmdpbiwgZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSkpIHtcbiAgICAgICAgLy8gSXQncyBwb3NzaWJsZSB0aGF0IGV2ZW4gdGhvdWdoIHRoZSByYXRpbyBpcyByZXBvcnRlZCBhcyAxLCB0aGVcbiAgICAgICAgLy8gZWxlbWVudCBpcyBub3QgYWN0dWFsbHkgZnVsbHkgd2l0aGluIHRoZSBJbnRlcnNlY3Rpb25PYnNlcnZlcidzIHJvb3RcbiAgICAgICAgLy8gYXJlYSBhbnltb3JlLiBUaGlzIGNhbiBoYXBwZW4gdW5kZXIgcGVyZm9ybWFuY2UgY29uc3RyYWludHMuIFRoaXMgbWF5XG4gICAgICAgIC8vIGJlIGEgYnVnIGluIHRoZSBicm93c2VyJ3MgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgaW1wbGVtZW50YXRpb24uIFRvXG4gICAgICAgIC8vIHdvcmsgYXJvdW5kIHRoaXMsIHdlIGNvbXBhcmUgdGhlIGVsZW1lbnQncyBib3VuZGluZyByZWN0IG5vdyB3aXRoXG4gICAgICAgIC8vIHdoYXQgaXQgd2FzIGF0IHRoZSB0aW1lIHdlIGNyZWF0ZWQgdGhlIEludGVyc2VjdGlvbk9ic2VydmVyLiBJZiB0aGV5XG4gICAgICAgIC8vIGFyZSBub3QgZXF1YWwgdGhlbiB0aGUgZWxlbWVudCBtb3ZlZCwgc28gd2UgcmVmcmVzaC5cbiAgICAgICAgcmVmcmVzaCgpO1xuICAgICAgfVxuICAgICAgaXNGaXJzdFVwZGF0ZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIE9sZGVyIGJyb3dzZXJzIGRvbid0IHN1cHBvcnQgYSBgZG9jdW1lbnRgIGFzIHRoZSByb290IGFuZCB3aWxsIHRocm93IGFuXG4gICAgLy8gZXJyb3IuXG4gICAgdHJ5IHtcbiAgICAgIGlvID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGhhbmRsZU9ic2VydmUsIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgLy8gSGFuZGxlIDxpZnJhbWU+c1xuICAgICAgICByb290OiByb290Lm93bmVyRG9jdW1lbnRcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKF9lKSB7XG4gICAgICBpbyA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihoYW5kbGVPYnNlcnZlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgaW8ub2JzZXJ2ZShlbGVtZW50KTtcbiAgfVxuICByZWZyZXNoKHRydWUpO1xuICByZXR1cm4gY2xlYW51cDtcbn1cblxuLyoqXG4gKiBBdXRvbWF0aWNhbGx5IHVwZGF0ZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IHdoZW4gbmVjZXNzYXJ5LlxuICogU2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW4gdGhlIGZsb2F0aW5nIGVsZW1lbnQgaXMgbW91bnRlZCBvbiB0aGUgRE9NIG9yXG4gKiB2aXNpYmxlIG9uIHRoZSBzY3JlZW4uXG4gKiBAcmV0dXJucyBjbGVhbnVwIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGludm9rZWQgd2hlbiB0aGUgZmxvYXRpbmcgZWxlbWVudCBpc1xuICogcmVtb3ZlZCBmcm9tIHRoZSBET00gb3IgaGlkZGVuIGZyb20gdGhlIHNjcmVlbi5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9hdXRvVXBkYXRlXG4gKi9cbmZ1bmN0aW9uIGF1dG9VcGRhdGUocmVmZXJlbmNlLCBmbG9hdGluZywgdXBkYXRlLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIGFuY2VzdG9yU2Nyb2xsID0gdHJ1ZSxcbiAgICBhbmNlc3RvclJlc2l6ZSA9IHRydWUsXG4gICAgZWxlbWVudFJlc2l6ZSA9IHR5cGVvZiBSZXNpemVPYnNlcnZlciA9PT0gJ2Z1bmN0aW9uJyxcbiAgICBsYXlvdXRTaGlmdCA9IHR5cGVvZiBJbnRlcnNlY3Rpb25PYnNlcnZlciA9PT0gJ2Z1bmN0aW9uJyxcbiAgICBhbmltYXRpb25GcmFtZSA9IGZhbHNlXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCByZWZlcmVuY2VFbCA9IHVud3JhcEVsZW1lbnQocmVmZXJlbmNlKTtcbiAgY29uc3QgYW5jZXN0b3JzID0gYW5jZXN0b3JTY3JvbGwgfHwgYW5jZXN0b3JSZXNpemUgPyBbLi4uKHJlZmVyZW5jZUVsID8gZ2V0T3ZlcmZsb3dBbmNlc3RvcnMocmVmZXJlbmNlRWwpIDogW10pLCAuLi5nZXRPdmVyZmxvd0FuY2VzdG9ycyhmbG9hdGluZyldIDogW107XG4gIGFuY2VzdG9ycy5mb3JFYWNoKGFuY2VzdG9yID0+IHtcbiAgICBhbmNlc3RvclNjcm9sbCAmJiBhbmNlc3Rvci5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB1cGRhdGUsIHtcbiAgICAgIHBhc3NpdmU6IHRydWVcbiAgICB9KTtcbiAgICBhbmNlc3RvclJlc2l6ZSAmJiBhbmNlc3Rvci5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB1cGRhdGUpO1xuICB9KTtcbiAgY29uc3QgY2xlYW51cElvID0gcmVmZXJlbmNlRWwgJiYgbGF5b3V0U2hpZnQgPyBvYnNlcnZlTW92ZShyZWZlcmVuY2VFbCwgdXBkYXRlKSA6IG51bGw7XG4gIGxldCByZW9ic2VydmVGcmFtZSA9IC0xO1xuICBsZXQgcmVzaXplT2JzZXJ2ZXIgPSBudWxsO1xuICBpZiAoZWxlbWVudFJlc2l6ZSkge1xuICAgIHJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKF9yZWYgPT4ge1xuICAgICAgbGV0IFtmaXJzdEVudHJ5XSA9IF9yZWY7XG4gICAgICBpZiAoZmlyc3RFbnRyeSAmJiBmaXJzdEVudHJ5LnRhcmdldCA9PT0gcmVmZXJlbmNlRWwgJiYgcmVzaXplT2JzZXJ2ZXIpIHtcbiAgICAgICAgLy8gUHJldmVudCB1cGRhdGUgbG9vcHMgd2hlbiB1c2luZyB0aGUgYHNpemVgIG1pZGRsZXdhcmUuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mbG9hdGluZy11aS9mbG9hdGluZy11aS9pc3N1ZXMvMTc0MFxuICAgICAgICByZXNpemVPYnNlcnZlci51bm9ic2VydmUoZmxvYXRpbmcpO1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShyZW9ic2VydmVGcmFtZSk7XG4gICAgICAgIHJlb2JzZXJ2ZUZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICB2YXIgX3Jlc2l6ZU9ic2VydmVyO1xuICAgICAgICAgIChfcmVzaXplT2JzZXJ2ZXIgPSByZXNpemVPYnNlcnZlcikgPT0gbnVsbCB8fCBfcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShmbG9hdGluZyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdXBkYXRlKCk7XG4gICAgfSk7XG4gICAgaWYgKHJlZmVyZW5jZUVsICYmICFhbmltYXRpb25GcmFtZSkge1xuICAgICAgcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShyZWZlcmVuY2VFbCk7XG4gICAgfVxuICAgIHJlc2l6ZU9ic2VydmVyLm9ic2VydmUoZmxvYXRpbmcpO1xuICB9XG4gIGxldCBmcmFtZUlkO1xuICBsZXQgcHJldlJlZlJlY3QgPSBhbmltYXRpb25GcmFtZSA/IGdldEJvdW5kaW5nQ2xpZW50UmVjdChyZWZlcmVuY2UpIDogbnVsbDtcbiAgaWYgKGFuaW1hdGlvbkZyYW1lKSB7XG4gICAgZnJhbWVMb29wKCk7XG4gIH1cbiAgZnVuY3Rpb24gZnJhbWVMb29wKCkge1xuICAgIGNvbnN0IG5leHRSZWZSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHJlZmVyZW5jZSk7XG4gICAgaWYgKHByZXZSZWZSZWN0ICYmICFyZWN0c0FyZUVxdWFsKHByZXZSZWZSZWN0LCBuZXh0UmVmUmVjdCkpIHtcbiAgICAgIHVwZGF0ZSgpO1xuICAgIH1cbiAgICBwcmV2UmVmUmVjdCA9IG5leHRSZWZSZWN0O1xuICAgIGZyYW1lSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnJhbWVMb29wKTtcbiAgfVxuICB1cGRhdGUoKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICB2YXIgX3Jlc2l6ZU9ic2VydmVyMjtcbiAgICBhbmNlc3RvcnMuZm9yRWFjaChhbmNlc3RvciA9PiB7XG4gICAgICBhbmNlc3RvclNjcm9sbCAmJiBhbmNlc3Rvci5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB1cGRhdGUpO1xuICAgICAgYW5jZXN0b3JSZXNpemUgJiYgYW5jZXN0b3IucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdXBkYXRlKTtcbiAgICB9KTtcbiAgICBjbGVhbnVwSW8gPT0gbnVsbCB8fCBjbGVhbnVwSW8oKTtcbiAgICAoX3Jlc2l6ZU9ic2VydmVyMiA9IHJlc2l6ZU9ic2VydmVyKSA9PSBudWxsIHx8IF9yZXNpemVPYnNlcnZlcjIuZGlzY29ubmVjdCgpO1xuICAgIHJlc2l6ZU9ic2VydmVyID0gbnVsbDtcbiAgICBpZiAoYW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGZyYW1lSWQpO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBSZXNvbHZlcyB3aXRoIGFuIG9iamVjdCBvZiBvdmVyZmxvdyBzaWRlIG9mZnNldHMgdGhhdCBkZXRlcm1pbmUgaG93IG11Y2ggdGhlXG4gKiBlbGVtZW50IGlzIG92ZXJmbG93aW5nIGEgZ2l2ZW4gY2xpcHBpbmcgYm91bmRhcnkgb24gZWFjaCBzaWRlLlxuICogLSBwb3NpdGl2ZSA9IG92ZXJmbG93aW5nIHRoZSBib3VuZGFyeSBieSB0aGF0IG51bWJlciBvZiBwaXhlbHNcbiAqIC0gbmVnYXRpdmUgPSBob3cgbWFueSBwaXhlbHMgbGVmdCBiZWZvcmUgaXQgd2lsbCBvdmVyZmxvd1xuICogLSAwID0gbGllcyBmbHVzaCB3aXRoIHRoZSBib3VuZGFyeVxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2RldGVjdE92ZXJmbG93XG4gKi9cbmNvbnN0IGRldGVjdE92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3ckMTtcblxuLyoqXG4gKiBNb2RpZmllcyB0aGUgcGxhY2VtZW50IGJ5IHRyYW5zbGF0aW5nIHRoZSBmbG9hdGluZyBlbGVtZW50IGFsb25nIHRoZVxuICogc3BlY2lmaWVkIGF4ZXMuXG4gKiBBIG51bWJlciAoc2hvcnRoYW5kIGZvciBgbWFpbkF4aXNgIG9yIGRpc3RhbmNlKSwgb3IgYW4gYXhlcyBjb25maWd1cmF0aW9uXG4gKiBvYmplY3QgbWF5IGJlIHBhc3NlZC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9vZmZzZXRcbiAqL1xuY29uc3Qgb2Zmc2V0ID0gb2Zmc2V0JDE7XG5cbi8qKlxuICogT3B0aW1pemVzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IGJ5IGNob29zaW5nIHRoZSBwbGFjZW1lbnRcbiAqIHRoYXQgaGFzIHRoZSBtb3N0IHNwYWNlIGF2YWlsYWJsZSBhdXRvbWF0aWNhbGx5LCB3aXRob3V0IG5lZWRpbmcgdG8gc3BlY2lmeSBhXG4gKiBwcmVmZXJyZWQgcGxhY2VtZW50LiBBbHRlcm5hdGl2ZSB0byBgZmxpcGAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvYXV0b1BsYWNlbWVudFxuICovXG5jb25zdCBhdXRvUGxhY2VtZW50ID0gYXV0b1BsYWNlbWVudCQxO1xuXG4vKipcbiAqIE9wdGltaXplcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBieSBzaGlmdGluZyBpdCBpbiBvcmRlciB0b1xuICoga2VlcCBpdCBpbiB2aWV3IHdoZW4gaXQgd2lsbCBvdmVyZmxvdyB0aGUgY2xpcHBpbmcgYm91bmRhcnkuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3Mvc2hpZnRcbiAqL1xuY29uc3Qgc2hpZnQgPSBzaGlmdCQxO1xuXG4vKipcbiAqIE9wdGltaXplcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBieSBmbGlwcGluZyB0aGUgYHBsYWNlbWVudGBcbiAqIGluIG9yZGVyIHRvIGtlZXAgaXQgaW4gdmlldyB3aGVuIHRoZSBwcmVmZXJyZWQgcGxhY2VtZW50KHMpIHdpbGwgb3ZlcmZsb3cgdGhlXG4gKiBjbGlwcGluZyBib3VuZGFyeS4gQWx0ZXJuYXRpdmUgdG8gYGF1dG9QbGFjZW1lbnRgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2ZsaXBcbiAqL1xuY29uc3QgZmxpcCA9IGZsaXAkMTtcblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRoYXQgYWxsb3dzIHlvdSB0byBjaGFuZ2UgdGhlIHNpemUgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQg4oCUXG4gKiBmb3IgaW5zdGFuY2UsIHByZXZlbnQgaXQgZnJvbSBvdmVyZmxvd2luZyB0aGUgY2xpcHBpbmcgYm91bmRhcnkgb3IgbWF0Y2ggdGhlXG4gKiB3aWR0aCBvZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3Mvc2l6ZVxuICovXG5jb25zdCBzaXplID0gc2l6ZSQxO1xuXG4vKipcbiAqIFByb3ZpZGVzIGRhdGEgdG8gaGlkZSB0aGUgZmxvYXRpbmcgZWxlbWVudCBpbiBhcHBsaWNhYmxlIHNpdHVhdGlvbnMsIHN1Y2ggYXNcbiAqIHdoZW4gaXQgaXMgbm90IGluIHRoZSBzYW1lIGNsaXBwaW5nIGNvbnRleHQgYXMgdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2hpZGVcbiAqL1xuY29uc3QgaGlkZSA9IGhpZGUkMTtcblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRvIHBvc2l0aW9uIGFuIGlubmVyIGVsZW1lbnQgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgc28gdGhhdCBpdFxuICogYXBwZWFycyBjZW50ZXJlZCB0byB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvYXJyb3dcbiAqL1xuY29uc3QgYXJyb3cgPSBhcnJvdyQxO1xuXG4vKipcbiAqIFByb3ZpZGVzIGltcHJvdmVkIHBvc2l0aW9uaW5nIGZvciBpbmxpbmUgcmVmZXJlbmNlIGVsZW1lbnRzIHRoYXQgY2FuIHNwYW5cbiAqIG92ZXIgbXVsdGlwbGUgbGluZXMsIHN1Y2ggYXMgaHlwZXJsaW5rcyBvciByYW5nZSBzZWxlY3Rpb25zLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2lubGluZVxuICovXG5jb25zdCBpbmxpbmUgPSBpbmxpbmUkMTtcblxuLyoqXG4gKiBCdWlsdC1pbiBgbGltaXRlcmAgdGhhdCB3aWxsIHN0b3AgYHNoaWZ0KClgIGF0IGEgY2VydGFpbiBwb2ludC5cbiAqL1xuY29uc3QgbGltaXRTaGlmdCA9IGxpbWl0U2hpZnQkMTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgYHhgIGFuZCBgeWAgY29vcmRpbmF0ZXMgdGhhdCB3aWxsIHBsYWNlIHRoZSBmbG9hdGluZyBlbGVtZW50XG4gKiBuZXh0IHRvIGEgZ2l2ZW4gcmVmZXJlbmNlIGVsZW1lbnQuXG4gKi9cbmNvbnN0IGNvbXB1dGVQb3NpdGlvbiA9IChyZWZlcmVuY2UsIGZsb2F0aW5nLCBvcHRpb25zKSA9PiB7XG4gIC8vIFRoaXMgY2FjaGVzIHRoZSBleHBlbnNpdmUgYGdldENsaXBwaW5nRWxlbWVudEFuY2VzdG9yc2AgZnVuY3Rpb24gc28gdGhhdFxuICAvLyBtdWx0aXBsZSBsaWZlY3ljbGUgcmVzZXRzIHJlLXVzZSB0aGUgc2FtZSByZXN1bHQuIEl0IG9ubHkgbGl2ZXMgZm9yIGFcbiAgLy8gc2luZ2xlIGNhbGwuIElmIG90aGVyIGZ1bmN0aW9ucyBiZWNvbWUgZXhwZW5zaXZlLCB3ZSBjYW4gYWRkIHRoZW0gYXMgd2VsbC5cbiAgY29uc3QgY2FjaGUgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IG1lcmdlZE9wdGlvbnMgPSB7XG4gICAgcGxhdGZvcm0sXG4gICAgLi4ub3B0aW9uc1xuICB9O1xuICBjb25zdCBwbGF0Zm9ybVdpdGhDYWNoZSA9IHtcbiAgICAuLi5tZXJnZWRPcHRpb25zLnBsYXRmb3JtLFxuICAgIF9jOiBjYWNoZVxuICB9O1xuICByZXR1cm4gY29tcHV0ZVBvc2l0aW9uJDEocmVmZXJlbmNlLCBmbG9hdGluZywge1xuICAgIC4uLm1lcmdlZE9wdGlvbnMsXG4gICAgcGxhdGZvcm06IHBsYXRmb3JtV2l0aENhY2hlXG4gIH0pO1xufTtcblxuZXhwb3J0IHsgYXJyb3csIGF1dG9QbGFjZW1lbnQsIGF1dG9VcGRhdGUsIGNvbXB1dGVQb3NpdGlvbiwgZGV0ZWN0T3ZlcmZsb3csIGZsaXAsIGhpZGUsIGlubGluZSwgbGltaXRTaGlmdCwgb2Zmc2V0LCBwbGF0Zm9ybSwgc2hpZnQsIHNpemUgfTtcbiJdLCJuYW1lcyI6WyJyZWN0VG9DbGllbnRSZWN0IiwiYXJyb3ciLCJhcnJvdyQxIiwiYXV0b1BsYWNlbWVudCIsImF1dG9QbGFjZW1lbnQkMSIsImRldGVjdE92ZXJmbG93IiwiZGV0ZWN0T3ZlcmZsb3ckMSIsImZsaXAiLCJmbGlwJDEiLCJoaWRlIiwiaGlkZSQxIiwiaW5saW5lIiwiaW5saW5lJDEiLCJsaW1pdFNoaWZ0IiwibGltaXRTaGlmdCQxIiwib2Zmc2V0Iiwib2Zmc2V0JDEiLCJzaGlmdCIsInNoaWZ0JDEiLCJzaXplIiwic2l6ZSQxIiwiY29tcHV0ZVBvc2l0aW9uIiwiY29tcHV0ZVBvc2l0aW9uJDEiLCJyb3VuZCIsImNyZWF0ZUNvb3JkcyIsIm1heCIsIm1pbiIsImZsb29yIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImlzSFRNTEVsZW1lbnQiLCJpc0VsZW1lbnQiLCJnZXRXaW5kb3ciLCJpc1dlYktpdCIsImdldEZyYW1lRWxlbWVudCIsImdldE5vZGVTY3JvbGwiLCJnZXREb2N1bWVudEVsZW1lbnQiLCJpc1RvcExheWVyIiwiZ2V0Tm9kZU5hbWUiLCJpc092ZXJmbG93RWxlbWVudCIsImdldE92ZXJmbG93QW5jZXN0b3JzIiwiZ2V0UGFyZW50Tm9kZSIsImlzTGFzdFRyYXZlcnNhYmxlTm9kZSIsImlzQ29udGFpbmluZ0Jsb2NrIiwiaXNUYWJsZUVsZW1lbnQiLCJnZXRDb250YWluaW5nQmxvY2siLCJnZXRDc3NEaW1lbnNpb25zIiwiZWxlbWVudCIsImNzcyIsIndpZHRoIiwicGFyc2VGbG9hdCIsImhlaWdodCIsImhhc09mZnNldCIsIm9mZnNldFdpZHRoIiwib2Zmc2V0SGVpZ2h0Iiwic2hvdWxkRmFsbGJhY2siLCIkIiwidW53cmFwRWxlbWVudCIsImNvbnRleHRFbGVtZW50IiwiZ2V0U2NhbGUiLCJkb21FbGVtZW50IiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIngiLCJ5IiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJub09mZnNldHMiLCJnZXRWaXN1YWxPZmZzZXRzIiwid2luIiwidmlzdWFsVmlld3BvcnQiLCJvZmZzZXRMZWZ0Iiwib2Zmc2V0VG9wIiwic2hvdWxkQWRkVmlzdWFsT2Zmc2V0cyIsImlzRml4ZWQiLCJmbG9hdGluZ09mZnNldFBhcmVudCIsImluY2x1ZGVTY2FsZSIsImlzRml4ZWRTdHJhdGVneSIsIm9mZnNldFBhcmVudCIsImNsaWVudFJlY3QiLCJzY2FsZSIsInZpc3VhbE9mZnNldHMiLCJsZWZ0IiwidG9wIiwib2Zmc2V0V2luIiwiY3VycmVudFdpbiIsImN1cnJlbnRJRnJhbWUiLCJpZnJhbWVTY2FsZSIsImlmcmFtZVJlY3QiLCJjbGllbnRMZWZ0IiwicGFkZGluZ0xlZnQiLCJjbGllbnRUb3AiLCJwYWRkaW5nVG9wIiwiZ2V0V2luZG93U2Nyb2xsQmFyWCIsImxlZnRTY3JvbGwiLCJzY3JvbGxMZWZ0IiwiZ2V0SFRNTE9mZnNldCIsImRvY3VtZW50RWxlbWVudCIsInNjcm9sbCIsImlnbm9yZVNjcm9sbGJhclgiLCJodG1sUmVjdCIsInNjcm9sbFRvcCIsImNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0IiwiX3JlZiIsImVsZW1lbnRzIiwic3RyYXRlZ3kiLCJ0b3BMYXllciIsImZsb2F0aW5nIiwib2Zmc2V0cyIsImlzT2Zmc2V0UGFyZW50QW5FbGVtZW50Iiwib2Zmc2V0UmVjdCIsImh0bWxPZmZzZXQiLCJnZXRDbGllbnRSZWN0cyIsIkFycmF5IiwiZnJvbSIsImdldERvY3VtZW50UmVjdCIsImh0bWwiLCJib2R5Iiwib3duZXJEb2N1bWVudCIsInNjcm9sbFdpZHRoIiwiY2xpZW50V2lkdGgiLCJzY3JvbGxIZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJkaXJlY3Rpb24iLCJnZXRWaWV3cG9ydFJlY3QiLCJ2aXN1YWxWaWV3cG9ydEJhc2VkIiwiYWJzb2x1dGVPckZpeGVkIiwiU2V0IiwiZ2V0SW5uZXJCb3VuZGluZ0NsaWVudFJlY3QiLCJnZXRDbGllbnRSZWN0RnJvbUNsaXBwaW5nQW5jZXN0b3IiLCJjbGlwcGluZ0FuY2VzdG9yIiwiaGFzRml4ZWRQb3NpdGlvbkFuY2VzdG9yIiwic3RvcE5vZGUiLCJwYXJlbnROb2RlIiwicG9zaXRpb24iLCJnZXRDbGlwcGluZ0VsZW1lbnRBbmNlc3RvcnMiLCJjYWNoZSIsImNhY2hlZFJlc3VsdCIsImdldCIsInJlc3VsdCIsImZpbHRlciIsImVsIiwiY3VycmVudENvbnRhaW5pbmdCbG9ja0NvbXB1dGVkU3R5bGUiLCJlbGVtZW50SXNGaXhlZCIsImN1cnJlbnROb2RlIiwiY29tcHV0ZWRTdHlsZSIsImN1cnJlbnROb2RlSXNDb250YWluaW5nIiwic2hvdWxkRHJvcEN1cnJlbnROb2RlIiwiaGFzIiwiYW5jZXN0b3IiLCJzZXQiLCJnZXRDbGlwcGluZ1JlY3QiLCJib3VuZGFyeSIsInJvb3RCb3VuZGFyeSIsImVsZW1lbnRDbGlwcGluZ0FuY2VzdG9ycyIsIl9jIiwiY29uY2F0IiwiY2xpcHBpbmdBbmNlc3RvcnMiLCJmaXJzdENsaXBwaW5nQW5jZXN0b3IiLCJjbGlwcGluZ1JlY3QiLCJyZWR1Y2UiLCJhY2NSZWN0IiwicmlnaHQiLCJib3R0b20iLCJnZXREaW1lbnNpb25zIiwiZ2V0UmVjdFJlbGF0aXZlVG9PZmZzZXRQYXJlbnQiLCJzZXRMZWZ0UlRMU2Nyb2xsYmFyT2Zmc2V0IiwiaXNTdGF0aWNQb3NpdGlvbmVkIiwiZ2V0VHJ1ZU9mZnNldFBhcmVudCIsInBvbHlmaWxsIiwicmF3T2Zmc2V0UGFyZW50IiwiZ2V0T2Zmc2V0UGFyZW50Iiwic3ZnT2Zmc2V0UGFyZW50IiwiZ2V0RWxlbWVudFJlY3RzIiwiZGF0YSIsImdldE9mZnNldFBhcmVudEZuIiwiZ2V0RGltZW5zaW9uc0ZuIiwiZmxvYXRpbmdEaW1lbnNpb25zIiwicmVmZXJlbmNlIiwiaXNSVEwiLCJwbGF0Zm9ybSIsInJlY3RzQXJlRXF1YWwiLCJhIiwiYiIsIm9ic2VydmVNb3ZlIiwib25Nb3ZlIiwiaW8iLCJ0aW1lb3V0SWQiLCJyb290IiwiY2xlYW51cCIsIl9pbyIsImNsZWFyVGltZW91dCIsImRpc2Nvbm5lY3QiLCJyZWZyZXNoIiwic2tpcCIsInRocmVzaG9sZCIsImVsZW1lbnRSZWN0Rm9yUm9vdE1hcmdpbiIsImluc2V0VG9wIiwiaW5zZXRSaWdodCIsImluc2V0Qm90dG9tIiwiaW5zZXRMZWZ0Iiwicm9vdE1hcmdpbiIsIm9wdGlvbnMiLCJpc0ZpcnN0VXBkYXRlIiwiaGFuZGxlT2JzZXJ2ZSIsImVudHJpZXMiLCJyYXRpbyIsImludGVyc2VjdGlvblJhdGlvIiwic2V0VGltZW91dCIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwiX29iamVjdFNwcmVhZCIsIl9lIiwib2JzZXJ2ZSIsImF1dG9VcGRhdGUiLCJ1cGRhdGUiLCJhbmNlc3RvclNjcm9sbCIsImFuY2VzdG9yUmVzaXplIiwiZWxlbWVudFJlc2l6ZSIsIlJlc2l6ZU9ic2VydmVyIiwibGF5b3V0U2hpZnQiLCJhbmltYXRpb25GcmFtZSIsInJlZmVyZW5jZUVsIiwiYW5jZXN0b3JzIiwiZm9yRWFjaCIsImFkZEV2ZW50TGlzdGVuZXIiLCJwYXNzaXZlIiwiY2xlYW51cElvIiwicmVvYnNlcnZlRnJhbWUiLCJyZXNpemVPYnNlcnZlciIsImZpcnN0RW50cnkiLCJ0YXJnZXQiLCJ1bm9ic2VydmUiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIl9yZXNpemVPYnNlcnZlciIsImZyYW1lSWQiLCJwcmV2UmVmUmVjdCIsImZyYW1lTG9vcCIsIm5leHRSZWZSZWN0IiwiX3Jlc2l6ZU9ic2VydmVyMiIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJNYXAiLCJtZXJnZWRPcHRpb25zIiwicGxhdGZvcm1XaXRoQ2FjaGUiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@floating-ui/dom/node_modules/@floating-ui/core/dist/floating-ui.core.mjs":
/*!************************************************************************************************!*\
  !*** ./node_modules/@floating-ui/dom/node_modules/@floating-ui/core/dist/floating-ui.core.mjs ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrow: () => (/* binding */ arrow),\n/* harmony export */   autoPlacement: () => (/* binding */ autoPlacement),\n/* harmony export */   computePosition: () => (/* binding */ computePosition),\n/* harmony export */   detectOverflow: () => (/* binding */ detectOverflow),\n/* harmony export */   flip: () => (/* binding */ flip),\n/* harmony export */   hide: () => (/* binding */ hide),\n/* harmony export */   inline: () => (/* binding */ inline),\n/* harmony export */   limitShift: () => (/* binding */ limitShift),\n/* harmony export */   offset: () => (/* binding */ offset),\n/* harmony export */   rectToClientRect: () => (/* reexport safe */ _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect),\n/* harmony export */   shift: () => (/* binding */ shift),\n/* harmony export */   size: () => (/* binding */ size)\n/* harmony export */ });\n/* harmony import */ var _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/utils */ \"(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs\");\nconst _excluded = [\"crossAxis\", \"alignment\", \"allowedPlacements\", \"autoAlignment\"],\n  _excluded2 = [\"mainAxis\", \"crossAxis\", \"fallbackPlacements\", \"fallbackStrategy\", \"fallbackAxisSideDirection\", \"flipAlignment\"],\n  _excluded3 = [\"strategy\"],\n  _excluded4 = [\"mainAxis\", \"crossAxis\", \"limiter\"],\n  _excluded5 = [\"apply\"];\nfunction _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }\nfunction _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement);\n  const alignmentAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentAxis)(placement);\n  const alignLength = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAxisLength)(alignmentAxis);\n  const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);\n  const isVertical = sideAxis === 'y';\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch ((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement)) {\n    case 'start':\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = _objectSpread(_objectSpread({}, middlewareData), {}, {\n      [name]: _objectSpread(_objectSpread({}, middlewareData[name]), data)\n    });\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n  const paddingObject = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getPaddingObject)(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    x,\n    y,\n    width: rects.floating.width,\n    height: rects.floating.height\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements,\n      middlewareData\n    } = state;\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state) || {};\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getPaddingObject)(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentAxis)(placement);\n    const length = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAxisLength)(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // If the padding is large enough that it causes the arrow to no longer be\n    // centered, modify the padding so that it is centered.\n    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n    const minPadding = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(paddingObject[minProp], largestPossiblePadding);\n    const maxPadding = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(paddingObject[maxProp], largestPossiblePadding);\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min$1 = minPadding;\n    const max = clientSize - arrowDimensions[length] - maxPadding;\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.clamp)(min$1, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. To ensure `shift()` continues to take action,\n    // a single reset is performed when this is true.\n    const shouldAddOffset = !middlewareData.arrow && (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n    return {\n      [axis]: coords[axis] + alignmentOffset,\n      data: _objectSpread({\n        [axis]: offset,\n        centerOffset: center - offset - alignmentOffset\n      }, shouldAddOffset && {\n        alignmentOffset\n      }),\n      reset: shouldAddOffset\n    };\n  }\n});\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) === alignment), ...allowedPlacements.filter(placement => (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) !== alignment)] : allowedPlacements.filter(placement => (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) === alignment || (autoAlignment ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAlignmentPlacement)(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = state;\n      const _evaluate = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state),\n        {\n          crossAxis = false,\n          alignment,\n          allowedPlacements = _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.placements,\n          autoAlignment = true\n        } = _evaluate,\n        detectOverflowOptions = _objectWithoutProperties(_evaluate, _excluded);\n      const placements$1 = alignment !== undefined || allowedPlacements === _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements$1[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const alignmentSides = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentSides)(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place.\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements$1[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements$1[currentIndex + 1];\n\n      // There are more placements to check.\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows.map(d => {\n        const alignment = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(d.placement);\n        return [d.placement, alignment && crossAxis ?\n        // Check along the mainAxis and main crossAxis side.\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n        // Check only the mainAxis.\n        d.overflows[0], d.overflows];\n      }).sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n      // Aligned placements should not check their opposite crossAxis\n      // side.\n      (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(d[0]) ? 2 : 3).every(v => v <= 0));\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$arrow, _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const _evaluate2 = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state),\n        {\n          mainAxis: checkMainAxis = true,\n          crossAxis: checkCrossAxis = true,\n          fallbackPlacements: specifiedFallbackPlacements,\n          fallbackStrategy = 'bestFit',\n          fallbackAxisSideDirection = 'none',\n          flipAlignment = true\n        } = _evaluate2,\n        detectOverflowOptions = _objectWithoutProperties(_evaluate2, _excluded2);\n\n      // If a reset by the arrow was caused due to an alignment offset being\n      // added, we should skip any logic now since `flip()` has already done its\n      // work.\n      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);\n      const initialSideAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(initialPlacement);\n      const isBasePlacement = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositePlacement)(initialPlacement)] : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getExpandedPlacements)(initialPlacement));\n      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== 'none';\n      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {\n        fallbackPlacements.push(...(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAxisPlacements)(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const sides = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentSides)(placement, rects, rtl);\n        overflows.push(overflow[sides[0]], overflow[sides[1]]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          const ignoreCrossAxisOverflow = checkCrossAxis === 'alignment' ? initialSideAxis !== (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(nextPlacement) : false;\n          if (!ignoreCrossAxisOverflow ||\n          // We leave the current main axis only if every placement on that axis\n          // overflows the main axis.\n          overflowsData.every(d => (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(d.placement) === initialSideAxis ? d.overflows[0] > 0 : true)) {\n            // Try next placement and re-run the lifecycle.\n            return {\n              data: {\n                index: nextIndex,\n                overflows: overflowsData\n              },\n              reset: {\n                placement: nextPlacement\n              }\n            };\n          }\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$filter2;\n                const placement = (_overflowsData$filter2 = overflowsData.filter(d => {\n                  if (hasFallbackAxisSideDirection) {\n                    const currentSideAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(d.placement);\n                    return currentSideAxis === initialSideAxis ||\n                    // Create a bias to the `y` side axis due to horizontal\n                    // reading directions favoring greater width.\n                    currentSideAxis === 'y';\n                  }\n                  return true;\n                }).map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        rects\n      } = state;\n      const _evaluate3 = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state),\n        {\n          strategy = 'referenceHidden'\n        } = _evaluate3,\n        detectOverflowOptions = _objectWithoutProperties(_evaluate3, _excluded3);\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(state, _objectSpread(_objectSpread({}, detectOverflowOptions), {}, {\n              elementContext: 'reference'\n            }));\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(state, _objectSpread(_objectSpread({}, detectOverflowOptions), {}, {\n              altBoundary: true\n            }));\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\nfunction getBoundingRect(rects) {\n  const minX = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(...rects.map(rect => rect.left));\n  const minY = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(...rects.map(rect => rect.top));\n  const maxX = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(...rects.map(rect => rect.right));\n  const maxY = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(...rects.map(rect => rect.bottom));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction getRectsByLine(rects) {\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\n  const groups = [];\n  let prevRect = null;\n  for (let i = 0; i < sortedRects.length; i++) {\n    const rect = sortedRects[i];\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n    prevRect = rect;\n  }\n  return groups.map(rect => (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = state;\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n      const {\n        padding = 2,\n        x,\n        y\n      } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\n      const clientRects = getRectsByLine(nativeClientRects);\n      const fallback = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(getBoundingRect(nativeClientRects));\n      const paddingObject = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getPaddingObject)(padding);\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined.\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          // Find the first rect in which the point is fully inside.\n          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n        }\n\n        // There are 2 or more connected rects.\n        if (clientRects.length >= 2) {\n          if ((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement) === 'y') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          const isLeftSide = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement) === 'left';\n          const maxRight = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(...clientRects.map(rect => rect.right));\n          const minLeft = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n        return fallback;\n      }\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\nconst originSides = /*#__PURE__*/new Set(['left', 'top']);\n\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\n\nasync function convertValueToCoords(state, options) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);\n  const alignment = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement);\n  const isVertical = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement) === 'y';\n  const mainAxisMulti = originSides.has(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n\n  // eslint-disable-next-line prefer-const\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: rawValue.mainAxis || 0,\n    crossAxis: rawValue.crossAxis || 0,\n    alignmentAxis: rawValue.alignmentAxis\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: 'offset',\n    options,\n    async fn(state) {\n      var _middlewareData$offse, _middlewareData$arrow;\n      const {\n        x,\n        y,\n        placement,\n        middlewareData\n      } = state;\n      const diffCoords = await convertValueToCoords(state, options);\n\n      // If the placement is the same and the arrow caused an alignment offset\n      // then we don't need to change the positioning coordinates.\n      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: _objectSpread(_objectSpread({}, diffCoords), {}, {\n          placement\n        })\n      };\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const _evaluate4 = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state),\n        {\n          mainAxis: checkMainAxis = true,\n          crossAxis: checkCrossAxis = false,\n          limiter = {\n            fn: _ref => {\n              let {\n                x,\n                y\n              } = _ref;\n              return {\n                x,\n                y\n              };\n            }\n          }\n        } = _evaluate4,\n        detectOverflowOptions = _objectWithoutProperties(_evaluate4, _excluded4);\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const crossAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement));\n      const mainAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAxis)(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.clamp)(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.clamp)(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn(_objectSpread(_objectSpread({}, state), {}, {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      }));\n      return _objectSpread(_objectSpread({}, limitedCoords), {}, {\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y,\n          enabled: {\n            [mainAxis]: checkMainAxis,\n            [crossAxis]: checkCrossAxis\n          }\n        }\n      });\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = state;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const crossAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement);\n      const mainAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAxis)(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(offset, state);\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : _objectSpread({\n        mainAxis: 0,\n        crossAxis: 0\n      }, rawOffset);\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = originSides.has((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(state) {\n      var _state$middlewareData, _state$middlewareData2;\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      const _evaluate5 = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state),\n        {\n          apply = () => {}\n        } = _evaluate5,\n        detectOverflowOptions = _objectWithoutProperties(_evaluate5, _excluded5);\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);\n      const alignment = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement);\n      const isYAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement) === 'y';\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const maximumClippingHeight = height - overflow.top - overflow.bottom;\n      const maximumClippingWidth = width - overflow.left - overflow.right;\n      const overflowAvailableHeight = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(height - overflow[heightSide], maximumClippingHeight);\n      const overflowAvailableWidth = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(width - overflow[widthSide], maximumClippingWidth);\n      const noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {\n        availableWidth = maximumClippingWidth;\n      }\n      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {\n        availableHeight = maximumClippingHeight;\n      }\n      if (noShift && !alignment) {\n        const xMin = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.left, 0);\n        const xMax = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.right, 0);\n        const yMin = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.top, 0);\n        const yMax = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.bottom, 0);\n        if (isYAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.top, overflow.bottom));\n        }\n      }\n      await apply(_objectSpread(_objectSpread({}, state), {}, {\n        availableWidth,\n        availableHeight\n      }));\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL2RvbS9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL2NvcmUvZGlzdC9mbG9hdGluZy11aS5jb3JlLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXNVO0FBQ2hSO0FBRXRELFNBQVNtQiwwQkFBMEJBLENBQUNDLElBQUksRUFBRUMsU0FBUyxFQUFFQyxHQUFHLEVBQUU7RUFDeEQsSUFBSTtJQUNGQyxTQUFTO0lBQ1RDO0VBQ0YsQ0FBQyxHQUFHSixJQUFJO0VBQ1IsTUFBTUssUUFBUSxHQUFHekIsK0RBQVcsQ0FBQ3FCLFNBQVMsQ0FBQztFQUN2QyxNQUFNSyxhQUFhLEdBQUd6QixvRUFBZ0IsQ0FBQ29CLFNBQVMsQ0FBQztFQUNqRCxNQUFNTSxXQUFXLEdBQUd6QixpRUFBYSxDQUFDd0IsYUFBYSxDQUFDO0VBQ2hELE1BQU1FLElBQUksR0FBR3pCLDJEQUFPLENBQUNrQixTQUFTLENBQUM7RUFDL0IsTUFBTVEsVUFBVSxHQUFHSixRQUFRLEtBQUssR0FBRztFQUNuQyxNQUFNSyxPQUFPLEdBQUdQLFNBQVMsQ0FBQ1EsQ0FBQyxHQUFHUixTQUFTLENBQUNTLEtBQUssR0FBRyxDQUFDLEdBQUdSLFFBQVEsQ0FBQ1EsS0FBSyxHQUFHLENBQUM7RUFDdEUsTUFBTUMsT0FBTyxHQUFHVixTQUFTLENBQUNXLENBQUMsR0FBR1gsU0FBUyxDQUFDWSxNQUFNLEdBQUcsQ0FBQyxHQUFHWCxRQUFRLENBQUNXLE1BQU0sR0FBRyxDQUFDO0VBQ3hFLE1BQU1DLFdBQVcsR0FBR2IsU0FBUyxDQUFDSSxXQUFXLENBQUMsR0FBRyxDQUFDLEdBQUdILFFBQVEsQ0FBQ0csV0FBVyxDQUFDLEdBQUcsQ0FBQztFQUMxRSxJQUFJVSxNQUFNO0VBQ1YsUUFBUVQsSUFBSTtJQUNWLEtBQUssS0FBSztNQUNSUyxNQUFNLEdBQUc7UUFDUE4sQ0FBQyxFQUFFRCxPQUFPO1FBQ1ZJLENBQUMsRUFB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QUFJQyxJQUFJLEtBQUssQ0FBQyxHQUFHRCxJQUFJLEdBQUdDLElBQUksR0FBRzlPLHVEQUFHLENBQUNnSCxRQUFRLENBQUN4QyxJQUFJLEVBQUV3QyxRQUFRLENBQUN2QyxLQUFLLENBQUMsQ0FBQztRQUM1RyxDQUFDLE1BQU07VUFDTGtLLGVBQWUsR0FBR3pOLE1BQU0sR0FBRyxDQUFDLElBQUk2TixJQUFJLEtBQUssQ0FBQyxJQUFJQyxJQUFJLEtBQUssQ0FBQyxHQUFHRCxJQUFJLEdBQUdDLElBQUksR0FBR2hQLHVEQUFHLENBQUNnSCxRQUFRLENBQUMxQyxHQUFHLEVBQUUwQyxRQUFRLENBQUN6QyxNQUFNLENBQUMsQ0FBQztRQUM5RztNQUNGO01BQ0EsTUFBTTJKLEtBQUssQ0FBQXJMLGFBQUEsQ0FBQUEsYUFBQSxLQUNORSxLQUFLO1FBQ1I2TCxjQUFjO1FBQ2REO01BQWUsRUFDaEIsQ0FBQztNQUNGLE1BQU1NLGNBQWMsR0FBRyxNQUFNeE4sUUFBUSxDQUFDb0QsYUFBYSxDQUFDakMsUUFBUSxDQUFDckMsUUFBUSxDQUFDO01BQ3RFLElBQUlRLEtBQUssS0FBS2tPLGNBQWMsQ0FBQ2xPLEtBQUssSUFBSUcsTUFBTSxLQUFLK04sY0FBYyxDQUFDL04sTUFBTSxFQUFFO1FBQ3RFLE9BQU87VUFDTHdCLEtBQUssRUFBRTtZQUNMWixLQUFLLEVBQUU7VUFDVDtRQUNGLENBQUM7TUFDSDtNQUNBLE9BQU8sQ0FBQyxDQUFDO0lBQ1g7RUFDRixDQUFDO0FBQ0gsQ0FBQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxFcmZhblxcRGVza3RvcFxcMtm+2LHZiNqY2Ycg24wg2YXYrdmF2K8g2LnYsdmB2KfZhiDYsdi22KfbjNuMXFxFcmZhbmRldlxcLmZyb250ZW5kXFxub2RlX21vZHVsZXNcXEBmbG9hdGluZy11aVxcZG9tXFxub2RlX21vZHVsZXNcXEBmbG9hdGluZy11aVxcY29yZVxcZGlzdFxcZmxvYXRpbmctdWkuY29yZS5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0U2lkZUF4aXMsIGdldEFsaWdubWVudEF4aXMsIGdldEF4aXNMZW5ndGgsIGdldFNpZGUsIGdldEFsaWdubWVudCwgZXZhbHVhdGUsIGdldFBhZGRpbmdPYmplY3QsIHJlY3RUb0NsaWVudFJlY3QsIG1pbiwgY2xhbXAsIHBsYWNlbWVudHMsIGdldEFsaWdubWVudFNpZGVzLCBnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudCwgZ2V0T3Bwb3NpdGVQbGFjZW1lbnQsIGdldEV4cGFuZGVkUGxhY2VtZW50cywgZ2V0T3Bwb3NpdGVBeGlzUGxhY2VtZW50cywgc2lkZXMsIG1heCwgZ2V0T3Bwb3NpdGVBeGlzIH0gZnJvbSAnQGZsb2F0aW5nLXVpL3V0aWxzJztcbmV4cG9ydCB7IHJlY3RUb0NsaWVudFJlY3QgfSBmcm9tICdAZmxvYXRpbmctdWkvdXRpbHMnO1xuXG5mdW5jdGlvbiBjb21wdXRlQ29vcmRzRnJvbVBsYWNlbWVudChfcmVmLCBwbGFjZW1lbnQsIHJ0bCkge1xuICBsZXQge1xuICAgIHJlZmVyZW5jZSxcbiAgICBmbG9hdGluZ1xuICB9ID0gX3JlZjtcbiAgY29uc3Qgc2lkZUF4aXMgPSBnZXRTaWRlQXhpcyhwbGFjZW1lbnQpO1xuICBjb25zdCBhbGlnbm1lbnRBeGlzID0gZ2V0QWxpZ25tZW50QXhpcyhwbGFjZW1lbnQpO1xuICBjb25zdCBhbGlnbkxlbmd0aCA9IGdldEF4aXNMZW5ndGgoYWxpZ25tZW50QXhpcyk7XG4gIGNvbnN0IHNpZGUgPSBnZXRTaWRlKHBsYWNlbWVudCk7XG4gIGNvbnN0IGlzVmVydGljYWwgPSBzaWRlQXhpcyA9PT0gJ3knO1xuICBjb25zdCBjb21tb25YID0gcmVmZXJlbmNlLnggKyByZWZlcmVuY2Uud2lkdGggLyAyIC0gZmxvYXRpbmcud2lkdGggLyAyO1xuICBjb25zdCBjb21tb25ZID0gcmVmZXJlbmNlLnkgKyByZWZlcmVuY2UuaGVpZ2h0IC8gMiAtIGZsb2F0aW5nLmhlaWdodCAvIDI7XG4gIGNvbnN0IGNvbW1vbkFsaWduID0gcmVmZXJlbmNlW2FsaWduTGVuZ3RoXSAvIDIgLSBmbG9hdGluZ1thbGlnbkxlbmd0aF0gLyAyO1xuICBsZXQgY29vcmRzO1xuICBzd2l0Y2ggKHNpZGUpIHtcbiAgICBjYXNlICd0b3AnOlxuICAgICAgY29vcmRzID0ge1xuICAgICAgICB4OiBjb21tb25YLFxuICAgICAgICB5OiByZWZlcmVuY2UueSAtIGZsb2F0aW5nLmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICBjb29yZHMgPSB7XG4gICAgICAgIHg6IGNvbW1vblgsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLnggKyByZWZlcmVuY2Uud2lkdGgsXG4gICAgICAgIHk6IGNvbW1vbllcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdsZWZ0JzpcbiAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLnggLSBmbG9hdGluZy53aWR0aCxcbiAgICAgICAgeTogY29tbW9uWVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBjb29yZHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54LFxuICAgICAgICB5OiByZWZlcmVuY2UueVxuICAgICAgfTtcbiAgfVxuICBzd2l0Y2ggKGdldEFsaWdubWVudChwbGFjZW1lbnQpKSB7XG4gICAgY2FzZSAnc3RhcnQnOlxuICAgICAgY29vcmRzW2FsaWdubWVudEF4aXNdIC09IGNvbW1vbkFsaWduICogKHJ0bCAmJiBpc1ZlcnRpY2FsID8gLTEgOiAxKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2VuZCc6XG4gICAgICBjb29yZHNbYWxpZ25tZW50QXhpc10gKz0gY29tbW9uQWxpZ24gKiAocnRsICYmIGlzVmVydGljYWwgPyAtMSA6IDEpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIGNvb3Jkcztcbn1cblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgYHhgIGFuZCBgeWAgY29vcmRpbmF0ZXMgdGhhdCB3aWxsIHBsYWNlIHRoZSBmbG9hdGluZyBlbGVtZW50XG4gKiBuZXh0IHRvIGEgZ2l2ZW4gcmVmZXJlbmNlIGVsZW1lbnQuXG4gKlxuICogVGhpcyBleHBvcnQgZG9lcyBub3QgaGF2ZSBhbnkgYHBsYXRmb3JtYCBpbnRlcmZhY2UgbG9naWMuIFlvdSB3aWxsIG5lZWQgdG9cbiAqIHdyaXRlIG9uZSBmb3IgdGhlIHBsYXRmb3JtIHlvdSBhcmUgdXNpbmcgRmxvYXRpbmcgVUkgd2l0aC5cbiAqL1xuY29uc3QgY29tcHV0ZVBvc2l0aW9uID0gYXN5bmMgKHJlZmVyZW5jZSwgZmxvYXRpbmcsIGNvbmZpZykgPT4ge1xuICBjb25zdCB7XG4gICAgcGxhY2VtZW50ID0gJ2JvdHRvbScsXG4gICAgc3RyYXRlZ3kgPSAnYWJzb2x1dGUnLFxuICAgIG1pZGRsZXdhcmUgPSBbXSxcbiAgICBwbGF0Zm9ybVxuICB9ID0gY29uZmlnO1xuICBjb25zdCB2YWxpZE1pZGRsZXdhcmUgPSBtaWRkbGV3YXJlLmZpbHRlcihCb29sZWFuKTtcbiAgY29uc3QgcnRsID0gYXdhaXQgKHBsYXRmb3JtLmlzUlRMID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc1JUTChmbG9hdGluZykpO1xuICBsZXQgcmVjdHMgPSBhd2FpdCBwbGF0Zm9ybS5nZXRFbGVtZW50UmVjdHMoe1xuICAgIHJlZmVyZW5jZSxcbiAgICBmbG9hdGluZyxcbiAgICBzdHJhdGVneVxuICB9KTtcbiAgbGV0IHtcbiAgICB4LFxuICAgIHlcbiAgfSA9IGNvbXB1dGVDb29yZHNGcm9tUGxhY2VtZW50KHJlY3RzLCBwbGFjZW1lbnQsIHJ0bCk7XG4gIGxldCBzdGF0ZWZ1bFBsYWNlbWVudCA9IHBsYWNlbWVudDtcbiAgbGV0IG1pZGRsZXdhcmVEYXRhID0ge307XG4gIGxldCByZXNldENvdW50ID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWxpZE1pZGRsZXdhcmUubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB7XG4gICAgICBuYW1lLFxuICAgICAgZm5cbiAgICB9ID0gdmFsaWRNaWRkbGV3YXJlW2ldO1xuICAgIGNvbnN0IHtcbiAgICAgIHg6IG5leHRYLFxuICAgICAgeTogbmV4dFksXG4gICAgICBkYXRhLFxuICAgICAgcmVzZXRcbiAgICB9ID0gYXdhaXQgZm4oe1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBpbml0aWFsUGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICBwbGFjZW1lbnQ6IHN0YXRlZnVsUGxhY2VtZW50LFxuICAgICAgc3RyYXRlZ3ksXG4gICAgICBtaWRkbGV3YXJlRGF0YSxcbiAgICAgIHJlY3RzLFxuICAgICAgcGxhdGZvcm0sXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICByZWZlcmVuY2UsXG4gICAgICAgIGZsb2F0aW5nXG4gICAgICB9XG4gICAgfSk7XG4gICAgeCA9IG5leHRYICE9IG51bGwgPyBuZXh0WCA6IHg7XG4gICAgeSA9IG5leHRZICE9IG51bGwgPyBuZXh0WSA6IHk7XG4gICAgbWlkZGxld2FyZURhdGEgPSB7XG4gICAgICAuLi5taWRkbGV3YXJlRGF0YSxcbiAgICAgIFtuYW1lXToge1xuICAgICAgICAuLi5taWRkbGV3YXJlRGF0YVtuYW1lXSxcbiAgICAgICAgLi4uZGF0YVxuICAgICAgfVxuICAgIH07XG4gICAgaWYgKHJlc2V0ICYmIHJlc2V0Q291bnQgPD0gNTApIHtcbiAgICAgIHJlc2V0Q291bnQrKztcbiAgICAgIGlmICh0eXBlb2YgcmVzZXQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChyZXNldC5wbGFjZW1lbnQpIHtcbiAgICAgICAgICBzdGF0ZWZ1bFBsYWNlbWVudCA9IHJlc2V0LnBsYWNlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzZXQucmVjdHMpIHtcbiAgICAgICAgICByZWN0cyA9IHJlc2V0LnJlY3RzID09PSB0cnVlID8gYXdhaXQgcGxhdGZvcm0uZ2V0RWxlbWVudFJlY3RzKHtcbiAgICAgICAgICAgIHJlZmVyZW5jZSxcbiAgICAgICAgICAgIGZsb2F0aW5nLFxuICAgICAgICAgICAgc3RyYXRlZ3lcbiAgICAgICAgICB9KSA6IHJlc2V0LnJlY3RzO1xuICAgICAgICB9XG4gICAgICAgICh7XG4gICAgICAgICAgeCxcbiAgICAgICAgICB5XG4gICAgICAgIH0gPSBjb21wdXRlQ29vcmRzRnJvbVBsYWNlbWVudChyZWN0cywgc3RhdGVmdWxQbGFjZW1lbnQsIHJ0bCkpO1xuICAgICAgfVxuICAgICAgaSA9IC0xO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHgsXG4gICAgeSxcbiAgICBwbGFjZW1lbnQ6IHN0YXRlZnVsUGxhY2VtZW50LFxuICAgIHN0cmF0ZWd5LFxuICAgIG1pZGRsZXdhcmVEYXRhXG4gIH07XG59O1xuXG4vKipcbiAqIFJlc29sdmVzIHdpdGggYW4gb2JqZWN0IG9mIG92ZXJmbG93IHNpZGUgb2Zmc2V0cyB0aGF0IGRldGVybWluZSBob3cgbXVjaCB0aGVcbiAqIGVsZW1lbnQgaXMgb3ZlcmZsb3dpbmcgYSBnaXZlbiBjbGlwcGluZyBib3VuZGFyeSBvbiBlYWNoIHNpZGUuXG4gKiAtIHBvc2l0aXZlID0gb3ZlcmZsb3dpbmcgdGhlIGJvdW5kYXJ5IGJ5IHRoYXQgbnVtYmVyIG9mIHBpeGVsc1xuICogLSBuZWdhdGl2ZSA9IGhvdyBtYW55IHBpeGVscyBsZWZ0IGJlZm9yZSBpdCB3aWxsIG92ZXJmbG93XG4gKiAtIDAgPSBsaWVzIGZsdXNoIHdpdGggdGhlIGJvdW5kYXJ5XG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvZGV0ZWN0T3ZlcmZsb3dcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIG9wdGlvbnMpIHtcbiAgdmFyIF9hd2FpdCRwbGF0Zm9ybSRpc0VsZTtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgeCxcbiAgICB5LFxuICAgIHBsYXRmb3JtLFxuICAgIHJlY3RzLFxuICAgIGVsZW1lbnRzLFxuICAgIHN0cmF0ZWd5XG4gIH0gPSBzdGF0ZTtcbiAgY29uc3Qge1xuICAgIGJvdW5kYXJ5ID0gJ2NsaXBwaW5nQW5jZXN0b3JzJyxcbiAgICByb290Qm91bmRhcnkgPSAndmlld3BvcnQnLFxuICAgIGVsZW1lbnRDb250ZXh0ID0gJ2Zsb2F0aW5nJyxcbiAgICBhbHRCb3VuZGFyeSA9IGZhbHNlLFxuICAgIHBhZGRpbmcgPSAwXG4gIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG4gIGNvbnN0IHBhZGRpbmdPYmplY3QgPSBnZXRQYWRkaW5nT2JqZWN0KHBhZGRpbmcpO1xuICBjb25zdCBhbHRDb250ZXh0ID0gZWxlbWVudENvbnRleHQgPT09ICdmbG9hdGluZycgPyAncmVmZXJlbmNlJyA6ICdmbG9hdGluZyc7XG4gIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1thbHRCb3VuZGFyeSA/IGFsdENvbnRleHQgOiBlbGVtZW50Q29udGV4dF07XG4gIGNvbnN0IGNsaXBwaW5nQ2xpZW50UmVjdCA9IHJlY3RUb0NsaWVudFJlY3QoYXdhaXQgcGxhdGZvcm0uZ2V0Q2xpcHBpbmdSZWN0KHtcbiAgICBlbGVtZW50OiAoKF9hd2FpdCRwbGF0Zm9ybSRpc0VsZSA9IGF3YWl0IChwbGF0Zm9ybS5pc0VsZW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmlzRWxlbWVudChlbGVtZW50KSkpICE9IG51bGwgPyBfYXdhaXQkcGxhdGZvcm0kaXNFbGUgOiB0cnVlKSA/IGVsZW1lbnQgOiBlbGVtZW50LmNvbnRleHRFbGVtZW50IHx8IChhd2FpdCAocGxhdGZvcm0uZ2V0RG9jdW1lbnRFbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5nZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudHMuZmxvYXRpbmcpKSksXG4gICAgYm91bmRhcnksXG4gICAgcm9vdEJvdW5kYXJ5LFxuICAgIHN0cmF0ZWd5XG4gIH0pKTtcbiAgY29uc3QgcmVjdCA9IGVsZW1lbnRDb250ZXh0ID09PSAnZmxvYXRpbmcnID8ge1xuICAgIHgsXG4gICAgeSxcbiAgICB3aWR0aDogcmVjdHMuZmxvYXRpbmcud2lkdGgsXG4gICAgaGVpZ2h0OiByZWN0cy5mbG9hdGluZy5oZWlnaHRcbiAgfSA6IHJlY3RzLnJlZmVyZW5jZTtcbiAgY29uc3Qgb2Zmc2V0UGFyZW50ID0gYXdhaXQgKHBsYXRmb3JtLmdldE9mZnNldFBhcmVudCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnRzLmZsb2F0aW5nKSk7XG4gIGNvbnN0IG9mZnNldFNjYWxlID0gKGF3YWl0IChwbGF0Zm9ybS5pc0VsZW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmlzRWxlbWVudChvZmZzZXRQYXJlbnQpKSkgPyAoYXdhaXQgKHBsYXRmb3JtLmdldFNjYWxlID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5nZXRTY2FsZShvZmZzZXRQYXJlbnQpKSkgfHwge1xuICAgIHg6IDEsXG4gICAgeTogMVxuICB9IDoge1xuICAgIHg6IDEsXG4gICAgeTogMVxuICB9O1xuICBjb25zdCBlbGVtZW50Q2xpZW50UmVjdCA9IHJlY3RUb0NsaWVudFJlY3QocGxhdGZvcm0uY29udmVydE9mZnNldFBhcmVudFJlbGF0aXZlUmVjdFRvVmlld3BvcnRSZWxhdGl2ZVJlY3QgPyBhd2FpdCBwbGF0Zm9ybS5jb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdCh7XG4gICAgZWxlbWVudHMsXG4gICAgcmVjdCxcbiAgICBvZmZzZXRQYXJlbnQsXG4gICAgc3RyYXRlZ3lcbiAgfSkgOiByZWN0KTtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IChjbGlwcGluZ0NsaWVudFJlY3QudG9wIC0gZWxlbWVudENsaWVudFJlY3QudG9wICsgcGFkZGluZ09iamVjdC50b3ApIC8gb2Zmc2V0U2NhbGUueSxcbiAgICBib3R0b206IChlbGVtZW50Q2xpZW50UmVjdC5ib3R0b20gLSBjbGlwcGluZ0NsaWVudFJlY3QuYm90dG9tICsgcGFkZGluZ09iamVjdC5ib3R0b20pIC8gb2Zmc2V0U2NhbGUueSxcbiAgICBsZWZ0OiAoY2xpcHBpbmdDbGllbnRSZWN0LmxlZnQgLSBlbGVtZW50Q2xpZW50UmVjdC5sZWZ0ICsgcGFkZGluZ09iamVjdC5sZWZ0KSAvIG9mZnNldFNjYWxlLngsXG4gICAgcmlnaHQ6IChlbGVtZW50Q2xpZW50UmVjdC5yaWdodCAtIGNsaXBwaW5nQ2xpZW50UmVjdC5yaWdodCArIHBhZGRpbmdPYmplY3QucmlnaHQpIC8gb2Zmc2V0U2NhbGUueFxuICB9O1xufVxuXG4vKipcbiAqIFByb3ZpZGVzIGRhdGEgdG8gcG9zaXRpb24gYW4gaW5uZXIgZWxlbWVudCBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBzbyB0aGF0IGl0XG4gKiBhcHBlYXJzIGNlbnRlcmVkIHRvIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9hcnJvd1xuICovXG5jb25zdCBhcnJvdyA9IG9wdGlvbnMgPT4gKHtcbiAgbmFtZTogJ2Fycm93JyxcbiAgb3B0aW9ucyxcbiAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICBjb25zdCB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHBsYWNlbWVudCxcbiAgICAgIHJlY3RzLFxuICAgICAgcGxhdGZvcm0sXG4gICAgICBlbGVtZW50cyxcbiAgICAgIG1pZGRsZXdhcmVEYXRhXG4gICAgfSA9IHN0YXRlO1xuICAgIC8vIFNpbmNlIGBlbGVtZW50YCBpcyByZXF1aXJlZCwgd2UgZG9uJ3QgUGFydGlhbDw+IHRoZSB0eXBlLlxuICAgIGNvbnN0IHtcbiAgICAgIGVsZW1lbnQsXG4gICAgICBwYWRkaW5nID0gMFxuICAgIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSkgfHwge307XG4gICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBjb25zdCBwYWRkaW5nT2JqZWN0ID0gZ2V0UGFkZGluZ09iamVjdChwYWRkaW5nKTtcbiAgICBjb25zdCBjb29yZHMgPSB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH07XG4gICAgY29uc3QgYXhpcyA9IGdldEFsaWdubWVudEF4aXMocGxhY2VtZW50KTtcbiAgICBjb25zdCBsZW5ndGggPSBnZXRBeGlzTGVuZ3RoKGF4aXMpO1xuICAgIGNvbnN0IGFycm93RGltZW5zaW9ucyA9IGF3YWl0IHBsYXRmb3JtLmdldERpbWVuc2lvbnMoZWxlbWVudCk7XG4gICAgY29uc3QgaXNZQXhpcyA9IGF4aXMgPT09ICd5JztcbiAgICBjb25zdCBtaW5Qcm9wID0gaXNZQXhpcyA/ICd0b3AnIDogJ2xlZnQnO1xuICAgIGNvbnN0IG1heFByb3AgPSBpc1lBeGlzID8gJ2JvdHRvbScgOiAncmlnaHQnO1xuICAgIGNvbnN0IGNsaWVudFByb3AgPSBpc1lBeGlzID8gJ2NsaWVudEhlaWdodCcgOiAnY2xpZW50V2lkdGgnO1xuICAgIGNvbnN0IGVuZERpZmYgPSByZWN0cy5yZWZlcmVuY2VbbGVuZ3RoXSArIHJlY3RzLnJlZmVyZW5jZVtheGlzXSAtIGNvb3Jkc1theGlzXSAtIHJlY3RzLmZsb2F0aW5nW2xlbmd0aF07XG4gICAgY29uc3Qgc3RhcnREaWZmID0gY29vcmRzW2F4aXNdIC0gcmVjdHMucmVmZXJlbmNlW2F4aXNdO1xuICAgIGNvbnN0IGFycm93T2Zmc2V0UGFyZW50ID0gYXdhaXQgKHBsYXRmb3JtLmdldE9mZnNldFBhcmVudCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpKTtcbiAgICBsZXQgY2xpZW50U2l6ZSA9IGFycm93T2Zmc2V0UGFyZW50ID8gYXJyb3dPZmZzZXRQYXJlbnRbY2xpZW50UHJvcF0gOiAwO1xuXG4gICAgLy8gRE9NIHBsYXRmb3JtIGNhbiByZXR1cm4gYHdpbmRvd2AgYXMgdGhlIGBvZmZzZXRQYXJlbnRgLlxuICAgIGlmICghY2xpZW50U2l6ZSB8fCAhKGF3YWl0IChwbGF0Zm9ybS5pc0VsZW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmlzRWxlbWVudChhcnJvd09mZnNldFBhcmVudCkpKSkge1xuICAgICAgY2xpZW50U2l6ZSA9IGVsZW1lbnRzLmZsb2F0aW5nW2NsaWVudFByb3BdIHx8IHJlY3RzLmZsb2F0aW5nW2xlbmd0aF07XG4gICAgfVxuICAgIGNvbnN0IGNlbnRlclRvUmVmZXJlbmNlID0gZW5kRGlmZiAvIDIgLSBzdGFydERpZmYgLyAyO1xuXG4gICAgLy8gSWYgdGhlIHBhZGRpbmcgaXMgbGFyZ2UgZW5vdWdoIHRoYXQgaXQgY2F1c2VzIHRoZSBhcnJvdyB0byBubyBsb25nZXIgYmVcbiAgICAvLyBjZW50ZXJlZCwgbW9kaWZ5IHRoZSBwYWRkaW5nIHNvIHRoYXQgaXQgaXMgY2VudGVyZWQuXG4gICAgY29uc3QgbGFyZ2VzdFBvc3NpYmxlUGFkZGluZyA9IGNsaWVudFNpemUgLyAyIC0gYXJyb3dEaW1lbnNpb25zW2xlbmd0aF0gLyAyIC0gMTtcbiAgICBjb25zdCBtaW5QYWRkaW5nID0gbWluKHBhZGRpbmdPYmplY3RbbWluUHJvcF0sIGxhcmdlc3RQb3NzaWJsZVBhZGRpbmcpO1xuICAgIGNvbnN0IG1heFBhZGRpbmcgPSBtaW4ocGFkZGluZ09iamVjdFttYXhQcm9wXSwgbGFyZ2VzdFBvc3NpYmxlUGFkZGluZyk7XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhlIGFycm93IGRvZXNuJ3Qgb3ZlcmZsb3cgdGhlIGZsb2F0aW5nIGVsZW1lbnQgaWYgdGhlIGNlbnRlclxuICAgIC8vIHBvaW50IGlzIG91dHNpZGUgdGhlIGZsb2F0aW5nIGVsZW1lbnQncyBib3VuZHMuXG4gICAgY29uc3QgbWluJDEgPSBtaW5QYWRkaW5nO1xuICAgIGNvbnN0IG1heCA9IGNsaWVudFNpemUgLSBhcnJvd0RpbWVuc2lvbnNbbGVuZ3RoXSAtIG1heFBhZGRpbmc7XG4gICAgY29uc3QgY2VudGVyID0gY2xpZW50U2l6ZSAvIDIgLSBhcnJvd0RpbWVuc2lvbnNbbGVuZ3RoXSAvIDIgKyBjZW50ZXJUb1JlZmVyZW5jZTtcbiAgICBjb25zdCBvZmZzZXQgPSBjbGFtcChtaW4kMSwgY2VudGVyLCBtYXgpO1xuXG4gICAgLy8gSWYgdGhlIHJlZmVyZW5jZSBpcyBzbWFsbCBlbm91Z2ggdGhhdCB0aGUgYXJyb3cncyBwYWRkaW5nIGNhdXNlcyBpdCB0b1xuICAgIC8vIHRvIHBvaW50IHRvIG5vdGhpbmcgZm9yIGFuIGFsaWduZWQgcGxhY2VtZW50LCBhZGp1c3QgdGhlIG9mZnNldCBvZiB0aGVcbiAgICAvLyBmbG9hdGluZyBlbGVtZW50IGl0c2VsZi4gVG8gZW5zdXJlIGBzaGlmdCgpYCBjb250aW51ZXMgdG8gdGFrZSBhY3Rpb24sXG4gICAgLy8gYSBzaW5nbGUgcmVzZXQgaXMgcGVyZm9ybWVkIHdoZW4gdGhpcyBpcyB0cnVlLlxuICAgIGNvbnN0IHNob3VsZEFkZE9mZnNldCA9ICFtaWRkbGV3YXJlRGF0YS5hcnJvdyAmJiBnZXRBbGlnbm1lbnQocGxhY2VtZW50KSAhPSBudWxsICYmIGNlbnRlciAhPT0gb2Zmc2V0ICYmIHJlY3RzLnJlZmVyZW5jZVtsZW5ndGhdIC8gMiAtIChjZW50ZXIgPCBtaW4kMSA/IG1pblBhZGRpbmcgOiBtYXhQYWRkaW5nKSAtIGFycm93RGltZW5zaW9uc1tsZW5ndGhdIC8gMiA8IDA7XG4gICAgY29uc3QgYWxpZ25tZW50T2Zmc2V0ID0gc2hvdWxkQWRkT2Zmc2V0ID8gY2VudGVyIDwgbWluJDEgPyBjZW50ZXIgLSBtaW4kMSA6IGNlbnRlciAtIG1heCA6IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIFtheGlzXTogY29vcmRzW2F4aXNdICsgYWxpZ25tZW50T2Zmc2V0LFxuICAgICAgZGF0YToge1xuICAgICAgICBbYXhpc106IG9mZnNldCxcbiAgICAgICAgY2VudGVyT2Zmc2V0OiBjZW50ZXIgLSBvZmZzZXQgLSBhbGlnbm1lbnRPZmZzZXQsXG4gICAgICAgIC4uLihzaG91bGRBZGRPZmZzZXQgJiYge1xuICAgICAgICAgIGFsaWdubWVudE9mZnNldFxuICAgICAgICB9KVxuICAgICAgfSxcbiAgICAgIHJlc2V0OiBzaG91bGRBZGRPZmZzZXRcbiAgICB9O1xuICB9XG59KTtcblxuZnVuY3Rpb24gZ2V0UGxhY2VtZW50TGlzdChhbGlnbm1lbnQsIGF1dG9BbGlnbm1lbnQsIGFsbG93ZWRQbGFjZW1lbnRzKSB7XG4gIGNvbnN0IGFsbG93ZWRQbGFjZW1lbnRzU29ydGVkQnlBbGlnbm1lbnQgPSBhbGlnbm1lbnQgPyBbLi4uYWxsb3dlZFBsYWNlbWVudHMuZmlsdGVyKHBsYWNlbWVudCA9PiBnZXRBbGlnbm1lbnQocGxhY2VtZW50KSA9PT0gYWxpZ25tZW50KSwgLi4uYWxsb3dlZFBsYWNlbWVudHMuZmlsdGVyKHBsYWNlbWVudCA9PiBnZXRBbGlnbm1lbnQocGxhY2VtZW50KSAhPT0gYWxpZ25tZW50KV0gOiBhbGxvd2VkUGxhY2VtZW50cy5maWx0ZXIocGxhY2VtZW50ID0+IGdldFNpZGUocGxhY2VtZW50KSA9PT0gcGxhY2VtZW50KTtcbiAgcmV0dXJuIGFsbG93ZWRQbGFjZW1lbnRzU29ydGVkQnlBbGlnbm1lbnQuZmlsdGVyKHBsYWNlbWVudCA9PiB7XG4gICAgaWYgKGFsaWdubWVudCkge1xuICAgICAgcmV0dXJuIGdldEFsaWdubWVudChwbGFjZW1lbnQpID09PSBhbGlnbm1lbnQgfHwgKGF1dG9BbGlnbm1lbnQgPyBnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudChwbGFjZW1lbnQpICE9PSBwbGFjZW1lbnQgOiBmYWxzZSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9KTtcbn1cbi8qKlxuICogT3B0aW1pemVzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IGJ5IGNob29zaW5nIHRoZSBwbGFjZW1lbnRcbiAqIHRoYXQgaGFzIHRoZSBtb3N0IHNwYWNlIGF2YWlsYWJsZSBhdXRvbWF0aWNhbGx5LCB3aXRob3V0IG5lZWRpbmcgdG8gc3BlY2lmeSBhXG4gKiBwcmVmZXJyZWQgcGxhY2VtZW50LiBBbHRlcm5hdGl2ZSB0byBgZmxpcGAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvYXV0b1BsYWNlbWVudFxuICovXG5jb25zdCBhdXRvUGxhY2VtZW50ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdhdXRvUGxhY2VtZW50JyxcbiAgICBvcHRpb25zLFxuICAgIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgICB2YXIgX21pZGRsZXdhcmVEYXRhJGF1dG9QLCBfbWlkZGxld2FyZURhdGEkYXV0b1AyLCBfcGxhY2VtZW50c1RoYXRGaXRPbkU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJlY3RzLFxuICAgICAgICBtaWRkbGV3YXJlRGF0YSxcbiAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICBwbGF0Zm9ybSxcbiAgICAgICAgZWxlbWVudHNcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY3Jvc3NBeGlzID0gZmFsc2UsXG4gICAgICAgIGFsaWdubWVudCxcbiAgICAgICAgYWxsb3dlZFBsYWNlbWVudHMgPSBwbGFjZW1lbnRzLFxuICAgICAgICBhdXRvQWxpZ25tZW50ID0gdHJ1ZSxcbiAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zXG4gICAgICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuICAgICAgY29uc3QgcGxhY2VtZW50cyQxID0gYWxpZ25tZW50ICE9PSB1bmRlZmluZWQgfHwgYWxsb3dlZFBsYWNlbWVudHMgPT09IHBsYWNlbWVudHMgPyBnZXRQbGFjZW1lbnRMaXN0KGFsaWdubWVudCB8fCBudWxsLCBhdXRvQWxpZ25tZW50LCBhbGxvd2VkUGxhY2VtZW50cykgOiBhbGxvd2VkUGxhY2VtZW50cztcbiAgICAgIGNvbnN0IG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIGRldGVjdE92ZXJmbG93T3B0aW9ucyk7XG4gICAgICBjb25zdCBjdXJyZW50SW5kZXggPSAoKF9taWRkbGV3YXJlRGF0YSRhdXRvUCA9IG1pZGRsZXdhcmVEYXRhLmF1dG9QbGFjZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkYXV0b1AuaW5kZXgpIHx8IDA7XG4gICAgICBjb25zdCBjdXJyZW50UGxhY2VtZW50ID0gcGxhY2VtZW50cyQxW2N1cnJlbnRJbmRleF07XG4gICAgICBpZiAoY3VycmVudFBsYWNlbWVudCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFsaWdubWVudFNpZGVzID0gZ2V0QWxpZ25tZW50U2lkZXMoY3VycmVudFBsYWNlbWVudCwgcmVjdHMsIGF3YWl0IChwbGF0Zm9ybS5pc1JUTCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNSVEwoZWxlbWVudHMuZmxvYXRpbmcpKSk7XG5cbiAgICAgIC8vIE1ha2UgYGNvbXB1dGVDb29yZHNgIHN0YXJ0IGZyb20gdGhlIHJpZ2h0IHBsYWNlLlxuICAgICAgaWYgKHBsYWNlbWVudCAhPT0gY3VycmVudFBsYWNlbWVudCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudHMkMVswXVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGN1cnJlbnRPdmVyZmxvd3MgPSBbb3ZlcmZsb3dbZ2V0U2lkZShjdXJyZW50UGxhY2VtZW50KV0sIG92ZXJmbG93W2FsaWdubWVudFNpZGVzWzBdXSwgb3ZlcmZsb3dbYWxpZ25tZW50U2lkZXNbMV1dXTtcbiAgICAgIGNvbnN0IGFsbE92ZXJmbG93cyA9IFsuLi4oKChfbWlkZGxld2FyZURhdGEkYXV0b1AyID0gbWlkZGxld2FyZURhdGEuYXV0b1BsYWNlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9taWRkbGV3YXJlRGF0YSRhdXRvUDIub3ZlcmZsb3dzKSB8fCBbXSksIHtcbiAgICAgICAgcGxhY2VtZW50OiBjdXJyZW50UGxhY2VtZW50LFxuICAgICAgICBvdmVyZmxvd3M6IGN1cnJlbnRPdmVyZmxvd3NcbiAgICAgIH1dO1xuICAgICAgY29uc3QgbmV4dFBsYWNlbWVudCA9IHBsYWNlbWVudHMkMVtjdXJyZW50SW5kZXggKyAxXTtcblxuICAgICAgLy8gVGhlcmUgYXJlIG1vcmUgcGxhY2VtZW50cyB0byBjaGVjay5cbiAgICAgIGlmIChuZXh0UGxhY2VtZW50KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgaW5kZXg6IGN1cnJlbnRJbmRleCArIDEsXG4gICAgICAgICAgICBvdmVyZmxvd3M6IGFsbE92ZXJmbG93c1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgIHBsYWNlbWVudDogbmV4dFBsYWNlbWVudFxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBsYWNlbWVudHNTb3J0ZWRCeU1vc3RTcGFjZSA9IGFsbE92ZXJmbG93cy5tYXAoZCA9PiB7XG4gICAgICAgIGNvbnN0IGFsaWdubWVudCA9IGdldEFsaWdubWVudChkLnBsYWNlbWVudCk7XG4gICAgICAgIHJldHVybiBbZC5wbGFjZW1lbnQsIGFsaWdubWVudCAmJiBjcm9zc0F4aXMgP1xuICAgICAgICAvLyBDaGVjayBhbG9uZyB0aGUgbWFpbkF4aXMgYW5kIG1haW4gY3Jvc3NBeGlzIHNpZGUuXG4gICAgICAgIGQub3ZlcmZsb3dzLnNsaWNlKDAsIDIpLnJlZHVjZSgoYWNjLCB2KSA9PiBhY2MgKyB2LCAwKSA6XG4gICAgICAgIC8vIENoZWNrIG9ubHkgdGhlIG1haW5BeGlzLlxuICAgICAgICBkLm92ZXJmbG93c1swXSwgZC5vdmVyZmxvd3NdO1xuICAgICAgfSkuc29ydCgoYSwgYikgPT4gYVsxXSAtIGJbMV0pO1xuICAgICAgY29uc3QgcGxhY2VtZW50c1RoYXRGaXRPbkVhY2hTaWRlID0gcGxhY2VtZW50c1NvcnRlZEJ5TW9zdFNwYWNlLmZpbHRlcihkID0+IGRbMl0uc2xpY2UoMCxcbiAgICAgIC8vIEFsaWduZWQgcGxhY2VtZW50cyBzaG91bGQgbm90IGNoZWNrIHRoZWlyIG9wcG9zaXRlIGNyb3NzQXhpc1xuICAgICAgLy8gc2lkZS5cbiAgICAgIGdldEFsaWdubWVudChkWzBdKSA/IDIgOiAzKS5ldmVyeSh2ID0+IHYgPD0gMCkpO1xuICAgICAgY29uc3QgcmVzZXRQbGFjZW1lbnQgPSAoKF9wbGFjZW1lbnRzVGhhdEZpdE9uRSA9IHBsYWNlbWVudHNUaGF0Rml0T25FYWNoU2lkZVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9wbGFjZW1lbnRzVGhhdEZpdE9uRVswXSkgfHwgcGxhY2VtZW50c1NvcnRlZEJ5TW9zdFNwYWNlWzBdWzBdO1xuICAgICAgaWYgKHJlc2V0UGxhY2VtZW50ICE9PSBwbGFjZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBpbmRleDogY3VycmVudEluZGV4ICsgMSxcbiAgICAgICAgICAgIG92ZXJmbG93czogYWxsT3ZlcmZsb3dzXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgcGxhY2VtZW50OiByZXNldFBsYWNlbWVudFxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIE9wdGltaXplcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBieSBmbGlwcGluZyB0aGUgYHBsYWNlbWVudGBcbiAqIGluIG9yZGVyIHRvIGtlZXAgaXQgaW4gdmlldyB3aGVuIHRoZSBwcmVmZXJyZWQgcGxhY2VtZW50KHMpIHdpbGwgb3ZlcmZsb3cgdGhlXG4gKiBjbGlwcGluZyBib3VuZGFyeS4gQWx0ZXJuYXRpdmUgdG8gYGF1dG9QbGFjZW1lbnRgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2ZsaXBcbiAqL1xuY29uc3QgZmxpcCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnZmxpcCcsXG4gICAgb3B0aW9ucyxcbiAgICBhc3luYyBmbihzdGF0ZSkge1xuICAgICAgdmFyIF9taWRkbGV3YXJlRGF0YSRhcnJvdywgX21pZGRsZXdhcmVEYXRhJGZsaXA7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgbWlkZGxld2FyZURhdGEsXG4gICAgICAgIHJlY3RzLFxuICAgICAgICBpbml0aWFsUGxhY2VtZW50LFxuICAgICAgICBwbGF0Zm9ybSxcbiAgICAgICAgZWxlbWVudHNcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbWFpbkF4aXM6IGNoZWNrTWFpbkF4aXMgPSB0cnVlLFxuICAgICAgICBjcm9zc0F4aXM6IGNoZWNrQ3Jvc3NBeGlzID0gdHJ1ZSxcbiAgICAgICAgZmFsbGJhY2tQbGFjZW1lbnRzOiBzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMsXG4gICAgICAgIGZhbGxiYWNrU3RyYXRlZ3kgPSAnYmVzdEZpdCcsXG4gICAgICAgIGZhbGxiYWNrQXhpc1NpZGVEaXJlY3Rpb24gPSAnbm9uZScsXG4gICAgICAgIGZsaXBBbGlnbm1lbnQgPSB0cnVlLFxuICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnNcbiAgICAgIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG5cbiAgICAgIC8vIElmIGEgcmVzZXQgYnkgdGhlIGFycm93IHdhcyBjYXVzZWQgZHVlIHRvIGFuIGFsaWdubWVudCBvZmZzZXQgYmVpbmdcbiAgICAgIC8vIGFkZGVkLCB3ZSBzaG91bGQgc2tpcCBhbnkgbG9naWMgbm93IHNpbmNlIGBmbGlwKClgIGhhcyBhbHJlYWR5IGRvbmUgaXRzXG4gICAgICAvLyB3b3JrLlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zsb2F0aW5nLXVpL2Zsb2F0aW5nLXVpL2lzc3Vlcy8yNTQ5I2lzc3VlY29tbWVudC0xNzE5NjAxNjQzXG4gICAgICBpZiAoKF9taWRkbGV3YXJlRGF0YSRhcnJvdyA9IG1pZGRsZXdhcmVEYXRhLmFycm93KSAhPSBudWxsICYmIF9taWRkbGV3YXJlRGF0YSRhcnJvdy5hbGlnbm1lbnRPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgICAgY29uc3Qgc2lkZSA9IGdldFNpZGUocGxhY2VtZW50KTtcbiAgICAgIGNvbnN0IGluaXRpYWxTaWRlQXhpcyA9IGdldFNpZGVBeGlzKGluaXRpYWxQbGFjZW1lbnQpO1xuICAgICAgY29uc3QgaXNCYXNlUGxhY2VtZW50ID0gZ2V0U2lkZShpbml0aWFsUGxhY2VtZW50KSA9PT0gaW5pdGlhbFBsYWNlbWVudDtcbiAgICAgIGNvbnN0IHJ0bCA9IGF3YWl0IChwbGF0Zm9ybS5pc1JUTCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNSVEwoZWxlbWVudHMuZmxvYXRpbmcpKTtcbiAgICAgIGNvbnN0IGZhbGxiYWNrUGxhY2VtZW50cyA9IHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyB8fCAoaXNCYXNlUGxhY2VtZW50IHx8ICFmbGlwQWxpZ25tZW50ID8gW2dldE9wcG9zaXRlUGxhY2VtZW50KGluaXRpYWxQbGFjZW1lbnQpXSA6IGdldEV4cGFuZGVkUGxhY2VtZW50cyhpbml0aWFsUGxhY2VtZW50KSk7XG4gICAgICBjb25zdCBoYXNGYWxsYmFja0F4aXNTaWRlRGlyZWN0aW9uID0gZmFsbGJhY2tBeGlzU2lkZURpcmVjdGlvbiAhPT0gJ25vbmUnO1xuICAgICAgaWYgKCFzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMgJiYgaGFzRmFsbGJhY2tBeGlzU2lkZURpcmVjdGlvbikge1xuICAgICAgICBmYWxsYmFja1BsYWNlbWVudHMucHVzaCguLi5nZXRPcHBvc2l0ZUF4aXNQbGFjZW1lbnRzKGluaXRpYWxQbGFjZW1lbnQsIGZsaXBBbGlnbm1lbnQsIGZhbGxiYWNrQXhpc1NpZGVEaXJlY3Rpb24sIHJ0bCkpO1xuICAgICAgfVxuICAgICAgY29uc3QgcGxhY2VtZW50cyA9IFtpbml0aWFsUGxhY2VtZW50LCAuLi5mYWxsYmFja1BsYWNlbWVudHNdO1xuICAgICAgY29uc3Qgb3ZlcmZsb3cgPSBhd2FpdCBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwgZGV0ZWN0T3ZlcmZsb3dPcHRpb25zKTtcbiAgICAgIGNvbnN0IG92ZXJmbG93cyA9IFtdO1xuICAgICAgbGV0IG92ZXJmbG93c0RhdGEgPSAoKF9taWRkbGV3YXJlRGF0YSRmbGlwID0gbWlkZGxld2FyZURhdGEuZmxpcCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9taWRkbGV3YXJlRGF0YSRmbGlwLm92ZXJmbG93cykgfHwgW107XG4gICAgICBpZiAoY2hlY2tNYWluQXhpcykge1xuICAgICAgICBvdmVyZmxvd3MucHVzaChvdmVyZmxvd1tzaWRlXSk7XG4gICAgICB9XG4gICAgICBpZiAoY2hlY2tDcm9zc0F4aXMpIHtcbiAgICAgICAgY29uc3Qgc2lkZXMgPSBnZXRBbGlnbm1lbnRTaWRlcyhwbGFjZW1lbnQsIHJlY3RzLCBydGwpO1xuICAgICAgICBvdmVyZmxvd3MucHVzaChvdmVyZmxvd1tzaWRlc1swXV0sIG92ZXJmbG93W3NpZGVzWzFdXSk7XG4gICAgICB9XG4gICAgICBvdmVyZmxvd3NEYXRhID0gWy4uLm92ZXJmbG93c0RhdGEsIHtcbiAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICBvdmVyZmxvd3NcbiAgICAgIH1dO1xuXG4gICAgICAvLyBPbmUgb3IgbW9yZSBzaWRlcyBpcyBvdmVyZmxvd2luZy5cbiAgICAgIGlmICghb3ZlcmZsb3dzLmV2ZXJ5KHNpZGUgPT4gc2lkZSA8PSAwKSkge1xuICAgICAgICB2YXIgX21pZGRsZXdhcmVEYXRhJGZsaXAyLCBfb3ZlcmZsb3dzRGF0YSRmaWx0ZXI7XG4gICAgICAgIGNvbnN0IG5leHRJbmRleCA9ICgoKF9taWRkbGV3YXJlRGF0YSRmbGlwMiA9IG1pZGRsZXdhcmVEYXRhLmZsaXApID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkZmxpcDIuaW5kZXgpIHx8IDApICsgMTtcbiAgICAgICAgY29uc3QgbmV4dFBsYWNlbWVudCA9IHBsYWNlbWVudHNbbmV4dEluZGV4XTtcbiAgICAgICAgaWYgKG5leHRQbGFjZW1lbnQpIHtcbiAgICAgICAgICBjb25zdCBpZ25vcmVDcm9zc0F4aXNPdmVyZmxvdyA9IGNoZWNrQ3Jvc3NBeGlzID09PSAnYWxpZ25tZW50JyA/IGluaXRpYWxTaWRlQXhpcyAhPT0gZ2V0U2lkZUF4aXMobmV4dFBsYWNlbWVudCkgOiBmYWxzZTtcbiAgICAgICAgICBpZiAoIWlnbm9yZUNyb3NzQXhpc092ZXJmbG93IHx8XG4gICAgICAgICAgLy8gV2UgbGVhdmUgdGhlIGN1cnJlbnQgbWFpbiBheGlzIG9ubHkgaWYgZXZlcnkgcGxhY2VtZW50IG9uIHRoYXQgYXhpc1xuICAgICAgICAgIC8vIG92ZXJmbG93cyB0aGUgbWFpbiBheGlzLlxuICAgICAgICAgIG92ZXJmbG93c0RhdGEuZXZlcnkoZCA9PiBnZXRTaWRlQXhpcyhkLnBsYWNlbWVudCkgPT09IGluaXRpYWxTaWRlQXhpcyA/IGQub3ZlcmZsb3dzWzBdID4gMCA6IHRydWUpKSB7XG4gICAgICAgICAgICAvLyBUcnkgbmV4dCBwbGFjZW1lbnQgYW5kIHJlLXJ1biB0aGUgbGlmZWN5Y2xlLlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGluZGV4OiBuZXh0SW5kZXgsXG4gICAgICAgICAgICAgICAgb3ZlcmZsb3dzOiBvdmVyZmxvd3NEYXRhXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICAgICAgcGxhY2VtZW50OiBuZXh0UGxhY2VtZW50XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmlyc3QsIGZpbmQgdGhlIGNhbmRpZGF0ZXMgdGhhdCBmaXQgb24gdGhlIG1haW5BeGlzIHNpZGUgb2Ygb3ZlcmZsb3csXG4gICAgICAgIC8vIHRoZW4gZmluZCB0aGUgcGxhY2VtZW50IHRoYXQgZml0cyB0aGUgYmVzdCBvbiB0aGUgbWFpbiBjcm9zc0F4aXMgc2lkZS5cbiAgICAgICAgbGV0IHJlc2V0UGxhY2VtZW50ID0gKF9vdmVyZmxvd3NEYXRhJGZpbHRlciA9IG92ZXJmbG93c0RhdGEuZmlsdGVyKGQgPT4gZC5vdmVyZmxvd3NbMF0gPD0gMCkuc29ydCgoYSwgYikgPT4gYS5vdmVyZmxvd3NbMV0gLSBiLm92ZXJmbG93c1sxXSlbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfb3ZlcmZsb3dzRGF0YSRmaWx0ZXIucGxhY2VtZW50O1xuXG4gICAgICAgIC8vIE90aGVyd2lzZSBmYWxsYmFjay5cbiAgICAgICAgaWYgKCFyZXNldFBsYWNlbWVudCkge1xuICAgICAgICAgIHN3aXRjaCAoZmFsbGJhY2tTdHJhdGVneSkge1xuICAgICAgICAgICAgY2FzZSAnYmVzdEZpdCc6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgX292ZXJmbG93c0RhdGEkZmlsdGVyMjtcbiAgICAgICAgICAgICAgICBjb25zdCBwbGFjZW1lbnQgPSAoX292ZXJmbG93c0RhdGEkZmlsdGVyMiA9IG92ZXJmbG93c0RhdGEuZmlsdGVyKGQgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKGhhc0ZhbGxiYWNrQXhpc1NpZGVEaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFNpZGVBeGlzID0gZ2V0U2lkZUF4aXMoZC5wbGFjZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudFNpZGVBeGlzID09PSBpbml0aWFsU2lkZUF4aXMgfHxcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgYmlhcyB0byB0aGUgYHlgIHNpZGUgYXhpcyBkdWUgdG8gaG9yaXpvbnRhbFxuICAgICAgICAgICAgICAgICAgICAvLyByZWFkaW5nIGRpcmVjdGlvbnMgZmF2b3JpbmcgZ3JlYXRlciB3aWR0aC5cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFNpZGVBeGlzID09PSAneSc7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9KS5tYXAoZCA9PiBbZC5wbGFjZW1lbnQsIGQub3ZlcmZsb3dzLmZpbHRlcihvdmVyZmxvdyA9PiBvdmVyZmxvdyA+IDApLnJlZHVjZSgoYWNjLCBvdmVyZmxvdykgPT4gYWNjICsgb3ZlcmZsb3csIDApXSkuc29ydCgoYSwgYikgPT4gYVsxXSAtIGJbMV0pWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX292ZXJmbG93c0RhdGEkZmlsdGVyMlswXTtcbiAgICAgICAgICAgICAgICBpZiAocGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICByZXNldFBsYWNlbWVudCA9IHBsYWNlbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2luaXRpYWxQbGFjZW1lbnQnOlxuICAgICAgICAgICAgICByZXNldFBsYWNlbWVudCA9IGluaXRpYWxQbGFjZW1lbnQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGxhY2VtZW50ICE9PSByZXNldFBsYWNlbWVudCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgICBwbGFjZW1lbnQ6IHJlc2V0UGxhY2VtZW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGdldFNpZGVPZmZzZXRzKG92ZXJmbG93LCByZWN0KSB7XG4gIHJldHVybiB7XG4gICAgdG9wOiBvdmVyZmxvdy50b3AgLSByZWN0LmhlaWdodCxcbiAgICByaWdodDogb3ZlcmZsb3cucmlnaHQgLSByZWN0LndpZHRoLFxuICAgIGJvdHRvbTogb3ZlcmZsb3cuYm90dG9tIC0gcmVjdC5oZWlnaHQsXG4gICAgbGVmdDogb3ZlcmZsb3cubGVmdCAtIHJlY3Qud2lkdGhcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChvdmVyZmxvdykge1xuICByZXR1cm4gc2lkZXMuc29tZShzaWRlID0+IG92ZXJmbG93W3NpZGVdID49IDApO1xufVxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRvIGhpZGUgdGhlIGZsb2F0aW5nIGVsZW1lbnQgaW4gYXBwbGljYWJsZSBzaXR1YXRpb25zLCBzdWNoIGFzXG4gKiB3aGVuIGl0IGlzIG5vdCBpbiB0aGUgc2FtZSBjbGlwcGluZyBjb250ZXh0IGFzIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9oaWRlXG4gKi9cbmNvbnN0IGhpZGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2hpZGUnLFxuICAgIG9wdGlvbnMsXG4gICAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmVjdHNcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc3RyYXRlZ3kgPSAncmVmZXJlbmNlSGlkZGVuJyxcbiAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zXG4gICAgICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuICAgICAgc3dpdGNoIChzdHJhdGVneSkge1xuICAgICAgICBjYXNlICdyZWZlcmVuY2VIaWRkZW4nOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICAgICAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zLFxuICAgICAgICAgICAgICBlbGVtZW50Q29udGV4dDogJ3JlZmVyZW5jZSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKG92ZXJmbG93LCByZWN0cy5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIHJlZmVyZW5jZUhpZGRlbk9mZnNldHM6IG9mZnNldHMsXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlSGlkZGVuOiBpc0FueVNpZGVGdWxseUNsaXBwZWQob2Zmc2V0cylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2VzY2FwZWQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICAgICAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zLFxuICAgICAgICAgICAgICBhbHRCb3VuZGFyeTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXRzID0gZ2V0U2lkZU9mZnNldHMob3ZlcmZsb3csIHJlY3RzLmZsb2F0aW5nKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBlc2NhcGVkT2Zmc2V0czogb2Zmc2V0cyxcbiAgICAgICAgICAgICAgICBlc2NhcGVkOiBpc0FueVNpZGVGdWxseUNsaXBwZWQob2Zmc2V0cylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG59O1xuXG5mdW5jdGlvbiBnZXRCb3VuZGluZ1JlY3QocmVjdHMpIHtcbiAgY29uc3QgbWluWCA9IG1pbiguLi5yZWN0cy5tYXAocmVjdCA9PiByZWN0LmxlZnQpKTtcbiAgY29uc3QgbWluWSA9IG1pbiguLi5yZWN0cy5tYXAocmVjdCA9PiByZWN0LnRvcCkpO1xuICBjb25zdCBtYXhYID0gbWF4KC4uLnJlY3RzLm1hcChyZWN0ID0+IHJlY3QucmlnaHQpKTtcbiAgY29uc3QgbWF4WSA9IG1heCguLi5yZWN0cy5tYXAocmVjdCA9PiByZWN0LmJvdHRvbSkpO1xuICByZXR1cm4ge1xuICAgIHg6IG1pblgsXG4gICAgeTogbWluWSxcbiAgICB3aWR0aDogbWF4WCAtIG1pblgsXG4gICAgaGVpZ2h0OiBtYXhZIC0gbWluWVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0UmVjdHNCeUxpbmUocmVjdHMpIHtcbiAgY29uc3Qgc29ydGVkUmVjdHMgPSByZWN0cy5zbGljZSgpLnNvcnQoKGEsIGIpID0+IGEueSAtIGIueSk7XG4gIGNvbnN0IGdyb3VwcyA9IFtdO1xuICBsZXQgcHJldlJlY3QgPSBudWxsO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNvcnRlZFJlY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcmVjdCA9IHNvcnRlZFJlY3RzW2ldO1xuICAgIGlmICghcHJldlJlY3QgfHwgcmVjdC55IC0gcHJldlJlY3QueSA+IHByZXZSZWN0LmhlaWdodCAvIDIpIHtcbiAgICAgIGdyb3Vwcy5wdXNoKFtyZWN0XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdyb3Vwc1tncm91cHMubGVuZ3RoIC0gMV0ucHVzaChyZWN0KTtcbiAgICB9XG4gICAgcHJldlJlY3QgPSByZWN0O1xuICB9XG4gIHJldHVybiBncm91cHMubWFwKHJlY3QgPT4gcmVjdFRvQ2xpZW50UmVjdChnZXRCb3VuZGluZ1JlY3QocmVjdCkpKTtcbn1cbi8qKlxuICogUHJvdmlkZXMgaW1wcm92ZWQgcG9zaXRpb25pbmcgZm9yIGlubGluZSByZWZlcmVuY2UgZWxlbWVudHMgdGhhdCBjYW4gc3BhblxuICogb3ZlciBtdWx0aXBsZSBsaW5lcywgc3VjaCBhcyBoeXBlcmxpbmtzIG9yIHJhbmdlIHNlbGVjdGlvbnMuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvaW5saW5lXG4gKi9cbmNvbnN0IGlubGluZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnaW5saW5lJyxcbiAgICBvcHRpb25zLFxuICAgIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgZWxlbWVudHMsXG4gICAgICAgIHJlY3RzLFxuICAgICAgICBwbGF0Zm9ybSxcbiAgICAgICAgc3RyYXRlZ3lcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIC8vIEEgTW91c2VFdmVudCdzIGNsaWVudHtYLFl9IGNvb3JkcyBjYW4gYmUgdXAgdG8gMiBwaXhlbHMgb2ZmIGFcbiAgICAgIC8vIENsaWVudFJlY3QncyBib3VuZHMsIGRlc3BpdGUgdGhlIGV2ZW50IGxpc3RlbmVyIGJlaW5nIHRyaWdnZXJlZC4gQVxuICAgICAgLy8gcGFkZGluZyBvZiAyIHNlZW1zIHRvIGhhbmRsZSB0aGlzIGlzc3VlLlxuICAgICAgY29uc3Qge1xuICAgICAgICBwYWRkaW5nID0gMixcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcbiAgICAgIGNvbnN0IG5hdGl2ZUNsaWVudFJlY3RzID0gQXJyYXkuZnJvbSgoYXdhaXQgKHBsYXRmb3JtLmdldENsaWVudFJlY3RzID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5nZXRDbGllbnRSZWN0cyhlbGVtZW50cy5yZWZlcmVuY2UpKSkgfHwgW10pO1xuICAgICAgY29uc3QgY2xpZW50UmVjdHMgPSBnZXRSZWN0c0J5TGluZShuYXRpdmVDbGllbnRSZWN0cyk7XG4gICAgICBjb25zdCBmYWxsYmFjayA9IHJlY3RUb0NsaWVudFJlY3QoZ2V0Qm91bmRpbmdSZWN0KG5hdGl2ZUNsaWVudFJlY3RzKSk7XG4gICAgICBjb25zdCBwYWRkaW5nT2JqZWN0ID0gZ2V0UGFkZGluZ09iamVjdChwYWRkaW5nKTtcbiAgICAgIGZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIHtcbiAgICAgICAgLy8gVGhlcmUgYXJlIHR3byByZWN0cyBhbmQgdGhleSBhcmUgZGlzam9pbmVkLlxuICAgICAgICBpZiAoY2xpZW50UmVjdHMubGVuZ3RoID09PSAyICYmIGNsaWVudFJlY3RzWzBdLmxlZnQgPiBjbGllbnRSZWN0c1sxXS5yaWdodCAmJiB4ICE9IG51bGwgJiYgeSAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gRmluZCB0aGUgZmlyc3QgcmVjdCBpbiB3aGljaCB0aGUgcG9pbnQgaXMgZnVsbHkgaW5zaWRlLlxuICAgICAgICAgIHJldHVybiBjbGllbnRSZWN0cy5maW5kKHJlY3QgPT4geCA+IHJlY3QubGVmdCAtIHBhZGRpbmdPYmplY3QubGVmdCAmJiB4IDwgcmVjdC5yaWdodCArIHBhZGRpbmdPYmplY3QucmlnaHQgJiYgeSA+IHJlY3QudG9wIC0gcGFkZGluZ09iamVjdC50b3AgJiYgeSA8IHJlY3QuYm90dG9tICsgcGFkZGluZ09iamVjdC5ib3R0b20pIHx8IGZhbGxiYWNrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlcmUgYXJlIDIgb3IgbW9yZSBjb25uZWN0ZWQgcmVjdHMuXG4gICAgICAgIGlmIChjbGllbnRSZWN0cy5sZW5ndGggPj0gMikge1xuICAgICAgICAgIGlmIChnZXRTaWRlQXhpcyhwbGFjZW1lbnQpID09PSAneScpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0UmVjdCA9IGNsaWVudFJlY3RzWzBdO1xuICAgICAgICAgICAgY29uc3QgbGFzdFJlY3QgPSBjbGllbnRSZWN0c1tjbGllbnRSZWN0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGNvbnN0IGlzVG9wID0gZ2V0U2lkZShwbGFjZW1lbnQpID09PSAndG9wJztcbiAgICAgICAgICAgIGNvbnN0IHRvcCA9IGZpcnN0UmVjdC50b3A7XG4gICAgICAgICAgICBjb25zdCBib3R0b20gPSBsYXN0UmVjdC5ib3R0b207XG4gICAgICAgICAgICBjb25zdCBsZWZ0ID0gaXNUb3AgPyBmaXJzdFJlY3QubGVmdCA6IGxhc3RSZWN0LmxlZnQ7XG4gICAgICAgICAgICBjb25zdCByaWdodCA9IGlzVG9wID8gZmlyc3RSZWN0LnJpZ2h0IDogbGFzdFJlY3QucmlnaHQ7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IGJvdHRvbSAtIHRvcDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHRvcCxcbiAgICAgICAgICAgICAgYm90dG9tLFxuICAgICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgICByaWdodCxcbiAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgICAgeDogbGVmdCxcbiAgICAgICAgICAgICAgeTogdG9wXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBpc0xlZnRTaWRlID0gZ2V0U2lkZShwbGFjZW1lbnQpID09PSAnbGVmdCc7XG4gICAgICAgICAgY29uc3QgbWF4UmlnaHQgPSBtYXgoLi4uY2xpZW50UmVjdHMubWFwKHJlY3QgPT4gcmVjdC5yaWdodCkpO1xuICAgICAgICAgIGNvbnN0IG1pbkxlZnQgPSBtaW4oLi4uY2xpZW50UmVjdHMubWFwKHJlY3QgPT4gcmVjdC5sZWZ0KSk7XG4gICAgICAgICAgY29uc3QgbWVhc3VyZVJlY3RzID0gY2xpZW50UmVjdHMuZmlsdGVyKHJlY3QgPT4gaXNMZWZ0U2lkZSA/IHJlY3QubGVmdCA9PT0gbWluTGVmdCA6IHJlY3QucmlnaHQgPT09IG1heFJpZ2h0KTtcbiAgICAgICAgICBjb25zdCB0b3AgPSBtZWFzdXJlUmVjdHNbMF0udG9wO1xuICAgICAgICAgIGNvbnN0IGJvdHRvbSA9IG1lYXN1cmVSZWN0c1ttZWFzdXJlUmVjdHMubGVuZ3RoIC0gMV0uYm90dG9tO1xuICAgICAgICAgIGNvbnN0IGxlZnQgPSBtaW5MZWZ0O1xuICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gbWF4UmlnaHQ7XG4gICAgICAgICAgY29uc3Qgd2lkdGggPSByaWdodCAtIGxlZnQ7XG4gICAgICAgICAgY29uc3QgaGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b3AsXG4gICAgICAgICAgICBib3R0b20sXG4gICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgcmlnaHQsXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgIHg6IGxlZnQsXG4gICAgICAgICAgICB5OiB0b3BcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxsYmFjaztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc2V0UmVjdHMgPSBhd2FpdCBwbGF0Zm9ybS5nZXRFbGVtZW50UmVjdHMoe1xuICAgICAgICByZWZlcmVuY2U6IHtcbiAgICAgICAgICBnZXRCb3VuZGluZ0NsaWVudFJlY3RcbiAgICAgICAgfSxcbiAgICAgICAgZmxvYXRpbmc6IGVsZW1lbnRzLmZsb2F0aW5nLFxuICAgICAgICBzdHJhdGVneVxuICAgICAgfSk7XG4gICAgICBpZiAocmVjdHMucmVmZXJlbmNlLnggIT09IHJlc2V0UmVjdHMucmVmZXJlbmNlLnggfHwgcmVjdHMucmVmZXJlbmNlLnkgIT09IHJlc2V0UmVjdHMucmVmZXJlbmNlLnkgfHwgcmVjdHMucmVmZXJlbmNlLndpZHRoICE9PSByZXNldFJlY3RzLnJlZmVyZW5jZS53aWR0aCB8fCByZWN0cy5yZWZlcmVuY2UuaGVpZ2h0ICE9PSByZXNldFJlY3RzLnJlZmVyZW5jZS5oZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgcmVjdHM6IHJlc2V0UmVjdHNcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9O1xufTtcblxuY29uc3Qgb3JpZ2luU2lkZXMgPSAvKiNfX1BVUkVfXyovbmV3IFNldChbJ2xlZnQnLCAndG9wJ10pO1xuXG4vLyBGb3IgdHlwZSBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSwgdGhlIGBPZmZzZXRPcHRpb25zYCB0eXBlIHdhcyBhbHNvXG4vLyBEZXJpdmFibGUuXG5cbmFzeW5jIGZ1bmN0aW9uIGNvbnZlcnRWYWx1ZVRvQ29vcmRzKHN0YXRlLCBvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBwbGFjZW1lbnQsXG4gICAgcGxhdGZvcm0sXG4gICAgZWxlbWVudHNcbiAgfSA9IHN0YXRlO1xuICBjb25zdCBydGwgPSBhd2FpdCAocGxhdGZvcm0uaXNSVEwgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmlzUlRMKGVsZW1lbnRzLmZsb2F0aW5nKSk7XG4gIGNvbnN0IHNpZGUgPSBnZXRTaWRlKHBsYWNlbWVudCk7XG4gIGNvbnN0IGFsaWdubWVudCA9IGdldEFsaWdubWVudChwbGFjZW1lbnQpO1xuICBjb25zdCBpc1ZlcnRpY2FsID0gZ2V0U2lkZUF4aXMocGxhY2VtZW50KSA9PT0gJ3knO1xuICBjb25zdCBtYWluQXhpc011bHRpID0gb3JpZ2luU2lkZXMuaGFzKHNpZGUpID8gLTEgOiAxO1xuICBjb25zdCBjcm9zc0F4aXNNdWx0aSA9IHJ0bCAmJiBpc1ZlcnRpY2FsID8gLTEgOiAxO1xuICBjb25zdCByYXdWYWx1ZSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWNvbnN0XG4gIGxldCB7XG4gICAgbWFpbkF4aXMsXG4gICAgY3Jvc3NBeGlzLFxuICAgIGFsaWdubWVudEF4aXNcbiAgfSA9IHR5cGVvZiByYXdWYWx1ZSA9PT0gJ251bWJlcicgPyB7XG4gICAgbWFpbkF4aXM6IHJhd1ZhbHVlLFxuICAgIGNyb3NzQXhpczogMCxcbiAgICBhbGlnbm1lbnRBeGlzOiBudWxsXG4gIH0gOiB7XG4gICAgbWFpbkF4aXM6IHJhd1ZhbHVlLm1haW5BeGlzIHx8IDAsXG4gICAgY3Jvc3NBeGlzOiByYXdWYWx1ZS5jcm9zc0F4aXMgfHwgMCxcbiAgICBhbGlnbm1lbnRBeGlzOiByYXdWYWx1ZS5hbGlnbm1lbnRBeGlzXG4gIH07XG4gIGlmIChhbGlnbm1lbnQgJiYgdHlwZW9mIGFsaWdubWVudEF4aXMgPT09ICdudW1iZXInKSB7XG4gICAgY3Jvc3NBeGlzID0gYWxpZ25tZW50ID09PSAnZW5kJyA/IGFsaWdubWVudEF4aXMgKiAtMSA6IGFsaWdubWVudEF4aXM7XG4gIH1cbiAgcmV0dXJuIGlzVmVydGljYWwgPyB7XG4gICAgeDogY3Jvc3NBeGlzICogY3Jvc3NBeGlzTXVsdGksXG4gICAgeTogbWFpbkF4aXMgKiBtYWluQXhpc011bHRpXG4gIH0gOiB7XG4gICAgeDogbWFpbkF4aXMgKiBtYWluQXhpc011bHRpLFxuICAgIHk6IGNyb3NzQXhpcyAqIGNyb3NzQXhpc011bHRpXG4gIH07XG59XG5cbi8qKlxuICogTW9kaWZpZXMgdGhlIHBsYWNlbWVudCBieSB0cmFuc2xhdGluZyB0aGUgZmxvYXRpbmcgZWxlbWVudCBhbG9uZyB0aGVcbiAqIHNwZWNpZmllZCBheGVzLlxuICogQSBudW1iZXIgKHNob3J0aGFuZCBmb3IgYG1haW5BeGlzYCBvciBkaXN0YW5jZSksIG9yIGFuIGF4ZXMgY29uZmlndXJhdGlvblxuICogb2JqZWN0IG1heSBiZSBwYXNzZWQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3Mvb2Zmc2V0XG4gKi9cbmNvbnN0IG9mZnNldCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0gMDtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdvZmZzZXQnLFxuICAgIG9wdGlvbnMsXG4gICAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICAgIHZhciBfbWlkZGxld2FyZURhdGEkb2Zmc2UsIF9taWRkbGV3YXJlRGF0YSRhcnJvdztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICBtaWRkbGV3YXJlRGF0YVxuICAgICAgfSA9IHN0YXRlO1xuICAgICAgY29uc3QgZGlmZkNvb3JkcyA9IGF3YWl0IGNvbnZlcnRWYWx1ZVRvQ29vcmRzKHN0YXRlLCBvcHRpb25zKTtcblxuICAgICAgLy8gSWYgdGhlIHBsYWNlbWVudCBpcyB0aGUgc2FtZSBhbmQgdGhlIGFycm93IGNhdXNlZCBhbiBhbGlnbm1lbnQgb2Zmc2V0XG4gICAgICAvLyB0aGVuIHdlIGRvbid0IG5lZWQgdG8gY2hhbmdlIHRoZSBwb3NpdGlvbmluZyBjb29yZGluYXRlcy5cbiAgICAgIGlmIChwbGFjZW1lbnQgPT09ICgoX21pZGRsZXdhcmVEYXRhJG9mZnNlID0gbWlkZGxld2FyZURhdGEub2Zmc2V0KSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJG9mZnNlLnBsYWNlbWVudCkgJiYgKF9taWRkbGV3YXJlRGF0YSRhcnJvdyA9IG1pZGRsZXdhcmVEYXRhLmFycm93KSAhPSBudWxsICYmIF9taWRkbGV3YXJlRGF0YSRhcnJvdy5hbGlnbm1lbnRPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCArIGRpZmZDb29yZHMueCxcbiAgICAgICAgeTogeSArIGRpZmZDb29yZHMueSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIC4uLmRpZmZDb29yZHMsXG4gICAgICAgICAgcGxhY2VtZW50XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xufTtcblxuLyoqXG4gKiBPcHRpbWl6ZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYnkgc2hpZnRpbmcgaXQgaW4gb3JkZXIgdG9cbiAqIGtlZXAgaXQgaW4gdmlldyB3aGVuIGl0IHdpbGwgb3ZlcmZsb3cgdGhlIGNsaXBwaW5nIGJvdW5kYXJ5LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3NoaWZ0XG4gKi9cbmNvbnN0IHNoaWZ0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdzaGlmdCcsXG4gICAgb3B0aW9ucyxcbiAgICBhc3luYyBmbihzdGF0ZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBwbGFjZW1lbnRcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbWFpbkF4aXM6IGNoZWNrTWFpbkF4aXMgPSB0cnVlLFxuICAgICAgICBjcm9zc0F4aXM6IGNoZWNrQ3Jvc3NBeGlzID0gZmFsc2UsXG4gICAgICAgIGxpbWl0ZXIgPSB7XG4gICAgICAgICAgZm46IF9yZWYgPT4ge1xuICAgICAgICAgICAgbGV0IHtcbiAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgeVxuICAgICAgICAgICAgfSA9IF9yZWY7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICB5XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zXG4gICAgICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuICAgICAgY29uc3QgY29vcmRzID0ge1xuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9O1xuICAgICAgY29uc3Qgb3ZlcmZsb3cgPSBhd2FpdCBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwgZGV0ZWN0T3ZlcmZsb3dPcHRpb25zKTtcbiAgICAgIGNvbnN0IGNyb3NzQXhpcyA9IGdldFNpZGVBeGlzKGdldFNpZGUocGxhY2VtZW50KSk7XG4gICAgICBjb25zdCBtYWluQXhpcyA9IGdldE9wcG9zaXRlQXhpcyhjcm9zc0F4aXMpO1xuICAgICAgbGV0IG1haW5BeGlzQ29vcmQgPSBjb29yZHNbbWFpbkF4aXNdO1xuICAgICAgbGV0IGNyb3NzQXhpc0Nvb3JkID0gY29vcmRzW2Nyb3NzQXhpc107XG4gICAgICBpZiAoY2hlY2tNYWluQXhpcykge1xuICAgICAgICBjb25zdCBtaW5TaWRlID0gbWFpbkF4aXMgPT09ICd5JyA/ICd0b3AnIDogJ2xlZnQnO1xuICAgICAgICBjb25zdCBtYXhTaWRlID0gbWFpbkF4aXMgPT09ICd5JyA/ICdib3R0b20nIDogJ3JpZ2h0JztcbiAgICAgICAgY29uc3QgbWluID0gbWFpbkF4aXNDb29yZCArIG92ZXJmbG93W21pblNpZGVdO1xuICAgICAgICBjb25zdCBtYXggPSBtYWluQXhpc0Nvb3JkIC0gb3ZlcmZsb3dbbWF4U2lkZV07XG4gICAgICAgIG1haW5BeGlzQ29vcmQgPSBjbGFtcChtaW4sIG1haW5BeGlzQ29vcmQsIG1heCk7XG4gICAgICB9XG4gICAgICBpZiAoY2hlY2tDcm9zc0F4aXMpIHtcbiAgICAgICAgY29uc3QgbWluU2lkZSA9IGNyb3NzQXhpcyA9PT0gJ3knID8gJ3RvcCcgOiAnbGVmdCc7XG4gICAgICAgIGNvbnN0IG1heFNpZGUgPSBjcm9zc0F4aXMgPT09ICd5JyA/ICdib3R0b20nIDogJ3JpZ2h0JztcbiAgICAgICAgY29uc3QgbWluID0gY3Jvc3NBeGlzQ29vcmQgKyBvdmVyZmxvd1ttaW5TaWRlXTtcbiAgICAgICAgY29uc3QgbWF4ID0gY3Jvc3NBeGlzQ29vcmQgLSBvdmVyZmxvd1ttYXhTaWRlXTtcbiAgICAgICAgY3Jvc3NBeGlzQ29vcmQgPSBjbGFtcChtaW4sIGNyb3NzQXhpc0Nvb3JkLCBtYXgpO1xuICAgICAgfVxuICAgICAgY29uc3QgbGltaXRlZENvb3JkcyA9IGxpbWl0ZXIuZm4oe1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgW21haW5BeGlzXTogbWFpbkF4aXNDb29yZCxcbiAgICAgICAgW2Nyb3NzQXhpc106IGNyb3NzQXhpc0Nvb3JkXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmxpbWl0ZWRDb29yZHMsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICB4OiBsaW1pdGVkQ29vcmRzLnggLSB4LFxuICAgICAgICAgIHk6IGxpbWl0ZWRDb29yZHMueSAtIHksXG4gICAgICAgICAgZW5hYmxlZDoge1xuICAgICAgICAgICAgW21haW5BeGlzXTogY2hlY2tNYWluQXhpcyxcbiAgICAgICAgICAgIFtjcm9zc0F4aXNdOiBjaGVja0Nyb3NzQXhpc1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH07XG59O1xuLyoqXG4gKiBCdWlsdC1pbiBgbGltaXRlcmAgdGhhdCB3aWxsIHN0b3AgYHNoaWZ0KClgIGF0IGEgY2VydGFpbiBwb2ludC5cbiAqL1xuY29uc3QgbGltaXRTaGlmdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBvcHRpb25zLFxuICAgIGZuKHN0YXRlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgcmVjdHMsXG4gICAgICAgIG1pZGRsZXdhcmVEYXRhXG4gICAgICB9ID0gc3RhdGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG9mZnNldCA9IDAsXG4gICAgICAgIG1haW5BeGlzOiBjaGVja01haW5BeGlzID0gdHJ1ZSxcbiAgICAgICAgY3Jvc3NBeGlzOiBjaGVja0Nyb3NzQXhpcyA9IHRydWVcbiAgICAgIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG4gICAgICBjb25zdCBjb29yZHMgPSB7XG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH07XG4gICAgICBjb25zdCBjcm9zc0F4aXMgPSBnZXRTaWRlQXhpcyhwbGFjZW1lbnQpO1xuICAgICAgY29uc3QgbWFpbkF4aXMgPSBnZXRPcHBvc2l0ZUF4aXMoY3Jvc3NBeGlzKTtcbiAgICAgIGxldCBtYWluQXhpc0Nvb3JkID0gY29vcmRzW21haW5BeGlzXTtcbiAgICAgIGxldCBjcm9zc0F4aXNDb29yZCA9IGNvb3Jkc1tjcm9zc0F4aXNdO1xuICAgICAgY29uc3QgcmF3T2Zmc2V0ID0gZXZhbHVhdGUob2Zmc2V0LCBzdGF0ZSk7XG4gICAgICBjb25zdCBjb21wdXRlZE9mZnNldCA9IHR5cGVvZiByYXdPZmZzZXQgPT09ICdudW1iZXInID8ge1xuICAgICAgICBtYWluQXhpczogcmF3T2Zmc2V0LFxuICAgICAgICBjcm9zc0F4aXM6IDBcbiAgICAgIH0gOiB7XG4gICAgICAgIG1haW5BeGlzOiAwLFxuICAgICAgICBjcm9zc0F4aXM6IDAsXG4gICAgICAgIC4uLnJhd09mZnNldFxuICAgICAgfTtcbiAgICAgIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgICAgIGNvbnN0IGxlbiA9IG1haW5BeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gICAgICAgIGNvbnN0IGxpbWl0TWluID0gcmVjdHMucmVmZXJlbmNlW21haW5BeGlzXSAtIHJlY3RzLmZsb2F0aW5nW2xlbl0gKyBjb21wdXRlZE9mZnNldC5tYWluQXhpcztcbiAgICAgICAgY29uc3QgbGltaXRNYXggPSByZWN0cy5yZWZlcmVuY2VbbWFpbkF4aXNdICsgcmVjdHMucmVmZXJlbmNlW2xlbl0gLSBjb21wdXRlZE9mZnNldC5tYWluQXhpcztcbiAgICAgICAgaWYgKG1haW5BeGlzQ29vcmQgPCBsaW1pdE1pbikge1xuICAgICAgICAgIG1haW5BeGlzQ29vcmQgPSBsaW1pdE1pbjtcbiAgICAgICAgfSBlbHNlIGlmIChtYWluQXhpc0Nvb3JkID4gbGltaXRNYXgpIHtcbiAgICAgICAgICBtYWluQXhpc0Nvb3JkID0gbGltaXRNYXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjaGVja0Nyb3NzQXhpcykge1xuICAgICAgICB2YXIgX21pZGRsZXdhcmVEYXRhJG9mZnNlLCBfbWlkZGxld2FyZURhdGEkb2Zmc2UyO1xuICAgICAgICBjb25zdCBsZW4gPSBtYWluQXhpcyA9PT0gJ3knID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuICAgICAgICBjb25zdCBpc09yaWdpblNpZGUgPSBvcmlnaW5TaWRlcy5oYXMoZ2V0U2lkZShwbGFjZW1lbnQpKTtcbiAgICAgICAgY29uc3QgbGltaXRNaW4gPSByZWN0cy5yZWZlcmVuY2VbY3Jvc3NBeGlzXSAtIHJlY3RzLmZsb2F0aW5nW2xlbl0gKyAoaXNPcmlnaW5TaWRlID8gKChfbWlkZGxld2FyZURhdGEkb2Zmc2UgPSBtaWRkbGV3YXJlRGF0YS5vZmZzZXQpID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkb2Zmc2VbY3Jvc3NBeGlzXSkgfHwgMCA6IDApICsgKGlzT3JpZ2luU2lkZSA/IDAgOiBjb21wdXRlZE9mZnNldC5jcm9zc0F4aXMpO1xuICAgICAgICBjb25zdCBsaW1pdE1heCA9IHJlY3RzLnJlZmVyZW5jZVtjcm9zc0F4aXNdICsgcmVjdHMucmVmZXJlbmNlW2xlbl0gKyAoaXNPcmlnaW5TaWRlID8gMCA6ICgoX21pZGRsZXdhcmVEYXRhJG9mZnNlMiA9IG1pZGRsZXdhcmVEYXRhLm9mZnNldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9taWRkbGV3YXJlRGF0YSRvZmZzZTJbY3Jvc3NBeGlzXSkgfHwgMCkgLSAoaXNPcmlnaW5TaWRlID8gY29tcHV0ZWRPZmZzZXQuY3Jvc3NBeGlzIDogMCk7XG4gICAgICAgIGlmIChjcm9zc0F4aXNDb29yZCA8IGxpbWl0TWluKSB7XG4gICAgICAgICAgY3Jvc3NBeGlzQ29vcmQgPSBsaW1pdE1pbjtcbiAgICAgICAgfSBlbHNlIGlmIChjcm9zc0F4aXNDb29yZCA+IGxpbWl0TWF4KSB7XG4gICAgICAgICAgY3Jvc3NBeGlzQ29vcmQgPSBsaW1pdE1heDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgW21haW5BeGlzXTogbWFpbkF4aXNDb29yZCxcbiAgICAgICAgW2Nyb3NzQXhpc106IGNyb3NzQXhpc0Nvb3JkXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn07XG5cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0aGF0IGFsbG93cyB5b3UgdG8gY2hhbmdlIHRoZSBzaXplIG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IOKAlFxuICogZm9yIGluc3RhbmNlLCBwcmV2ZW50IGl0IGZyb20gb3ZlcmZsb3dpbmcgdGhlIGNsaXBwaW5nIGJvdW5kYXJ5IG9yIG1hdGNoIHRoZVxuICogd2lkdGggb2YgdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3NpemVcbiAqL1xuY29uc3Qgc2l6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnc2l6ZScsXG4gICAgb3B0aW9ucyxcbiAgICBhc3luYyBmbihzdGF0ZSkge1xuICAgICAgdmFyIF9zdGF0ZSRtaWRkbGV3YXJlRGF0YSwgX3N0YXRlJG1pZGRsZXdhcmVEYXRhMjtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICByZWN0cyxcbiAgICAgICAgcGxhdGZvcm0sXG4gICAgICAgIGVsZW1lbnRzXG4gICAgICB9ID0gc3RhdGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFwcGx5ID0gKCkgPT4ge30sXG4gICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9uc1xuICAgICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcbiAgICAgIGNvbnN0IG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIGRldGVjdE92ZXJmbG93T3B0aW9ucyk7XG4gICAgICBjb25zdCBzaWRlID0gZ2V0U2lkZShwbGFjZW1lbnQpO1xuICAgICAgY29uc3QgYWxpZ25tZW50ID0gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCk7XG4gICAgICBjb25zdCBpc1lBeGlzID0gZ2V0U2lkZUF4aXMocGxhY2VtZW50KSA9PT0gJ3knO1xuICAgICAgY29uc3Qge1xuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICB9ID0gcmVjdHMuZmxvYXRpbmc7XG4gICAgICBsZXQgaGVpZ2h0U2lkZTtcbiAgICAgIGxldCB3aWR0aFNpZGU7XG4gICAgICBpZiAoc2lkZSA9PT0gJ3RvcCcgfHwgc2lkZSA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgaGVpZ2h0U2lkZSA9IHNpZGU7XG4gICAgICAgIHdpZHRoU2lkZSA9IGFsaWdubWVudCA9PT0gKChhd2FpdCAocGxhdGZvcm0uaXNSVEwgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmlzUlRMKGVsZW1lbnRzLmZsb2F0aW5nKSkpID8gJ3N0YXJ0JyA6ICdlbmQnKSA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aWR0aFNpZGUgPSBzaWRlO1xuICAgICAgICBoZWlnaHRTaWRlID0gYWxpZ25tZW50ID09PSAnZW5kJyA/ICd0b3AnIDogJ2JvdHRvbSc7XG4gICAgICB9XG4gICAgICBjb25zdCBtYXhpbXVtQ2xpcHBpbmdIZWlnaHQgPSBoZWlnaHQgLSBvdmVyZmxvdy50b3AgLSBvdmVyZmxvdy5ib3R0b207XG4gICAgICBjb25zdCBtYXhpbXVtQ2xpcHBpbmdXaWR0aCA9IHdpZHRoIC0gb3ZlcmZsb3cubGVmdCAtIG92ZXJmbG93LnJpZ2h0O1xuICAgICAgY29uc3Qgb3ZlcmZsb3dBdmFpbGFibGVIZWlnaHQgPSBtaW4oaGVpZ2h0IC0gb3ZlcmZsb3dbaGVpZ2h0U2lkZV0sIG1heGltdW1DbGlwcGluZ0hlaWdodCk7XG4gICAgICBjb25zdCBvdmVyZmxvd0F2YWlsYWJsZVdpZHRoID0gbWluKHdpZHRoIC0gb3ZlcmZsb3dbd2lkdGhTaWRlXSwgbWF4aW11bUNsaXBwaW5nV2lkdGgpO1xuICAgICAgY29uc3Qgbm9TaGlmdCA9ICFzdGF0ZS5taWRkbGV3YXJlRGF0YS5zaGlmdDtcbiAgICAgIGxldCBhdmFpbGFibGVIZWlnaHQgPSBvdmVyZmxvd0F2YWlsYWJsZUhlaWdodDtcbiAgICAgIGxldCBhdmFpbGFibGVXaWR0aCA9IG92ZXJmbG93QXZhaWxhYmxlV2lkdGg7XG4gICAgICBpZiAoKF9zdGF0ZSRtaWRkbGV3YXJlRGF0YSA9IHN0YXRlLm1pZGRsZXdhcmVEYXRhLnNoaWZ0KSAhPSBudWxsICYmIF9zdGF0ZSRtaWRkbGV3YXJlRGF0YS5lbmFibGVkLngpIHtcbiAgICAgICAgYXZhaWxhYmxlV2lkdGggPSBtYXhpbXVtQ2xpcHBpbmdXaWR0aDtcbiAgICAgIH1cbiAgICAgIGlmICgoX3N0YXRlJG1pZGRsZXdhcmVEYXRhMiA9IHN0YXRlLm1pZGRsZXdhcmVEYXRhLnNoaWZ0KSAhPSBudWxsICYmIF9zdGF0ZSRtaWRkbGV3YXJlRGF0YTIuZW5hYmxlZC55KSB7XG4gICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IG1heGltdW1DbGlwcGluZ0hlaWdodDtcbiAgICAgIH1cbiAgICAgIGlmIChub1NoaWZ0ICYmICFhbGlnbm1lbnQpIHtcbiAgICAgICAgY29uc3QgeE1pbiA9IG1heChvdmVyZmxvdy5sZWZ0LCAwKTtcbiAgICAgICAgY29uc3QgeE1heCA9IG1heChvdmVyZmxvdy5yaWdodCwgMCk7XG4gICAgICAgIGNvbnN0IHlNaW4gPSBtYXgob3ZlcmZsb3cudG9wLCAwKTtcbiAgICAgICAgY29uc3QgeU1heCA9IG1heChvdmVyZmxvdy5ib3R0b20sIDApO1xuICAgICAgICBpZiAoaXNZQXhpcykge1xuICAgICAgICAgIGF2YWlsYWJsZVdpZHRoID0gd2lkdGggLSAyICogKHhNaW4gIT09IDAgfHwgeE1heCAhPT0gMCA/IHhNaW4gKyB4TWF4IDogbWF4KG92ZXJmbG93LmxlZnQsIG92ZXJmbG93LnJpZ2h0KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gaGVpZ2h0IC0gMiAqICh5TWluICE9PSAwIHx8IHlNYXggIT09IDAgPyB5TWluICsgeU1heCA6IG1heChvdmVyZmxvdy50b3AsIG92ZXJmbG93LmJvdHRvbSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhd2FpdCBhcHBseSh7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBhdmFpbGFibGVXaWR0aCxcbiAgICAgICAgYXZhaWxhYmxlSGVpZ2h0XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG5leHREaW1lbnNpb25zID0gYXdhaXQgcGxhdGZvcm0uZ2V0RGltZW5zaW9ucyhlbGVtZW50cy5mbG9hdGluZyk7XG4gICAgICBpZiAod2lkdGggIT09IG5leHREaW1lbnNpb25zLndpZHRoIHx8IGhlaWdodCAhPT0gbmV4dERpbWVuc2lvbnMuaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgIHJlY3RzOiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgfTtcbn07XG5cbmV4cG9ydCB7IGFycm93LCBhdXRvUGxhY2VtZW50LCBjb21wdXRlUG9zaXRpb24sIGRldGVjdE92ZXJmbG93LCBmbGlwLCBoaWRlLCBpbmxpbmUsIGxpbWl0U2hpZnQsIG9mZnNldCwgc2hpZnQsIHNpemUgfTtcbiJdLCJuYW1lcyI6WyJnZXRTaWRlQXhpcyIsImdldEFsaWdubWVudEF4aXMiLCJnZXRBeGlzTGVuZ3RoIiwiZ2V0U2lkZSIsImdldEFsaWdubWVudCIsImV2YWx1YXRlIiwiZ2V0UGFkZGluZ09iamVjdCIsInJlY3RUb0NsaWVudFJlY3QiLCJtaW4iLCJjbGFtcCIsInBsYWNlbWVudHMiLCJnZXRBbGlnbm1lbnRTaWRlcyIsImdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50IiwiZ2V0T3Bwb3NpdGVQbGFjZW1lbnQiLCJnZXRFeHBhbmRlZFBsYWNlbWVudHMiLCJnZXRPcHBvc2l0ZUF4aXNQbGFjZW1lbnRzIiwic2lkZXMiLCJtYXgiLCJnZXRPcHBvc2l0ZUF4aXMiLCJjb21wdXRlQ29vcmRzRnJvbVBsYWNlbWVudCIsIl9yZWYiLCJwbGFjZW1lbnQiLCJydGwiLCJyZWZlcmVuY2UiLCJmbG9hdGluZyIsInNpZGVBeGlzIiwiYWxpZ25tZW50QXhpcyIsImFsaWduTGVuZ3RoIiwic2lkZSIsImlzVmVydGljYWwiLCJjb21tb25YIiwieCIsIndpZHRoIiwiY29tbW9uWSIsInkiLCJoZWlnaHQiLCJjb21tb25BbGlnbiIsImNvb3JkcyIsImNvbXB1dGVQb3NpdGlvbiIsImNvbmZpZyIsInN0cmF0ZWd5IiwibWlkZGxld2FyZSIsInBsYXRmb3JtIiwidmFsaWRNaWRkbGV3YXJlIiwiZmlsdGVyIiwiQm9vbGVhbiIsImlzUlRMIiwicmVjdHMiLCJnZXRFbGVtZW50UmVjdHMiLCJzdGF0ZWZ1bFBsYWNlbWVudCIsIm1pZGRsZXdhcmVEYXRhIiwicmVzZXRDb3VudCIsImkiLCJsZW5ndGgiLCJuYW1lIiwiZm4iLCJuZXh0WCIsIm5leHRZIiwiZGF0YSIsInJlc2V0IiwiaW5pdGlhbFBsYWNlbWVudCIsImVsZW1lbnRzIiwiX29iamVjdFNwcmVhZCIsImRldGVjdE92ZXJmbG93Iiwic3RhdGUiLCJvcHRpb25zIiwiX2F3YWl0JHBsYXRmb3JtJGlzRWxlIiwiYm91bmRhcnkiLCJyb290Qm91bmRhcnkiLCJlbGVtZW50Q29udGV4dCIsImFsdEJvdW5kYXJ5IiwicGFkZGluZyIsInBhZGRpbmdPYmplY3QiLCJhbHRDb250ZXh0IiwiZWxlbWVudCIsImNsaXBwaW5nQ2xpZW50UmVjdCIsImdldENsaXBwaW5nUmVjdCIsImlzRWxlbWVudCIsImNvbnRleHRFbGVtZW50IiwiZ2V0RG9jdW1lbnRFbGVtZW50IiwicmVjdCIsIm9mZnNldFBhcmVudCIsImdldE9mZnNldFBhcmVudCIsIm9mZnNldFNjYWxlIiwiZ2V0U2NhbGUiLCJlbGVtZW50Q2xpZW50UmVjdCIsImNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0IiwidG9wIiwiYm90dG9tIiwibGVmdCIsInJpZ2h0IiwiYXJyb3ciLCJheGlzIiwiYXJyb3dEaW1lbnNpb25zIiwiZ2V0RGltZW5zaW9ucyIsImlzWUF4aXMiLCJtaW5Qcm9wIiwibWF4UHJvcCIsImNsaWVudFByb3AiLCJlbmREaWZmIiwic3RhcnREaWZmIiwiYXJyb3dPZmZzZXRQYXJlbnQiLCJjbGllbnRTaXplIiwiY2VudGVyVG9SZWZlcmVuY2UiLCJsYXJnZXN0UG9zc2libGVQYWRkaW5nIiwibWluUGFkZGluZyIsIm1heFBhZGRpbmciLCJtaW4kMSIsImNlbnRlciIsIm9mZnNldCIsInNob3VsZEFkZE9mZnNldCIsImFsaWdubWVudE9mZnNldCIsImNlbnRlck9mZnNldCIsImdldFBsYWNlbWVudExpc3QiLCJhbGlnbm1lbnQiLCJhdXRvQWxpZ25tZW50IiwiYWxsb3dlZFBsYWNlbWVudHMiLCJhbGxvd2VkUGxhY2VtZW50c1NvcnRlZEJ5QWxpZ25tZW50IiwiYXV0b1BsYWNlbWVudCIsIl9taWRkbGV3YXJlRGF0YSRhdXRvUCIsIl9taWRkbGV3YXJlRGF0YSRhdXRvUDIiLCJfcGxhY2VtZW50c1RoYXRGaXRPbkUiLCJfZXZhbHVhdGUiLCJjcm9zc0F4aXMiLCJkZXRlY3RPdmVyZmxvd09wdGlvbnMiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiLCJfZXhjbHVkZWQiLCJwbGFjZW1lbnRzJDEiLCJ1bmRlZmluZWQiLCJvdmVyZmxvdyIsImN1cnJlbnRJbmRleCIsImluZGV4IiwiY3VycmVudFBsYWNlbWVudCIsImFsaWdubWVudFNpZGVzIiwiY3VycmVudE92ZXJmbG93cyIsImFsbE92ZXJmbG93cyIsIm92ZXJmbG93cyIsIm5leHRQbGFjZW1lbnQiLCJwbGFjZW1lbnRzU29ydGVkQnlNb3N0U3BhY2UiLCJtYXAiLCJkIiwic2xpY2UiLCJyZWR1Y2UiLCJhY2MiLCJ2Iiwic29ydCIsImEiLCJiIiwicGxhY2VtZW50c1RoYXRGaXRPbkVhY2hTaWRlIiwiZXZlcnkiLCJyZXNldFBsYWNlbWVudCIsImZsaXAiLCJfbWlkZGxld2FyZURhdGEkYXJyb3ciLCJfbWlkZGxld2FyZURhdGEkZmxpcCIsIl9ldmFsdWF0ZTIiLCJtYWluQXhpcyIsImNoZWNrTWFpbkF4aXMiLCJjaGVja0Nyb3NzQXhpcyIsImZhbGxiYWNrUGxhY2VtZW50cyIsInNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyIsImZhbGxiYWNrU3RyYXRlZ3kiLCJmYWxsYmFja0F4aXNTaWRlRGlyZWN0aW9uIiwiZmxpcEFsaWdubWVudCIsIl9leGNsdWRlZDIiLCJpbml0aWFsU2lkZUF4aXMiLCJpc0Jhc2VQbGFjZW1lbnQiLCJoYXNGYWxsYmFja0F4aXNTaWRlRGlyZWN0aW9uIiwicHVzaCIsIm92ZXJmbG93c0RhdGEiLCJfbWlkZGxld2FyZURhdGEkZmxpcDIiLCJfb3ZlcmZsb3dzRGF0YSRmaWx0ZXIiLCJuZXh0SW5kZXgiLCJpZ25vcmVDcm9zc0F4aXNPdmVyZmxvdyIsIl9vdmVyZmxvd3NEYXRhJGZpbHRlcjIiLCJjdXJyZW50U2lkZUF4aXMiLCJnZXRTaWRlT2Zmc2V0cyIsImlzQW55U2lkZUZ1bGx5Q2xpcHBlZCIsInNvbWUiLCJoaWRlIiwiX2V2YWx1YXRlMyIsIl9leGNsdWRlZDMiLCJvZmZzZXRzIiwicmVmZXJlbmNlSGlkZGVuT2Zmc2V0cyIsInJlZmVyZW5jZUhpZGRlbiIsImVzY2FwZWRPZmZzZXRzIiwiZXNjYXBlZCIsImdldEJvdW5kaW5nUmVjdCIsIm1pblgiLCJtaW5ZIiwibWF4WCIsIm1heFkiLCJnZXRSZWN0c0J5TGluZSIsInNvcnRlZFJlY3RzIiwiZ3JvdXBzIiwicHJldlJlY3QiLCJpbmxpbmUiLCJuYXRpdmVDbGllbnRSZWN0cyIsIkFycmF5IiwiZnJvbSIsImdldENsaWVudFJlY3RzIiwiY2xpZW50UmVjdHMiLCJmYWxsYmFjayIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImZpbmQiLCJmaXJzdFJlY3QiLCJsYXN0UmVjdCIsImlzVG9wIiwiaXNMZWZ0U2lkZSIsIm1heFJpZ2h0IiwibWluTGVmdCIsIm1lYXN1cmVSZWN0cyIsInJlc2V0UmVjdHMiLCJvcmlnaW5TaWRlcyIsIlNldCIsImNvbnZlcnRWYWx1ZVRvQ29vcmRzIiwibWFpbkF4aXNNdWx0aSIsImhhcyIsImNyb3NzQXhpc011bHRpIiwicmF3VmFsdWUiLCJfbWlkZGxld2FyZURhdGEkb2Zmc2UiLCJkaWZmQ29vcmRzIiwic2hpZnQiLCJfZXZhbHVhdGU0IiwibGltaXRlciIsIl9leGNsdWRlZDQiLCJtYWluQXhpc0Nvb3JkIiwiY3Jvc3NBeGlzQ29vcmQiLCJtaW5TaWRlIiwibWF4U2lkZSIsImxpbWl0ZWRDb29yZHMiLCJlbmFibGVkIiwibGltaXRTaGlmdCIsInJhd09mZnNldCIsImNvbXB1dGVkT2Zmc2V0IiwibGVuIiwibGltaXRNaW4iLCJsaW1pdE1heCIsIl9taWRkbGV3YXJlRGF0YSRvZmZzZTIiLCJpc09yaWdpblNpZGUiLCJzaXplIiwiX3N0YXRlJG1pZGRsZXdhcmVEYXRhIiwiX3N0YXRlJG1pZGRsZXdhcmVEYXRhMiIsIl9ldmFsdWF0ZTUiLCJhcHBseSIsIl9leGNsdWRlZDUiLCJoZWlnaHRTaWRlIiwid2lkdGhTaWRlIiwibWF4aW11bUNsaXBwaW5nSGVpZ2h0IiwibWF4aW11bUNsaXBwaW5nV2lkdGgiLCJvdmVyZmxvd0F2YWlsYWJsZUhlaWdodCIsIm92ZXJmbG93QXZhaWxhYmxlV2lkdGgiLCJub1NoaWZ0IiwiYXZhaWxhYmxlSGVpZ2h0IiwiYXZhaWxhYmxlV2lkdGgiLCJ4TWluIiwieE1heCIsInlNaW4iLCJ5TWF4IiwibmV4dERpbWVuc2lvbnMiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/dom/node_modules/@floating-ui/core/dist/floating-ui.core.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrow: () => (/* binding */ arrow),\n/* harmony export */   autoPlacement: () => (/* binding */ autoPlacement),\n/* harmony export */   autoUpdate: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.autoUpdate),\n/* harmony export */   computePosition: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.computePosition),\n/* harmony export */   detectOverflow: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.detectOverflow),\n/* harmony export */   flip: () => (/* binding */ flip),\n/* harmony export */   getOverflowAncestors: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__.getOverflowAncestors),\n/* harmony export */   hide: () => (/* binding */ hide),\n/* harmony export */   inline: () => (/* binding */ inline),\n/* harmony export */   limitShift: () => (/* binding */ limitShift),\n/* harmony export */   offset: () => (/* binding */ offset),\n/* harmony export */   platform: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.platform),\n/* harmony export */   shift: () => (/* binding */ shift),\n/* harmony export */   size: () => (/* binding */ size),\n/* harmony export */   useFloating: () => (/* binding */ useFloating)\n/* harmony export */ });\n/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/dom */ \"(ssr)/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\");\n/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @floating-ui/dom */ \"(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-dom.js\");\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n\n\n\nvar isClient = typeof document !== 'undefined';\nvar noop = function noop() {};\nvar index = isClient ? react__WEBPACK_IMPORTED_MODULE_2__.useLayoutEffect : noop;\n\n// Fork of `fast-deep-equal` that only does the comparisons we need and compares\n// functions\nfunction deepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (typeof a !== typeof b) {\n    return false;\n  }\n  if (typeof a === 'function' && a.toString() === b.toString()) {\n    return true;\n  }\n  let length;\n  let i;\n  let keys;\n  if (a && b && typeof a === 'object') {\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length !== b.length) return false;\n      for (i = length; i-- !== 0;) {\n        if (!deepEqual(a[i], b[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) {\n      return false;\n    }\n    for (i = length; i-- !== 0;) {\n      if (!{}.hasOwnProperty.call(b, keys[i])) {\n        return false;\n      }\n    }\n    for (i = length; i-- !== 0;) {\n      const key = keys[i];\n      if (key === '_owner' && a.$$typeof) {\n        continue;\n      }\n      if (!deepEqual(a[key], b[key])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return a !== a && b !== b;\n}\nfunction getDPR(element) {\n  if (true) {\n    return 1;\n  }\n  const win = element.ownerDocument.defaultView || window;\n  return win.devicePixelRatio || 1;\n}\nfunction roundByDPR(element, value) {\n  const dpr = getDPR(element);\n  return Math.round(value * dpr) / dpr;\n}\nfunction useLatestRef(value) {\n  const ref = react__WEBPACK_IMPORTED_MODULE_2__.useRef(value);\n  index(() => {\n    ref.current = value;\n  });\n  return ref;\n}\n\n/**\n * Provides data to position a floating element.\n * @see https://floating-ui.com/docs/useFloating\n */\nfunction useFloating(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform,\n    elements: {\n      reference: externalReference,\n      floating: externalFloating\n    } = {},\n    transform = true,\n    whileElementsMounted,\n    open\n  } = options;\n  const [data, setData] = react__WEBPACK_IMPORTED_MODULE_2__.useState({\n    x: 0,\n    y: 0,\n    strategy,\n    placement,\n    middlewareData: {},\n    isPositioned: false\n  });\n  const [latestMiddleware, setLatestMiddleware] = react__WEBPACK_IMPORTED_MODULE_2__.useState(middleware);\n  if (!deepEqual(latestMiddleware, middleware)) {\n    setLatestMiddleware(middleware);\n  }\n  const [_reference, _setReference] = react__WEBPACK_IMPORTED_MODULE_2__.useState(null);\n  const [_floating, _setFloating] = react__WEBPACK_IMPORTED_MODULE_2__.useState(null);\n  const setReference = react__WEBPACK_IMPORTED_MODULE_2__.useCallback(node => {\n    if (node !== referenceRef.current) {\n      referenceRef.current = node;\n      _setReference(node);\n    }\n  }, []);\n  const setFloating = react__WEBPACK_IMPORTED_MODULE_2__.useCallback(node => {\n    if (node !== floatingRef.current) {\n      floatingRef.current = node;\n      _setFloating(node);\n    }\n  }, []);\n  const referenceEl = externalReference || _reference;\n  const floatingEl = externalFloating || _floating;\n  const referenceRef = react__WEBPACK_IMPORTED_MODULE_2__.useRef(null);\n  const floatingRef = react__WEBPACK_IMPORTED_MODULE_2__.useRef(null);\n  const dataRef = react__WEBPACK_IMPORTED_MODULE_2__.useRef(data);\n  const hasWhileElementsMounted = whileElementsMounted != null;\n  const whileElementsMountedRef = useLatestRef(whileElementsMounted);\n  const platformRef = useLatestRef(platform);\n  const openRef = useLatestRef(open);\n  const update = react__WEBPACK_IMPORTED_MODULE_2__.useCallback(() => {\n    if (!referenceRef.current || !floatingRef.current) {\n      return;\n    }\n    const config = {\n      placement,\n      strategy,\n      middleware: latestMiddleware\n    };\n    if (platformRef.current) {\n      config.platform = platformRef.current;\n    }\n    (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.computePosition)(referenceRef.current, floatingRef.current, config).then(data => {\n      const fullData = _objectSpread(_objectSpread({}, data), {}, {\n        // The floating element's position may be recomputed while it's closed\n        // but still mounted (such as when transitioning out). To ensure\n        // `isPositioned` will be `false` initially on the next open, avoid\n        // setting it to `true` when `open === false` (must be specified).\n        isPositioned: openRef.current !== false\n      });\n      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {\n        dataRef.current = fullData;\n        react_dom__WEBPACK_IMPORTED_MODULE_3__.flushSync(() => {\n          setData(fullData);\n        });\n      }\n    });\n  }, [latestMiddleware, placement, strategy, platformRef, openRef]);\n  index(() => {\n    if (open === false && dataRef.current.isPositioned) {\n      dataRef.current.isPositioned = false;\n      setData(data => _objectSpread(_objectSpread({}, data), {}, {\n        isPositioned: false\n      }));\n    }\n  }, [open]);\n  const isMountedRef = react__WEBPACK_IMPORTED_MODULE_2__.useRef(false);\n  index(() => {\n    isMountedRef.current = true;\n    return () => {\n      isMountedRef.current = false;\n    };\n  }, []);\n  index(() => {\n    if (referenceEl) referenceRef.current = referenceEl;\n    if (floatingEl) floatingRef.current = floatingEl;\n    if (referenceEl && floatingEl) {\n      if (whileElementsMountedRef.current) {\n        return whileElementsMountedRef.current(referenceEl, floatingEl, update);\n      }\n      update();\n    }\n  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);\n  const refs = react__WEBPACK_IMPORTED_MODULE_2__.useMemo(() => ({\n    reference: referenceRef,\n    floating: floatingRef,\n    setReference,\n    setFloating\n  }), [setReference, setFloating]);\n  const elements = react__WEBPACK_IMPORTED_MODULE_2__.useMemo(() => ({\n    reference: referenceEl,\n    floating: floatingEl\n  }), [referenceEl, floatingEl]);\n  const floatingStyles = react__WEBPACK_IMPORTED_MODULE_2__.useMemo(() => {\n    const initialStyles = {\n      position: strategy,\n      left: 0,\n      top: 0\n    };\n    if (!elements.floating) {\n      return initialStyles;\n    }\n    const x = roundByDPR(elements.floating, data.x);\n    const y = roundByDPR(elements.floating, data.y);\n    if (transform) {\n      return _objectSpread(_objectSpread({}, initialStyles), {}, {\n        transform: \"translate(\" + x + \"px, \" + y + \"px)\"\n      }, getDPR(elements.floating) >= 1.5 && {\n        willChange: 'transform'\n      });\n    }\n    return {\n      position: strategy,\n      left: x,\n      top: y\n    };\n  }, [strategy, transform, elements.floating, data.x, data.y]);\n  return react__WEBPACK_IMPORTED_MODULE_2__.useMemo(() => _objectSpread(_objectSpread({}, data), {}, {\n    update,\n    refs,\n    elements,\n    floatingStyles\n  }), [data, update, refs, elements, floatingStyles]);\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * This wraps the core `arrow` middleware to allow React refs as the element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow$1 = options => {\n  function isRef(value) {\n    return {}.hasOwnProperty.call(value, 'current');\n  }\n  return {\n    name: 'arrow',\n    options,\n    fn(state) {\n      const {\n        element,\n        padding\n      } = typeof options === 'function' ? options(state) : options;\n      if (element && isRef(element)) {\n        if (element.current != null) {\n          return (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.arrow)({\n            element: element.current,\n            padding\n          }).fn(state);\n        }\n        return {};\n      }\n      if (element) {\n        return (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.arrow)({\n          element,\n          padding\n        }).fn(state);\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = (options, deps) => _objectSpread(_objectSpread({}, (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.offset)(options)), {}, {\n  options: [options, deps]\n});\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = (options, deps) => _objectSpread(_objectSpread({}, (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.shift)(options)), {}, {\n  options: [options, deps]\n});\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = (options, deps) => _objectSpread(_objectSpread({}, (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.limitShift)(options)), {}, {\n  options: [options, deps]\n});\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = (options, deps) => _objectSpread(_objectSpread({}, (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.flip)(options)), {}, {\n  options: [options, deps]\n});\n\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = (options, deps) => _objectSpread(_objectSpread({}, (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.size)(options)), {}, {\n  options: [options, deps]\n});\n\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = (options, deps) => _objectSpread(_objectSpread({}, (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.autoPlacement)(options)), {}, {\n  options: [options, deps]\n});\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = (options, deps) => _objectSpread(_objectSpread({}, (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.hide)(options)), {}, {\n  options: [options, deps]\n});\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = (options, deps) => _objectSpread(_objectSpread({}, (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.inline)(options)), {}, {\n  options: [options, deps]\n});\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * This wraps the core `arrow` middleware to allow React refs as the element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = (options, deps) => _objectSpread(_objectSpread({}, arrow$1(options)), {}, {\n  options: [options, deps]\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3JlYWN0LWRvbS9kaXN0L2Zsb2F0aW5nLXVpLnJlYWN0LWRvbS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTZPO0FBQzlIO0FBQ2hGO0FBQ1M7QUFDRjtBQUV0QyxJQUFJMEIsUUFBUSxHQUFHLE9BQU9DLFFBQVEsS0FBSyxXQUFXO0FBRTlDLElBQUlDLElBQUksR0FBRyxTQUFTQSxJQUFJQSxDQUFBLEVBQUcsQ0FBQyxDQUFDO0FBQzdCLElBQUlDLEtBQUssR0FBR0gsUUFBUSxHQUFHRixrREFBZSxHQUFHSSxJQUFJOztBQUU3QztBQUNBO0FBQ0EsU0FBU0UsU0FBU0EsQ0FBQ0MsQ0FBQyxFQUFFQyxDQUFDLEVBQUU7RUFDdkIsSUFBSUQsQ0FBQyxLQUFLQyxDQUFDLEVBQUU7SUFDWCxPQUFPLElBQUk7RUFDYjtFQUNBLElBQUksT0FBT0QsQ0FBQyxLQUFLLE9BQU9DLENBQUMsRUFBRTtJQUN6QixPQUFPLEtBQUs7RUFDZDtFQUNBLElBQUksT0FBT0QsQ0FBQyxLQUFLLFVBQVUsSUFBSUEsQ0FBQyxDQUFDRSxRQUFRLENBQUMsQ0FBQyxLQUFLRCxDQUFDLENBQUNDLFFBQVEsQ0FBQyxDQUFDLEVBQUU7SUFDNUQsT0FBTyxJQUFJO0VBQ2I7RUFDQSxJQUFJQyxNQUFNO0VBQ1YsSUFBSUMsQ0FBQztFQUNMLElBQUlDLElBQUk7RUFDUixJQUFJTCxDQUFDLElBQUlDLENBQUMsSUFBSSxPQUFPRCxDQUFDLEtBQUssUUFBUSxFQUFFO0lBQ25DLElBQUlNLEtBQUssQ0FBQ0MsT0FBTyxDQUFDUCxDQUFDLENBQUMsRUFBRTtNQUNwQkcsTUFBTSxHQUFHSCxDQUFDLENBQUNHLE1BQU07TUFDakIsSUFBSUEsTUFBTSxLQUFLRixDQUFDLENBQUNFLE1BQU0sRUFBRSxPQUFPLEtBQUs7TUFDckMsS0FBS0MsQ0FBQyxHQUFHRCxNQUFNLEVBQUVDLENBQUMsRUFBRSxLQUFLLENB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QTtBQUNBO0FBQ0E7QUFDQSxNQUFNdkgsS0FBSyxHQUFHQSxDQUFDNEQsT0FBTyxFQUFFMkQsSUFBSSxLQUFBakIsYUFBQSxDQUFBQSxhQUFBLEtBQ3ZCVyxPQUFPLENBQUNyRCxPQUFPLENBQUM7RUFDbkJBLE9BQU8sRUFBRSxDQUFDQSxPQUFPLEVBQUUyRCxJQUFJO0FBQUMsRUFDeEIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcRXJmYW5cXERlc2t0b3BcXDLZvtix2YjamNmHINuMINmF2K3ZhdivINi52LHZgdin2YYg2LHYttin24zbjFxcRXJmYW5kZXZcXC5mcm9udGVuZFxcbm9kZV9tb2R1bGVzXFxAZmxvYXRpbmctdWlcXHJlYWN0LWRvbVxcZGlzdFxcZmxvYXRpbmctdWkucmVhY3QtZG9tLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjb21wdXRlUG9zaXRpb24sIGFycm93IGFzIGFycm93JDIsIGF1dG9QbGFjZW1lbnQgYXMgYXV0b1BsYWNlbWVudCQxLCBmbGlwIGFzIGZsaXAkMSwgaGlkZSBhcyBoaWRlJDEsIGlubGluZSBhcyBpbmxpbmUkMSwgbGltaXRTaGlmdCBhcyBsaW1pdFNoaWZ0JDEsIG9mZnNldCBhcyBvZmZzZXQkMSwgc2hpZnQgYXMgc2hpZnQkMSwgc2l6ZSBhcyBzaXplJDEgfSBmcm9tICdAZmxvYXRpbmctdWkvZG9tJztcbmV4cG9ydCB7IGF1dG9VcGRhdGUsIGNvbXB1dGVQb3NpdGlvbiwgZGV0ZWN0T3ZlcmZsb3csIGdldE92ZXJmbG93QW5jZXN0b3JzLCBwbGF0Zm9ybSB9IGZyb20gJ0BmbG9hdGluZy11aS9kb20nO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0ICogYXMgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcblxudmFyIGlzQ2xpZW50ID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcblxudmFyIG5vb3AgPSBmdW5jdGlvbiBub29wKCkge307XG52YXIgaW5kZXggPSBpc0NsaWVudCA/IHVzZUxheW91dEVmZmVjdCA6IG5vb3A7XG5cbi8vIEZvcmsgb2YgYGZhc3QtZGVlcC1lcXVhbGAgdGhhdCBvbmx5IGRvZXMgdGhlIGNvbXBhcmlzb25zIHdlIG5lZWQgYW5kIGNvbXBhcmVzXG4vLyBmdW5jdGlvbnNcbmZ1bmN0aW9uIGRlZXBFcXVhbChhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHR5cGVvZiBhICE9PSB0eXBlb2YgYikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIGEgPT09ICdmdW5jdGlvbicgJiYgYS50b1N0cmluZygpID09PSBiLnRvU3RyaW5nKCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBsZXQgbGVuZ3RoO1xuICBsZXQgaTtcbiAgbGV0IGtleXM7XG4gIGlmIChhICYmIGIgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgIGxlbmd0aCA9IGEubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOykge1xuICAgICAgICBpZiAoIWRlZXBFcXVhbChhW2ldLCBiW2ldKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KSB7XG4gICAgICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoYiwga2V5c1tpXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspIHtcbiAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICBpZiAoa2V5ID09PSAnX293bmVyJyAmJiBhLiQkdHlwZW9mKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFkZWVwRXF1YWwoYVtrZXldLCBiW2tleV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGEgIT09IGEgJiYgYiAhPT0gYjtcbn1cblxuZnVuY3Rpb24gZ2V0RFBSKGVsZW1lbnQpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgY29uc3Qgd2luID0gZWxlbWVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcbiAgcmV0dXJuIHdpbi5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG59XG5cbmZ1bmN0aW9uIHJvdW5kQnlEUFIoZWxlbWVudCwgdmFsdWUpIHtcbiAgY29uc3QgZHByID0gZ2V0RFBSKGVsZW1lbnQpO1xuICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIGRwcikgLyBkcHI7XG59XG5cbmZ1bmN0aW9uIHVzZUxhdGVzdFJlZih2YWx1ZSkge1xuICBjb25zdCByZWYgPSBSZWFjdC51c2VSZWYodmFsdWUpO1xuICBpbmRleCgoKSA9PiB7XG4gICAgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiByZWY7XG59XG5cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0byBwb3NpdGlvbiBhIGZsb2F0aW5nIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlRmxvYXRpbmdcbiAqL1xuZnVuY3Rpb24gdXNlRmxvYXRpbmcob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBwbGFjZW1lbnQgPSAnYm90dG9tJyxcbiAgICBzdHJhdGVneSA9ICdhYnNvbHV0ZScsXG4gICAgbWlkZGxld2FyZSA9IFtdLFxuICAgIHBsYXRmb3JtLFxuICAgIGVsZW1lbnRzOiB7XG4gICAgICByZWZlcmVuY2U6IGV4dGVybmFsUmVmZXJlbmNlLFxuICAgICAgZmxvYXRpbmc6IGV4dGVybmFsRmxvYXRpbmdcbiAgICB9ID0ge30sXG4gICAgdHJhbnNmb3JtID0gdHJ1ZSxcbiAgICB3aGlsZUVsZW1lbnRzTW91bnRlZCxcbiAgICBvcGVuXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBbZGF0YSwgc2V0RGF0YV0gPSBSZWFjdC51c2VTdGF0ZSh7XG4gICAgeDogMCxcbiAgICB5OiAwLFxuICAgIHN0cmF0ZWd5LFxuICAgIHBsYWNlbWVudCxcbiAgICBtaWRkbGV3YXJlRGF0YToge30sXG4gICAgaXNQb3NpdGlvbmVkOiBmYWxzZVxuICB9KTtcbiAgY29uc3QgW2xhdGVzdE1pZGRsZXdhcmUsIHNldExhdGVzdE1pZGRsZXdhcmVdID0gUmVhY3QudXNlU3RhdGUobWlkZGxld2FyZSk7XG4gIGlmICghZGVlcEVxdWFsKGxhdGVzdE1pZGRsZXdhcmUsIG1pZGRsZXdhcmUpKSB7XG4gICAgc2V0TGF0ZXN0TWlkZGxld2FyZShtaWRkbGV3YXJlKTtcbiAgfVxuICBjb25zdCBbX3JlZmVyZW5jZSwgX3NldFJlZmVyZW5jZV0gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgW19mbG9hdGluZywgX3NldEZsb2F0aW5nXSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBzZXRSZWZlcmVuY2UgPSBSZWFjdC51c2VDYWxsYmFjayhub2RlID0+IHtcbiAgICBpZiAobm9kZSAhPT0gcmVmZXJlbmNlUmVmLmN1cnJlbnQpIHtcbiAgICAgIHJlZmVyZW5jZVJlZi5jdXJyZW50ID0gbm9kZTtcbiAgICAgIF9zZXRSZWZlcmVuY2Uobm9kZSk7XG4gICAgfVxuICB9LCBbXSk7XG4gIGNvbnN0IHNldEZsb2F0aW5nID0gUmVhY3QudXNlQ2FsbGJhY2sobm9kZSA9PiB7XG4gICAgaWYgKG5vZGUgIT09IGZsb2F0aW5nUmVmLmN1cnJlbnQpIHtcbiAgICAgIGZsb2F0aW5nUmVmLmN1cnJlbnQgPSBub2RlO1xuICAgICAgX3NldEZsb2F0aW5nKG5vZGUpO1xuICAgIH1cbiAgfSwgW10pO1xuICBjb25zdCByZWZlcmVuY2VFbCA9IGV4dGVybmFsUmVmZXJlbmNlIHx8IF9yZWZlcmVuY2U7XG4gIGNvbnN0IGZsb2F0aW5nRWwgPSBleHRlcm5hbEZsb2F0aW5nIHx8IF9mbG9hdGluZztcbiAgY29uc3QgcmVmZXJlbmNlUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBmbG9hdGluZ1JlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgZGF0YVJlZiA9IFJlYWN0LnVzZVJlZihkYXRhKTtcbiAgY29uc3QgaGFzV2hpbGVFbGVtZW50c01vdW50ZWQgPSB3aGlsZUVsZW1lbnRzTW91bnRlZCAhPSBudWxsO1xuICBjb25zdCB3aGlsZUVsZW1lbnRzTW91bnRlZFJlZiA9IHVzZUxhdGVzdFJlZih3aGlsZUVsZW1lbnRzTW91bnRlZCk7XG4gIGNvbnN0IHBsYXRmb3JtUmVmID0gdXNlTGF0ZXN0UmVmKHBsYXRmb3JtKTtcbiAgY29uc3Qgb3BlblJlZiA9IHVzZUxhdGVzdFJlZihvcGVuKTtcbiAgY29uc3QgdXBkYXRlID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmICghcmVmZXJlbmNlUmVmLmN1cnJlbnQgfHwgIWZsb2F0aW5nUmVmLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgcGxhY2VtZW50LFxuICAgICAgc3RyYXRlZ3ksXG4gICAgICBtaWRkbGV3YXJlOiBsYXRlc3RNaWRkbGV3YXJlXG4gICAgfTtcbiAgICBpZiAocGxhdGZvcm1SZWYuY3VycmVudCkge1xuICAgICAgY29uZmlnLnBsYXRmb3JtID0gcGxhdGZvcm1SZWYuY3VycmVudDtcbiAgICB9XG4gICAgY29tcHV0ZVBvc2l0aW9uKHJlZmVyZW5jZVJlZi5jdXJyZW50LCBmbG9hdGluZ1JlZi5jdXJyZW50LCBjb25maWcpLnRoZW4oZGF0YSA9PiB7XG4gICAgICBjb25zdCBmdWxsRGF0YSA9IHtcbiAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgLy8gVGhlIGZsb2F0aW5nIGVsZW1lbnQncyBwb3NpdGlvbiBtYXkgYmUgcmVjb21wdXRlZCB3aGlsZSBpdCdzIGNsb3NlZFxuICAgICAgICAvLyBidXQgc3RpbGwgbW91bnRlZCAoc3VjaCBhcyB3aGVuIHRyYW5zaXRpb25pbmcgb3V0KS4gVG8gZW5zdXJlXG4gICAgICAgIC8vIGBpc1Bvc2l0aW9uZWRgIHdpbGwgYmUgYGZhbHNlYCBpbml0aWFsbHkgb24gdGhlIG5leHQgb3BlbiwgYXZvaWRcbiAgICAgICAgLy8gc2V0dGluZyBpdCB0byBgdHJ1ZWAgd2hlbiBgb3BlbiA9PT0gZmFsc2VgIChtdXN0IGJlIHNwZWNpZmllZCkuXG4gICAgICAgIGlzUG9zaXRpb25lZDogb3BlblJlZi5jdXJyZW50ICE9PSBmYWxzZVxuICAgICAgfTtcbiAgICAgIGlmIChpc01vdW50ZWRSZWYuY3VycmVudCAmJiAhZGVlcEVxdWFsKGRhdGFSZWYuY3VycmVudCwgZnVsbERhdGEpKSB7XG4gICAgICAgIGRhdGFSZWYuY3VycmVudCA9IGZ1bGxEYXRhO1xuICAgICAgICBSZWFjdERPTS5mbHVzaFN5bmMoKCkgPT4ge1xuICAgICAgICAgIHNldERhdGEoZnVsbERhdGEpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgW2xhdGVzdE1pZGRsZXdhcmUsIHBsYWNlbWVudCwgc3RyYXRlZ3ksIHBsYXRmb3JtUmVmLCBvcGVuUmVmXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAob3BlbiA9PT0gZmFsc2UgJiYgZGF0YVJlZi5jdXJyZW50LmlzUG9zaXRpb25lZCkge1xuICAgICAgZGF0YVJlZi5jdXJyZW50LmlzUG9zaXRpb25lZCA9IGZhbHNlO1xuICAgICAgc2V0RGF0YShkYXRhID0+ICh7XG4gICAgICAgIC4uLmRhdGEsXG4gICAgICAgIGlzUG9zaXRpb25lZDogZmFsc2VcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0sIFtvcGVuXSk7XG4gIGNvbnN0IGlzTW91bnRlZFJlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpc01vdW50ZWRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlzTW91bnRlZFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgfTtcbiAgfSwgW10pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKHJlZmVyZW5jZUVsKSByZWZlcmVuY2VSZWYuY3VycmVudCA9IHJlZmVyZW5jZUVsO1xuICAgIGlmIChmbG9hdGluZ0VsKSBmbG9hdGluZ1JlZi5jdXJyZW50ID0gZmxvYXRpbmdFbDtcbiAgICBpZiAocmVmZXJlbmNlRWwgJiYgZmxvYXRpbmdFbCkge1xuICAgICAgaWYgKHdoaWxlRWxlbWVudHNNb3VudGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuIHdoaWxlRWxlbWVudHNNb3VudGVkUmVmLmN1cnJlbnQocmVmZXJlbmNlRWwsIGZsb2F0aW5nRWwsIHVwZGF0ZSk7XG4gICAgICB9XG4gICAgICB1cGRhdGUoKTtcbiAgICB9XG4gIH0sIFtyZWZlcmVuY2VFbCwgZmxvYXRpbmdFbCwgdXBkYXRlLCB3aGlsZUVsZW1lbnRzTW91bnRlZFJlZiwgaGFzV2hpbGVFbGVtZW50c01vdW50ZWRdKTtcbiAgY29uc3QgcmVmcyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICByZWZlcmVuY2U6IHJlZmVyZW5jZVJlZixcbiAgICBmbG9hdGluZzogZmxvYXRpbmdSZWYsXG4gICAgc2V0UmVmZXJlbmNlLFxuICAgIHNldEZsb2F0aW5nXG4gIH0pLCBbc2V0UmVmZXJlbmNlLCBzZXRGbG9hdGluZ10pO1xuICBjb25zdCBlbGVtZW50cyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICByZWZlcmVuY2U6IHJlZmVyZW5jZUVsLFxuICAgIGZsb2F0aW5nOiBmbG9hdGluZ0VsXG4gIH0pLCBbcmVmZXJlbmNlRWwsIGZsb2F0aW5nRWxdKTtcbiAgY29uc3QgZmxvYXRpbmdTdHlsZXMgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCBpbml0aWFsU3R5bGVzID0ge1xuICAgICAgcG9zaXRpb246IHN0cmF0ZWd5LFxuICAgICAgbGVmdDogMCxcbiAgICAgIHRvcDogMFxuICAgIH07XG4gICAgaWYgKCFlbGVtZW50cy5mbG9hdGluZykge1xuICAgICAgcmV0dXJuIGluaXRpYWxTdHlsZXM7XG4gICAgfVxuICAgIGNvbnN0IHggPSByb3VuZEJ5RFBSKGVsZW1lbnRzLmZsb2F0aW5nLCBkYXRhLngpO1xuICAgIGNvbnN0IHkgPSByb3VuZEJ5RFBSKGVsZW1lbnRzLmZsb2F0aW5nLCBkYXRhLnkpO1xuICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmluaXRpYWxTdHlsZXMsXG4gICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoXCIgKyB4ICsgXCJweCwgXCIgKyB5ICsgXCJweClcIixcbiAgICAgICAgLi4uKGdldERQUihlbGVtZW50cy5mbG9hdGluZykgPj0gMS41ICYmIHtcbiAgICAgICAgICB3aWxsQ2hhbmdlOiAndHJhbnNmb3JtJ1xuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvc2l0aW9uOiBzdHJhdGVneSxcbiAgICAgIGxlZnQ6IHgsXG4gICAgICB0b3A6IHlcbiAgICB9O1xuICB9LCBbc3RyYXRlZ3ksIHRyYW5zZm9ybSwgZWxlbWVudHMuZmxvYXRpbmcsIGRhdGEueCwgZGF0YS55XSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgLi4uZGF0YSxcbiAgICB1cGRhdGUsXG4gICAgcmVmcyxcbiAgICBlbGVtZW50cyxcbiAgICBmbG9hdGluZ1N0eWxlc1xuICB9KSwgW2RhdGEsIHVwZGF0ZSwgcmVmcywgZWxlbWVudHMsIGZsb2F0aW5nU3R5bGVzXSk7XG59XG5cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0byBwb3NpdGlvbiBhbiBpbm5lciBlbGVtZW50IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IHNvIHRoYXQgaXRcbiAqIGFwcGVhcnMgY2VudGVyZWQgdG8gdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogVGhpcyB3cmFwcyB0aGUgY29yZSBgYXJyb3dgIG1pZGRsZXdhcmUgdG8gYWxsb3cgUmVhY3QgcmVmcyBhcyB0aGUgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9hcnJvd1xuICovXG5jb25zdCBhcnJvdyQxID0gb3B0aW9ucyA9PiB7XG4gIGZ1bmN0aW9uIGlzUmVmKHZhbHVlKSB7XG4gICAgcmV0dXJuIHt9Lmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjdXJyZW50Jyk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnYXJyb3cnLFxuICAgIG9wdGlvbnMsXG4gICAgZm4oc3RhdGUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZWxlbWVudCxcbiAgICAgICAgcGFkZGluZ1xuICAgICAgfSA9IHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucyhzdGF0ZSkgOiBvcHRpb25zO1xuICAgICAgaWYgKGVsZW1lbnQgJiYgaXNSZWYoZWxlbWVudCkpIHtcbiAgICAgICAgaWYgKGVsZW1lbnQuY3VycmVudCAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGFycm93JDIoe1xuICAgICAgICAgICAgZWxlbWVudDogZWxlbWVudC5jdXJyZW50LFxuICAgICAgICAgICAgcGFkZGluZ1xuICAgICAgICAgIH0pLmZuKHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gYXJyb3ckMih7XG4gICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICBwYWRkaW5nXG4gICAgICAgIH0pLmZuKHN0YXRlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIE1vZGlmaWVzIHRoZSBwbGFjZW1lbnQgYnkgdHJhbnNsYXRpbmcgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYWxvbmcgdGhlXG4gKiBzcGVjaWZpZWQgYXhlcy5cbiAqIEEgbnVtYmVyIChzaG9ydGhhbmQgZm9yIGBtYWluQXhpc2Agb3IgZGlzdGFuY2UpLCBvciBhbiBheGVzIGNvbmZpZ3VyYXRpb25cbiAqIG9iamVjdCBtYXkgYmUgcGFzc2VkLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL29mZnNldFxuICovXG5jb25zdCBvZmZzZXQgPSAob3B0aW9ucywgZGVwcykgPT4gKHtcbiAgLi4ub2Zmc2V0JDEob3B0aW9ucyksXG4gIG9wdGlvbnM6IFtvcHRpb25zLCBkZXBzXVxufSk7XG5cbi8qKlxuICogT3B0aW1pemVzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IGJ5IHNoaWZ0aW5nIGl0IGluIG9yZGVyIHRvXG4gKiBrZWVwIGl0IGluIHZpZXcgd2hlbiBpdCB3aWxsIG92ZXJmbG93IHRoZSBjbGlwcGluZyBib3VuZGFyeS5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9zaGlmdFxuICovXG5jb25zdCBzaGlmdCA9IChvcHRpb25zLCBkZXBzKSA9PiAoe1xuICAuLi5zaGlmdCQxKG9wdGlvbnMpLFxuICBvcHRpb25zOiBbb3B0aW9ucywgZGVwc11cbn0pO1xuXG4vKipcbiAqIEJ1aWx0LWluIGBsaW1pdGVyYCB0aGF0IHdpbGwgc3RvcCBgc2hpZnQoKWAgYXQgYSBjZXJ0YWluIHBvaW50LlxuICovXG5jb25zdCBsaW1pdFNoaWZ0ID0gKG9wdGlvbnMsIGRlcHMpID0+ICh7XG4gIC4uLmxpbWl0U2hpZnQkMShvcHRpb25zKSxcbiAgb3B0aW9uczogW29wdGlvbnMsIGRlcHNdXG59KTtcblxuLyoqXG4gKiBPcHRpbWl6ZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYnkgZmxpcHBpbmcgdGhlIGBwbGFjZW1lbnRgXG4gKiBpbiBvcmRlciB0byBrZWVwIGl0IGluIHZpZXcgd2hlbiB0aGUgcHJlZmVycmVkIHBsYWNlbWVudChzKSB3aWxsIG92ZXJmbG93IHRoZVxuICogY2xpcHBpbmcgYm91bmRhcnkuIEFsdGVybmF0aXZlIHRvIGBhdXRvUGxhY2VtZW50YC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9mbGlwXG4gKi9cbmNvbnN0IGZsaXAgPSAob3B0aW9ucywgZGVwcykgPT4gKHtcbiAgLi4uZmxpcCQxKG9wdGlvbnMpLFxuICBvcHRpb25zOiBbb3B0aW9ucywgZGVwc11cbn0pO1xuXG4vKipcbiAqIFByb3ZpZGVzIGRhdGEgdGhhdCBhbGxvd3MgeW91IHRvIGNoYW5nZSB0aGUgc2l6ZSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCDigJRcbiAqIGZvciBpbnN0YW5jZSwgcHJldmVudCBpdCBmcm9tIG92ZXJmbG93aW5nIHRoZSBjbGlwcGluZyBib3VuZGFyeSBvciBtYXRjaCB0aGVcbiAqIHdpZHRoIG9mIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9zaXplXG4gKi9cbmNvbnN0IHNpemUgPSAob3B0aW9ucywgZGVwcykgPT4gKHtcbiAgLi4uc2l6ZSQxKG9wdGlvbnMpLFxuICBvcHRpb25zOiBbb3B0aW9ucywgZGVwc11cbn0pO1xuXG4vKipcbiAqIE9wdGltaXplcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBieSBjaG9vc2luZyB0aGUgcGxhY2VtZW50XG4gKiB0aGF0IGhhcyB0aGUgbW9zdCBzcGFjZSBhdmFpbGFibGUgYXV0b21hdGljYWxseSwgd2l0aG91dCBuZWVkaW5nIHRvIHNwZWNpZnkgYVxuICogcHJlZmVycmVkIHBsYWNlbWVudC4gQWx0ZXJuYXRpdmUgdG8gYGZsaXBgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2F1dG9QbGFjZW1lbnRcbiAqL1xuY29uc3QgYXV0b1BsYWNlbWVudCA9IChvcHRpb25zLCBkZXBzKSA9PiAoe1xuICAuLi5hdXRvUGxhY2VtZW50JDEob3B0aW9ucyksXG4gIG9wdGlvbnM6IFtvcHRpb25zLCBkZXBzXVxufSk7XG5cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0byBoaWRlIHRoZSBmbG9hdGluZyBlbGVtZW50IGluIGFwcGxpY2FibGUgc2l0dWF0aW9ucywgc3VjaCBhc1xuICogd2hlbiBpdCBpcyBub3QgaW4gdGhlIHNhbWUgY2xpcHBpbmcgY29udGV4dCBhcyB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvaGlkZVxuICovXG5jb25zdCBoaWRlID0gKG9wdGlvbnMsIGRlcHMpID0+ICh7XG4gIC4uLmhpZGUkMShvcHRpb25zKSxcbiAgb3B0aW9uczogW29wdGlvbnMsIGRlcHNdXG59KTtcblxuLyoqXG4gKiBQcm92aWRlcyBpbXByb3ZlZCBwb3NpdGlvbmluZyBmb3IgaW5saW5lIHJlZmVyZW5jZSBlbGVtZW50cyB0aGF0IGNhbiBzcGFuXG4gKiBvdmVyIG11bHRpcGxlIGxpbmVzLCBzdWNoIGFzIGh5cGVybGlua3Mgb3IgcmFuZ2Ugc2VsZWN0aW9ucy5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9pbmxpbmVcbiAqL1xuY29uc3QgaW5saW5lID0gKG9wdGlvbnMsIGRlcHMpID0+ICh7XG4gIC4uLmlubGluZSQxKG9wdGlvbnMpLFxuICBvcHRpb25zOiBbb3B0aW9ucywgZGVwc11cbn0pO1xuXG4vKipcbiAqIFByb3ZpZGVzIGRhdGEgdG8gcG9zaXRpb24gYW4gaW5uZXIgZWxlbWVudCBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBzbyB0aGF0IGl0XG4gKiBhcHBlYXJzIGNlbnRlcmVkIHRvIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIFRoaXMgd3JhcHMgdGhlIGNvcmUgYGFycm93YCBtaWRkbGV3YXJlIHRvIGFsbG93IFJlYWN0IHJlZnMgYXMgdGhlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvYXJyb3dcbiAqL1xuY29uc3QgYXJyb3cgPSAob3B0aW9ucywgZGVwcykgPT4gKHtcbiAgLi4uYXJyb3ckMShvcHRpb25zKSxcbiAgb3B0aW9uczogW29wdGlvbnMsIGRlcHNdXG59KTtcblxuZXhwb3J0IHsgYXJyb3csIGF1dG9QbGFjZW1lbnQsIGZsaXAsIGhpZGUsIGlubGluZSwgbGltaXRTaGlmdCwgb2Zmc2V0LCBzaGlmdCwgc2l6ZSwgdXNlRmxvYXRpbmcgfTtcbiJdLCJuYW1lcyI6WyJjb21wdXRlUG9zaXRpb24iLCJhcnJvdyIsImFycm93JDIiLCJhdXRvUGxhY2VtZW50IiwiYXV0b1BsYWNlbWVudCQxIiwiZmxpcCIsImZsaXAkMSIsImhpZGUiLCJoaWRlJDEiLCJpbmxpbmUiLCJpbmxpbmUkMSIsImxpbWl0U2hpZnQiLCJsaW1pdFNoaWZ0JDEiLCJvZmZzZXQiLCJvZmZzZXQkMSIsInNoaWZ0Iiwic2hpZnQkMSIsInNpemUiLCJzaXplJDEiLCJhdXRvVXBkYXRlIiwiZGV0ZWN0T3ZlcmZsb3ciLCJnZXRPdmVyZmxvd0FuY2VzdG9ycyIsInBsYXRmb3JtIiwiUmVhY3QiLCJ1c2VMYXlvdXRFZmZlY3QiLCJSZWFjdERPTSIsImlzQ2xpZW50IiwiZG9jdW1lbnQiLCJub29wIiwiaW5kZXgiLCJkZWVwRXF1YWwiLCJhIiwiYiIsInRvU3RyaW5nIiwibGVuZ3RoIiwiaSIsImtleXMiLCJBcnJheSIsImlzQXJyYXkiLCJPYmplY3QiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJrZXkiLCIkJHR5cGVvZiIsImdldERQUiIsImVsZW1lbnQiLCJ3aW4iLCJvd25lckRvY3VtZW50IiwiZGVmYXVsdFZpZXciLCJ3aW5kb3ciLCJkZXZpY2VQaXhlbFJhdGlvIiwicm91bmRCeURQUiIsInZhbHVlIiwiZHByIiwiTWF0aCIsInJvdW5kIiwidXNlTGF0ZXN0UmVmIiwicmVmIiwidXNlUmVmIiwiY3VycmVudCIsInVzZUZsb2F0aW5nIiwib3B0aW9ucyIsInBsYWNlbWVudCIsInN0cmF0ZWd5IiwibWlkZGxld2FyZSIsImVsZW1lbnRzIiwicmVmZXJlbmNlIiwiZXh0ZXJuYWxSZWZlcmVuY2UiLCJmbG9hdGluZyIsImV4dGVybmFsRmxvYXRpbmciLCJ0cmFuc2Zvcm0iLCJ3aGlsZUVsZW1lbnRzTW91bnRlZCIsIm9wZW4iLCJkYXRhIiwic2V0RGF0YSIsInVzZVN0YXRlIiwieCIsInkiLCJtaWRkbGV3YXJlRGF0YSIsImlzUG9zaXRpb25lZCIsImxhdGVzdE1pZGRsZXdhcmUiLCJzZXRMYXRlc3RNaWRkbGV3YXJlIiwiX3JlZmVyZW5jZSIsIl9zZXRSZWZlcmVuY2UiLCJfZmxvYXRpbmciLCJfc2V0RmxvYXRpbmciLCJzZXRSZWZlcmVuY2UiLCJ1c2VDYWxsYmFjayIsIm5vZGUiLCJyZWZlcmVuY2VSZWYiLCJzZXRGbG9hdGluZyIsImZsb2F0aW5nUmVmIiwicmVmZXJlbmNlRWwiLCJmbG9hdGluZ0VsIiwiZGF0YVJlZiIsImhhc1doaWxlRWxlbWVudHNNb3VudGVkIiwid2hpbGVFbGVtZW50c01vdW50ZWRSZWYiLCJwbGF0Zm9ybVJlZiIsIm9wZW5SZWYiLCJ1cGRhdGUiLCJjb25maWciLCJ0aGVuIiwiZnVsbERhdGEiLCJfb2JqZWN0U3ByZWFkIiwiaXNNb3VudGVkUmVmIiwiZmx1c2hTeW5jIiwicmVmcyIsInVzZU1lbW8iLCJmbG9hdGluZ1N0eWxlcyIsImluaXRpYWxTdHlsZXMiLCJwb3NpdGlvbiIsImxlZnQiLCJ0b3AiLCJ3aWxsQ2hhbmdlIiwiYXJyb3ckMSIsImlzUmVmIiwibmFtZSIsImZuIiwic3RhdGUiLCJwYWRkaW5nIiwiZGVwcyJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@floating-ui/react/dist/floating-ui.react.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@floating-ui/react/dist/floating-ui.react.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var react__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Composite: () => (/* binding */ Composite),\n/* harmony export */   CompositeItem: () => (/* binding */ CompositeItem),\n/* harmony export */   FloatingArrow: () => (/* binding */ FloatingArrow),\n/* harmony export */   FloatingDelayGroup: () => (/* binding */ FloatingDelayGroup),\n/* harmony export */   FloatingFocusManager: () => (/* binding */ FloatingFocusManager),\n/* harmony export */   FloatingList: () => (/* binding */ FloatingList),\n/* harmony export */   FloatingNode: () => (/* binding */ FloatingNode),\n/* harmony export */   FloatingOverlay: () => (/* binding */ FloatingOverlay),\n/* harmony export */   FloatingPortal: () => (/* binding */ FloatingPortal),\n/* harmony export */   FloatingTree: () => (/* binding */ FloatingTree),\n/* harmony export */   arrow: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_1__.arrow),\n/* harmony export */   autoPlacement: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_1__.autoPlacement),\n/* harmony export */   autoUpdate: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.autoUpdate),\n/* harmony export */   computePosition: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.computePosition),\n/* harmony export */   detectOverflow: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.detectOverflow),\n/* harmony export */   flip: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_1__.flip),\n/* harmony export */   getOverflowAncestors: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.getOverflowAncestors),\n/* harmony export */   hide: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_1__.hide),\n/* harmony export */   inline: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_1__.inline),\n/* harmony export */   inner: () => (/* binding */ inner),\n/* harmony export */   limitShift: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_1__.limitShift),\n/* harmony export */   offset: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_1__.offset),\n/* harmony export */   platform: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.platform),\n/* harmony export */   safePolygon: () => (/* binding */ safePolygon),\n/* harmony export */   shift: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_1__.shift),\n/* harmony export */   size: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_1__.size),\n/* harmony export */   useClick: () => (/* binding */ useClick),\n/* harmony export */   useClientPoint: () => (/* binding */ useClientPoint),\n/* harmony export */   useDelayGroup: () => (/* binding */ useDelayGroup),\n/* harmony export */   useDelayGroupContext: () => (/* binding */ useDelayGroupContext),\n/* harmony export */   useDismiss: () => (/* binding */ useDismiss),\n/* harmony export */   useFloating: () => (/* binding */ useFloating),\n/* harmony export */   useFloatingNodeId: () => (/* binding */ useFloatingNodeId),\n/* harmony export */   useFloatingParentNodeId: () => (/* binding */ useFloatingParentNodeId),\n/* harmony export */   useFloatingPortalNode: () => (/* binding */ useFloatingPortalNode),\n/* harmony export */   useFloatingTree: () => (/* binding */ useFloatingTree),\n/* harmony export */   useFocus: () => (/* binding */ useFocus),\n/* harmony export */   useHover: () => (/* binding */ useHover),\n/* harmony export */   useId: () => (/* binding */ useId),\n/* harmony export */   useInnerOffset: () => (/* binding */ useInnerOffset),\n/* harmony export */   useInteractions: () => (/* binding */ useInteractions),\n/* harmony export */   useListItem: () => (/* binding */ useListItem),\n/* harmony export */   useListNavigation: () => (/* binding */ useListNavigation),\n/* harmony export */   useMergeRefs: () => (/* binding */ useMergeRefs),\n/* harmony export */   useRole: () => (/* binding */ useRole),\n/* harmony export */   useTransitionStatus: () => (/* binding */ useTransitionStatus),\n/* harmony export */   useTransitionStyles: () => (/* binding */ useTransitionStyles),\n/* harmony export */   useTypeahead: () => (/* binding */ useTypeahead)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @floating-ui/react/utils */ \"(ssr)/./node_modules/@floating-ui/react/dist/floating-ui.react.utils.mjs\");\n/* harmony import */ var _floating_ui_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @floating-ui/utils */ \"(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs\");\n/* harmony import */ var _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @floating-ui/react-dom */ \"(ssr)/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\");\n/* harmony import */ var _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @floating-ui/utils/dom */ \"(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs\");\n/* harmony import */ var _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @floating-ui/react-dom */ \"(ssr)/./node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs\");\n/* harmony import */ var tabbable__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! tabbable */ \"(ssr)/./node_modules/tabbable/dist/index.esm.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-dom.js\");\nconst _excluded = [\"render\", \"orientation\", \"loop\", \"cols\", \"disabledIndices\", \"activeIndex\", \"onNavigate\", \"itemSizes\", \"dense\"],\n  _excluded2 = [\"render\"],\n  _excluded3 = [\"transform\"],\n  _excluded4 = [\"context\", \"width\", \"height\", \"tipRadius\", \"strokeWidth\", \"staticOffset\", \"stroke\", \"d\", \"style\"],\n  _excluded5 = [\"lockScroll\"],\n  _excluded6 = [\"listRef\", \"overflowRef\", \"onFallbackChange\", \"offset\", \"index\", \"minItemsVisible\", \"referenceOverflowThreshold\", \"scrollRef\"];\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }\nfunction _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }\n\n\n\n\n\n\n\n\n\n\n/**\n * Merges an array of refs into a single memoized callback ref or `null`.\n * @see https://floating-ui.com/docs/react-utils#usemergerefs\n */\nfunction useMergeRefs(refs) {\n  // biome-ignore lint/correctness/useExhaustiveDependencies: intentional\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    if (refs.every(ref => ref == null)) {\n      return null;\n    }\n    return value => {\n      refs.forEach(ref => {\n        if (typeof ref === 'function') {\n          ref(value);\n        } else if (ref != null) {\n          ref.current = value;\n        }\n      });\n    };\n  }, refs);\n}\n\n// `toString()` prevents bundlers from trying to `import { useInsertionEffect } from 'react'`\nconst useInsertionEffect = /*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_0__, 2)))[/*#__PURE__*/'useInsertionEffect'.toString()];\nconst useSafeInsertionEffect = useInsertionEffect || (fn => fn());\nfunction useEffectEvent(callback) {\n  const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(() => {\n    if (true) {\n      throw new Error('Cannot call an event handler while rendering.');\n    }\n  });\n  useSafeInsertionEffect(() => {\n    ref.current = callback;\n  });\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return ref.current == null ? void 0 : ref.current(...args);\n  }, []);\n}\nconst ARROW_UP = 'ArrowUp';\nconst ARROW_DOWN = 'ArrowDown';\nconst ARROW_LEFT = 'ArrowLeft';\nconst ARROW_RIGHT = 'ArrowRight';\nfunction isDifferentRow(index, cols, prevRow) {\n  return Math.floor(index / cols) !== prevRow;\n}\nfunction isIndexOutOfBounds(listRef, index) {\n  return index < 0 || index >= listRef.current.length;\n}\nfunction getMinIndex(listRef, disabledIndices) {\n  return findNonDisabledIndex(listRef, {\n    disabledIndices\n  });\n}\nfunction getMaxIndex(listRef, disabledIndices) {\n  return findNonDisabledIndex(listRef, {\n    decrement: true,\n    startingIndex: listRef.current.length,\n    disabledIndices\n  });\n}\nfunction findNonDisabledIndex(listRef, _temp) {\n  let {\n    startingIndex = -1,\n    decrement = false,\n    disabledIndices,\n    amount = 1\n  } = _temp === void 0 ? {} : _temp;\n  const list = listRef.current;\n  const isDisabledIndex = disabledIndices ? index => disabledIndices.includes(index) : index => {\n    const element = list[index];\n    return element == null || element.hasAttribute('disabled') || element.getAttribute('aria-disabled') === 'true';\n  };\n  let index = startingIndex;\n  do {\n    index += decrement ? -amount : amount;\n  } while (index >= 0 && index <= list.length - 1 && isDisabledIndex(index));\n  return index;\n}\nfunction getGridNavigatedIndex(elementsRef, _ref) {\n  let {\n    event,\n    orientation,\n    loop,\n    cols,\n    disabledIndices,\n    minIndex,\n    maxIndex,\n    prevIndex,\n    stopEvent: stop = false\n  } = _ref;\n  let nextIndex = prevIndex;\n  if (event.key === ARROW_UP) {\n    stop && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n    if (prevIndex === -1) {\n      nextIndex = maxIndex;\n    } else {\n      nextIndex = findNonDisabledIndex(elementsRef, {\n        startingIndex: nextIndex,\n        amount: cols,\n        decrement: true,\n        disabledIndices\n      });\n      if (loop && (prevIndex - cols < minIndex || nextIndex < 0)) {\n        const col = prevIndex % cols;\n        const maxCol = maxIndex % cols;\n        const offset = maxIndex - (maxCol - col);\n        if (maxCol === col) {\n          nextIndex = maxIndex;\n        } else {\n          nextIndex = maxCol > col ? offset : offset - cols;\n        }\n      }\n    }\n    if (isIndexOutOfBounds(elementsRef, nextIndex)) {\n      nextIndex = prevIndex;\n    }\n  }\n  if (event.key === ARROW_DOWN) {\n    stop && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n    if (prevIndex === -1) {\n      nextIndex = minIndex;\n    } else {\n      nextIndex = findNonDisabledIndex(elementsRef, {\n        startingIndex: prevIndex,\n        amount: cols,\n        disabledIndices\n      });\n      if (loop && prevIndex + cols > maxIndex) {\n        nextIndex = findNonDisabledIndex(elementsRef, {\n          startingIndex: prevIndex % cols - cols,\n          amount: cols,\n          disabledIndices\n        });\n      }\n    }\n    if (isIndexOutOfBounds(elementsRef, nextIndex)) {\n      nextIndex = prevIndex;\n    }\n  }\n\n  // Remains on the same row/column.\n  if (orientation === 'both') {\n    const prevRow = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_6__.floor)(prevIndex / cols);\n    if (event.key === ARROW_RIGHT) {\n      stop && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n      if (prevIndex % cols !== cols - 1) {\n        nextIndex = findNonDisabledIndex(elementsRef, {\n          startingIndex: prevIndex,\n          disabledIndices\n        });\n        if (loop && isDifferentRow(nextIndex, cols, prevRow)) {\n          nextIndex = findNonDisabledIndex(elementsRef, {\n            startingIndex: prevIndex - prevIndex % cols - 1,\n            disabledIndices\n          });\n        }\n      } else if (loop) {\n        nextIndex = findNonDisabledIndex(elementsRef, {\n          startingIndex: prevIndex - prevIndex % cols - 1,\n          disabledIndices\n        });\n      }\n      if (isDifferentRow(nextIndex, cols, prevRow)) {\n        nextIndex = prevIndex;\n      }\n    }\n    if (event.key === ARROW_LEFT) {\n      stop && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n      if (prevIndex % cols !== 0) {\n        nextIndex = findNonDisabledIndex(elementsRef, {\n          startingIndex: prevIndex,\n          disabledIndices,\n          decrement: true\n        });\n        if (loop && isDifferentRow(nextIndex, cols, prevRow)) {\n          nextIndex = findNonDisabledIndex(elementsRef, {\n            startingIndex: prevIndex + (cols - prevIndex % cols),\n            decrement: true,\n            disabledIndices\n          });\n        }\n      } else if (loop) {\n        nextIndex = findNonDisabledIndex(elementsRef, {\n          startingIndex: prevIndex + (cols - prevIndex % cols),\n          decrement: true,\n          disabledIndices\n        });\n      }\n      if (isDifferentRow(nextIndex, cols, prevRow)) {\n        nextIndex = prevIndex;\n      }\n    }\n    const lastRow = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_6__.floor)(maxIndex / cols) === prevRow;\n    if (isIndexOutOfBounds(elementsRef, nextIndex)) {\n      if (loop && lastRow) {\n        nextIndex = event.key === ARROW_LEFT ? maxIndex : findNonDisabledIndex(elementsRef, {\n          startingIndex: prevIndex - prevIndex % cols - 1,\n          disabledIndices\n        });\n      } else {\n        nextIndex = prevIndex;\n      }\n    }\n  }\n  return nextIndex;\n}\n\n/** For each cell index, gets the item index that occupies that cell */\nfunction buildCellMap(sizes, cols, dense) {\n  const cellMap = [];\n  let startIndex = 0;\n  sizes.forEach((_ref2, index) => {\n    let {\n      width,\n      height\n    } = _ref2;\n    if (width > cols) {\n      if (true) {\n        throw new Error(\"[Floating UI]: Invalid grid - item width at index \" + index + \" is greater than grid columns\");\n      }\n    }\n    let itemPlaced = false;\n    if (dense) {\n      startIndex = 0;\n    }\n    while (!itemPlaced) {\n      const targetCells = [];\n      for (let i = 0; i < width; i++) {\n        for (let j = 0; j < height; j++) {\n          targetCells.push(startIndex + i + j * cols);\n        }\n      }\n      if (startIndex % cols + width <= cols && targetCells.every(cell => cellMap[cell] == null)) {\n        targetCells.forEach(cell => {\n          cellMap[cell] = index;\n        });\n        itemPlaced = true;\n      } else {\n        startIndex++;\n      }\n    }\n  });\n\n  // convert into a non-sparse array\n  return [...cellMap];\n}\n\n/** Gets cell index of an item's corner or -1 when index is -1. */\nfunction getCellIndexOfCorner(index, sizes, cellMap, cols, corner) {\n  if (index === -1) return -1;\n  const firstCellIndex = cellMap.indexOf(index);\n  switch (corner) {\n    case 'tl':\n      return firstCellIndex;\n    case 'tr':\n      return firstCellIndex + sizes[index].width - 1;\n    case 'bl':\n      return firstCellIndex + (sizes[index].height - 1) * cols;\n    case 'br':\n      return cellMap.lastIndexOf(index);\n  }\n}\n\n/** Gets all cell indices that correspond to the specified indices */\nfunction getCellIndices(indices, cellMap) {\n  return cellMap.flatMap((index, cellIndex) => indices.includes(index) ? [cellIndex] : []);\n}\nlet rafId = 0;\nfunction enqueueFocus(el, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    preventScroll = false,\n    cancelPrevious = true,\n    sync = false\n  } = options;\n  cancelPrevious && cancelAnimationFrame(rafId);\n  const exec = () => el == null ? void 0 : el.focus({\n    preventScroll\n  });\n  if (sync) {\n    exec();\n  } else {\n    rafId = requestAnimationFrame(exec);\n  }\n}\nvar index = typeof document !== 'undefined' ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nfunction sortByDocumentPosition(a, b) {\n  const position = a.compareDocumentPosition(b);\n  if (position & Node.DOCUMENT_POSITION_FOLLOWING || position & Node.DOCUMENT_POSITION_CONTAINED_BY) {\n    return -1;\n  }\n  if (position & Node.DOCUMENT_POSITION_PRECEDING || position & Node.DOCUMENT_POSITION_CONTAINS) {\n    return 1;\n  }\n  return 0;\n}\nfunction areMapsEqual(map1, map2) {\n  if (map1.size !== map2.size) {\n    return false;\n  }\n  for (const [key, value] of map1.entries()) {\n    if (value !== map2.get(key)) {\n      return false;\n    }\n  }\n  return true;\n}\nconst FloatingListContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n  register: () => {},\n  unregister: () => {},\n  map: /*#__PURE__*/new Map(),\n  elementsRef: {\n    current: []\n  }\n});\n/**\n * Provides context for a list of items within the floating element.\n * @see https://floating-ui.com/docs/FloatingList\n */\nfunction FloatingList(_ref) {\n  let {\n    children,\n    elementsRef,\n    labelsRef\n  } = _ref;\n  const [map, setMap] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => new Map());\n  const register = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(node => {\n    setMap(prevMap => new Map(prevMap).set(node, null));\n  }, []);\n  const unregister = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(node => {\n    setMap(prevMap => {\n      const map = new Map(prevMap);\n      map.delete(node);\n      return map;\n    });\n  }, []);\n  index(() => {\n    const newMap = new Map(map);\n    const nodes = Array.from(newMap.keys()).sort(sortByDocumentPosition);\n    nodes.forEach((node, index) => {\n      newMap.set(node, index);\n    });\n    if (!areMapsEqual(map, newMap)) {\n      setMap(newMap);\n    }\n  }, [map]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(FloatingListContext.Provider, {\n    value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n      register,\n      unregister,\n      map,\n      elementsRef,\n      labelsRef\n    }), [register, unregister, map, elementsRef, labelsRef])\n  }, children);\n}\n/**\n * Used to register a list item and its index (DOM position) in the\n * `FloatingList`.\n * @see https://floating-ui.com/docs/FloatingList#uselistitem\n */\nfunction useListItem(_temp) {\n  let {\n    label\n  } = _temp === void 0 ? {} : _temp;\n  const [index$1, setIndex] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n  const componentRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const {\n    register,\n    unregister,\n    map,\n    elementsRef,\n    labelsRef\n  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(FloatingListContext);\n  const ref = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(node => {\n    componentRef.current = node;\n    if (index$1 !== null) {\n      elementsRef.current[index$1] = node;\n      if (labelsRef) {\n        var _node$textContent;\n        const isLabelDefined = label !== undefined;\n        labelsRef.current[index$1] = isLabelDefined ? label : (_node$textContent = node == null ? void 0 : node.textContent) != null ? _node$textContent : null;\n      }\n    }\n  }, [index$1, elementsRef, labelsRef, label]);\n  index(() => {\n    const node = componentRef.current;\n    if (node) {\n      register(node);\n      return () => {\n        unregister(node);\n      };\n    }\n  }, [register, unregister]);\n  index(() => {\n    const index = componentRef.current ? map.get(componentRef.current) : null;\n    if (index != null) {\n      setIndex(index);\n    }\n  }, [map]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    ref,\n    index: index$1 == null ? -1 : index$1\n  }), [index$1, ref]);\n}\nfunction renderJsx(render, computedProps) {\n  if (typeof render === 'function') {\n    return render(computedProps);\n  }\n  if (render) {\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(render, computedProps);\n  }\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", computedProps);\n}\nconst CompositeContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n  activeIndex: 0,\n  onNavigate: () => {}\n});\nconst horizontalKeys = [ARROW_LEFT, ARROW_RIGHT];\nconst verticalKeys = [ARROW_UP, ARROW_DOWN];\nconst allKeys = [...horizontalKeys, ...verticalKeys];\n\n/**\n * Creates a single tab stop whose items are navigated by arrow keys, which\n * provides list navigation outside of floating element contexts.\n *\n * This is useful to enable navigation of a list of items that aren’t part of a\n * floating element. A menubar is an example of a composite, with each reference\n * element being an item.\n * @see https://floating-ui.com/docs/Composite\n */\nconst Composite = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function Composite(_ref, forwardedRef) {\n  let {\n      render,\n      orientation = 'both',\n      loop = true,\n      cols = 1,\n      disabledIndices = [],\n      activeIndex: externalActiveIndex,\n      onNavigate: externalSetActiveIndex,\n      itemSizes,\n      dense = false\n    } = _ref,\n    props = _objectWithoutProperties(_ref, _excluded);\n  const [internalActiveIndex, internalSetActiveIndex] = react__WEBPACK_IMPORTED_MODULE_0__.useState(0);\n  const activeIndex = externalActiveIndex != null ? externalActiveIndex : internalActiveIndex;\n  const onNavigate = useEffectEvent(externalSetActiveIndex != null ? externalSetActiveIndex : internalSetActiveIndex);\n  const elementsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef([]);\n  const renderElementProps = render && typeof render !== 'function' ? render.props : {};\n  const contextValue = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    activeIndex,\n    onNavigate\n  }), [activeIndex, onNavigate]);\n  const isGrid = cols > 1;\n  function handleKeyDown(event) {\n    if (!allKeys.includes(event.key)) return;\n    let nextIndex = activeIndex;\n    if (isGrid) {\n      const sizes = itemSizes || Array.from({\n        length: elementsRef.current.length\n      }, () => ({\n        width: 1,\n        height: 1\n      }));\n      // To calculate movements on the grid, we use hypothetical cell indices\n      // as if every item was 1x1, then convert back to real indices.\n      const cellMap = buildCellMap(sizes, cols, dense);\n      const minGridIndex = cellMap.findIndex(index => index != null && !disabledIndices.includes(index));\n      // last enabled index\n      const maxGridIndex = cellMap.reduce((foundIndex, index, cellIndex) => index != null && !(disabledIndices != null && disabledIndices.includes(index)) ? cellIndex : foundIndex, -1);\n      nextIndex = cellMap[getGridNavigatedIndex({\n        current: cellMap.map(itemIndex => itemIndex ? elementsRef.current[itemIndex] : null)\n      }, {\n        event,\n        orientation,\n        loop,\n        cols,\n        // treat undefined (empty grid spaces) as disabled indices so we\n        // don't end up in them\n        disabledIndices: getCellIndices([...disabledIndices, undefined], cellMap),\n        minIndex: minGridIndex,\n        maxIndex: maxGridIndex,\n        prevIndex: getCellIndexOfCorner(activeIndex, sizes, cellMap, cols,\n        // use a corner matching the edge closest to the direction we're\n        // moving in so we don't end up in the same item. Prefer\n        // top/left over bottom/right.\n        event.key === ARROW_DOWN ? 'bl' : event.key === ARROW_RIGHT ? 'tr' : 'tl')\n      })]; // navigated cell will never be nullish\n    }\n    const minIndex = getMinIndex(elementsRef, disabledIndices);\n    const maxIndex = getMaxIndex(elementsRef, disabledIndices);\n    const toEndKeys = {\n      horizontal: [ARROW_RIGHT],\n      vertical: [ARROW_DOWN],\n      both: [ARROW_RIGHT, ARROW_DOWN]\n    }[orientation];\n    const toStartKeys = {\n      horizontal: [ARROW_LEFT],\n      vertical: [ARROW_UP],\n      both: [ARROW_LEFT, ARROW_UP]\n    }[orientation];\n    const preventedKeys = isGrid ? allKeys : {\n      horizontal: horizontalKeys,\n      vertical: verticalKeys,\n      both: allKeys\n    }[orientation];\n    if (nextIndex === activeIndex && [...toEndKeys, ...toStartKeys].includes(event.key)) {\n      if (loop && nextIndex === maxIndex && toEndKeys.includes(event.key)) {\n        nextIndex = minIndex;\n      } else if (loop && nextIndex === minIndex && toStartKeys.includes(event.key)) {\n        nextIndex = maxIndex;\n      } else {\n        nextIndex = findNonDisabledIndex(elementsRef, {\n          startingIndex: nextIndex,\n          decrement: toStartKeys.includes(event.key),\n          disabledIndices\n        });\n      }\n    }\n    if (nextIndex !== activeIndex && !isIndexOutOfBounds(elementsRef, nextIndex)) {\n      event.stopPropagation();\n      if (preventedKeys.includes(event.key)) {\n        event.preventDefault();\n      }\n      onNavigate(nextIndex);\n\n      // Wait for FocusManager `returnFocus` to execute.\n      queueMicrotask(() => {\n        enqueueFocus(elementsRef.current[nextIndex]);\n      });\n    }\n  }\n  const computedProps = _objectSpread(_objectSpread(_objectSpread({}, props), renderElementProps), {}, {\n    ref: forwardedRef,\n    'aria-orientation': orientation === 'both' ? undefined : orientation,\n    onKeyDown(e) {\n      props.onKeyDown == null || props.onKeyDown(e);\n      renderElementProps.onKeyDown == null || renderElementProps.onKeyDown(e);\n      handleKeyDown(e);\n    }\n  });\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(CompositeContext.Provider, {\n    value: contextValue\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(FloatingList, {\n    elementsRef: elementsRef\n  }, renderJsx(render, computedProps)));\n});\n/**\n * @see https://floating-ui.com/docs/Composite\n */\nconst CompositeItem = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function CompositeItem(_ref2, forwardedRef) {\n  let {\n      render\n    } = _ref2,\n    props = _objectWithoutProperties(_ref2, _excluded2);\n  const renderElementProps = render && typeof render !== 'function' ? render.props : {};\n  const {\n    activeIndex,\n    onNavigate\n  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(CompositeContext);\n  const {\n    ref,\n    index\n  } = useListItem();\n  const mergedRef = useMergeRefs([ref, forwardedRef, renderElementProps.ref]);\n  const isActive = activeIndex === index;\n  const computedProps = _objectSpread(_objectSpread(_objectSpread({}, props), renderElementProps), {}, {\n    ref: mergedRef,\n    tabIndex: isActive ? 0 : -1,\n    'data-active': isActive ? '' : undefined,\n    onFocus(e) {\n      props.onFocus == null || props.onFocus(e);\n      renderElementProps.onFocus == null || renderElementProps.onFocus(e);\n      onNavigate(index);\n    }\n  });\n  return renderJsx(render, computedProps);\n});\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nlet serverHandoffComplete = false;\nlet count = 0;\nconst genId = () => \"floating-ui-\" + count++;\nfunction useFloatingId() {\n  const [id, setId] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => serverHandoffComplete ? genId() : undefined);\n\n  // biome-ignore lint/correctness/useExhaustiveDependencies: intentional\n  index(() => {\n    if (id == null) {\n      setId(genId());\n    }\n  }, []);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!serverHandoffComplete) {\n      serverHandoffComplete = true;\n    }\n  }, []);\n  return id;\n}\n\n// `toString()` prevents bundlers from trying to `import { useId } from 'react'`\nconst useReactId = /*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_0__, 2)))[/*#__PURE__*/'useId'.toString()];\n\n/**\n * Uses React 18's built-in `useId()` when available, or falls back to a\n * slightly less performant (requiring a double render) implementation for\n * earlier React versions.\n * @see https://floating-ui.com/docs/react-utils#useid\n */\nconst useId = useReactId || useFloatingId;\n\n/**\n * Renders a pointing arrow triangle.\n * @see https://floating-ui.com/docs/FloatingArrow\n */\nconst FloatingArrow = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function FloatingArrow(_ref, ref) {\n  let {\n      context: {\n        placement,\n        elements: {\n          floating\n        },\n        middlewareData: {\n          arrow\n        }\n      },\n      width = 14,\n      height = 7,\n      tipRadius = 0,\n      strokeWidth = 0,\n      staticOffset,\n      stroke,\n      d,\n      style: {\n        transform\n      } = {}\n    } = _ref,\n    restStyle = _objectWithoutProperties(_ref.style, _excluded3),\n    rest = _objectWithoutProperties(_ref, _excluded4);\n  if (true) {\n    if (!ref) {\n      console.warn('Floating UI: The `ref` prop is required for the `FloatingArrow`', 'component.');\n    }\n  }\n  const clipPathId = useId();\n  if (!floating) {\n    return null;\n  }\n\n  // Strokes must be double the border width, this ensures the stroke's width\n  // works as you'd expect.\n  strokeWidth *= 2;\n  const halfStrokeWidth = strokeWidth / 2;\n  const svgX = width / 2 * (tipRadius / -8 + 1);\n  const svgY = height / 2 * tipRadius / 4;\n  const [side, alignment] = placement.split('-');\n  const isRTL = _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.platform.isRTL(floating);\n  const isCustomShape = !!d;\n  const isVerticalSide = side === 'top' || side === 'bottom';\n  const yOffsetProp = staticOffset && alignment === 'end' ? 'bottom' : 'top';\n  let xOffsetProp = staticOffset && alignment === 'end' ? 'right' : 'left';\n  if (staticOffset && isRTL) {\n    xOffsetProp = alignment === 'end' ? 'left' : 'right';\n  }\n  const arrowX = (arrow == null ? void 0 : arrow.x) != null ? staticOffset || arrow.x : '';\n  const arrowY = (arrow == null ? void 0 : arrow.y) != null ? staticOffset || arrow.y : '';\n  const dValue = d ||\n  // biome-ignore lint/style/useTemplate: readability\n  'M0,0' + (\" H\" + width) + (\" L\" + (width - svgX) + \",\" + (height - svgY)) + (\" Q\" + width / 2 + \",\" + height + \" \" + svgX + \",\" + (height - svgY)) + ' Z';\n  const rotation = {\n    top: isCustomShape ? 'rotate(180deg)' : '',\n    left: isCustomShape ? 'rotate(90deg)' : 'rotate(-90deg)',\n    bottom: isCustomShape ? '' : 'rotate(180deg)',\n    right: isCustomShape ? 'rotate(-90deg)' : 'rotate(90deg)'\n  }[side];\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", _extends({}, rest, {\n    \"aria-hidden\": true,\n    ref: ref,\n    width: isCustomShape ? width : width + strokeWidth,\n    height: width,\n    viewBox: \"0 0 \" + width + \" \" + (height > width ? height : width),\n    style: _objectSpread({\n      position: 'absolute',\n      pointerEvents: 'none',\n      [xOffsetProp]: arrowX,\n      [yOffsetProp]: arrowY,\n      [side]: isVerticalSide || isCustomShape ? '100%' : \"calc(100% - \" + strokeWidth / 2 + \"px)\",\n      transform: \"\" + rotation + (transform != null ? transform : '')\n    }, restStyle)\n  }), strokeWidth > 0 && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n    clipPath: \"url(#\" + clipPathId + \")\",\n    fill: \"none\",\n    stroke: stroke\n    // Account for the stroke on the fill path rendered below.\n    ,\n\n    strokeWidth: strokeWidth + (d ? 0 : 1),\n    d: dValue\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n    stroke: strokeWidth && !d ? rest.fill : 'none',\n    d: dValue\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"clipPath\", {\n    id: clipPathId\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"rect\", {\n    x: -halfStrokeWidth,\n    y: halfStrokeWidth * (isCustomShape ? -1 : 1),\n    width: width + strokeWidth,\n    height: width\n  })));\n});\nfunction createPubSub() {\n  const map = new Map();\n  return {\n    emit(event, data) {\n      var _map$get;\n      (_map$get = map.get(event)) == null || _map$get.forEach(handler => handler(data));\n    },\n    on(event, listener) {\n      map.set(event, [...(map.get(event) || []), listener]);\n    },\n    off(event, listener) {\n      var _map$get2;\n      map.set(event, ((_map$get2 = map.get(event)) == null ? void 0 : _map$get2.filter(l => l !== listener)) || []);\n    }\n  };\n}\nconst FloatingNodeContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nconst FloatingTreeContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n\n/**\n * Returns the parent node id for nested floating elements, if available.\n * Returns `null` for top-level floating elements.\n */\nconst useFloatingParentNodeId = () => {\n  var _React$useContext;\n  return ((_React$useContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;\n};\n\n/**\n * Returns the nearest floating tree context, if available.\n */\nconst useFloatingTree = () => react__WEBPACK_IMPORTED_MODULE_0__.useContext(FloatingTreeContext);\n\n/**\n * Registers a node into the `FloatingTree`, returning its id.\n * @see https://floating-ui.com/docs/FloatingTree\n */\nfunction useFloatingNodeId(customParentId) {\n  const id = useId();\n  const tree = useFloatingTree();\n  const reactParentId = useFloatingParentNodeId();\n  const parentId = customParentId || reactParentId;\n  index(() => {\n    const node = {\n      id,\n      parentId\n    };\n    tree == null || tree.addNode(node);\n    return () => {\n      tree == null || tree.removeNode(node);\n    };\n  }, [tree, id, parentId]);\n  return id;\n}\n\n/**\n * Provides parent node context for nested floating elements.\n * @see https://floating-ui.com/docs/FloatingTree\n */\nfunction FloatingNode(_ref) {\n  let {\n    children,\n    id\n  } = _ref;\n  const parentId = useFloatingParentNodeId();\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(FloatingNodeContext.Provider, {\n    value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n      id,\n      parentId\n    }), [id, parentId])\n  }, children);\n}\n\n/**\n * Provides context for nested floating elements when they are not children of\n * each other on the DOM.\n * This is not necessary in all cases, except when there must be explicit communication between parent and child floating elements. It is necessary for:\n * - The `bubbles` option in the `useDismiss()` Hook\n * - Nested virtual list navigation\n * - Nested floating elements that each open on hover\n * - Custom communication between parent and child floating elements\n * @see https://floating-ui.com/docs/FloatingTree\n */\nfunction FloatingTree(_ref2) {\n  let {\n    children\n  } = _ref2;\n  const nodesRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef([]);\n  const addNode = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(node => {\n    nodesRef.current = [...nodesRef.current, node];\n  }, []);\n  const removeNode = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(node => {\n    nodesRef.current = nodesRef.current.filter(n => n !== node);\n  }, []);\n  const events = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => createPubSub())[0];\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(FloatingTreeContext.Provider, {\n    value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n      nodesRef,\n      addNode,\n      removeNode,\n      events\n    }), [addNode, removeNode, events])\n  }, children);\n}\nfunction createAttribute(name) {\n  return \"data-floating-ui-\" + name;\n}\nfunction useLatestRef(value) {\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(value);\n  index(() => {\n    ref.current = value;\n  });\n  return ref;\n}\nconst safePolygonIdentifier = /*#__PURE__*/createAttribute('safe-polygon');\nfunction getDelay(value, prop, pointerType) {\n  if (pointerType && !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isMouseLikePointerType)(pointerType)) {\n    return 0;\n  }\n  if (typeof value === 'number') {\n    return value;\n  }\n  return value == null ? void 0 : value[prop];\n}\n/**\n * Opens the floating element while hovering over the reference element, like\n * CSS `:hover`.\n * @see https://floating-ui.com/docs/useHover\n */\nfunction useHover(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    onOpenChange,\n    dataRef,\n    events,\n    elements: {\n      domReference,\n      floating\n    },\n    refs\n  } = context;\n  const {\n    enabled = true,\n    delay = 0,\n    handleClose = null,\n    mouseOnly = false,\n    restMs = 0,\n    move = true\n  } = props;\n  const tree = useFloatingTree();\n  const parentId = useFloatingParentNodeId();\n  const handleCloseRef = useLatestRef(handleClose);\n  const delayRef = useLatestRef(delay);\n  const pointerTypeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n  const timeoutRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n  const handlerRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n  const restTimeoutRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n  const blockMouseMoveRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(true);\n  const performedPointerEventsMutationRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  const unbindMouseMoveRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(() => {});\n  const isHoverOpen = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\n    var _dataRef$current$open;\n    const type = (_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type;\n    return (type == null ? void 0 : type.includes('mouse')) && type !== 'mousedown';\n  }, [dataRef]);\n\n  // When closing before opening, clear the delay timeouts to cancel it\n  // from showing.\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    function onOpenChange(_ref) {\n      let {\n        open\n      } = _ref;\n      if (!open) {\n        clearTimeout(timeoutRef.current);\n        clearTimeout(restTimeoutRef.current);\n        blockMouseMoveRef.current = true;\n      }\n    }\n    events.on('openchange', onOpenChange);\n    return () => {\n      events.off('openchange', onOpenChange);\n    };\n  }, [enabled, events]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!enabled || !handleCloseRef.current || !open) {\n      return;\n    }\n    function onLeave(event) {\n      if (isHoverOpen()) {\n        onOpenChange(false, event, 'hover');\n      }\n    }\n    const html = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(floating).documentElement;\n    html.addEventListener('mouseleave', onLeave);\n    return () => {\n      html.removeEventListener('mouseleave', onLeave);\n    };\n  }, [floating, open, onOpenChange, enabled, handleCloseRef, isHoverOpen]);\n  const closeWithDelay = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function (event, runElseBranch, reason) {\n    if (runElseBranch === void 0) {\n      runElseBranch = true;\n    }\n    if (reason === void 0) {\n      reason = 'hover';\n    }\n    const closeDelay = getDelay(delayRef.current, 'close', pointerTypeRef.current);\n    if (closeDelay && !handlerRef.current) {\n      clearTimeout(timeoutRef.current);\n      timeoutRef.current = setTimeout(() => onOpenChange(false, event, reason), closeDelay);\n    } else if (runElseBranch) {\n      clearTimeout(timeoutRef.current);\n      onOpenChange(false, event, reason);\n    }\n  }, [delayRef, onOpenChange]);\n  const cleanupMouseMoveHandler = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\n    unbindMouseMoveRef.current();\n    handlerRef.current = undefined;\n  }, []);\n  const clearPointerEvents = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\n    if (performedPointerEventsMutationRef.current) {\n      const body = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(refs.floating.current).body;\n      body.style.pointerEvents = '';\n      body.removeAttribute(safePolygonIdentifier);\n      performedPointerEventsMutationRef.current = false;\n    }\n  }, [refs]);\n\n  // Registering the mouse events on the reference directly to bypass React's\n  // delegation system. If the cursor was on a disabled element and then entered\n  // the reference (no gap), `mouseenter` doesn't fire in the delegation system.\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    function isClickLikeOpenEvent() {\n      return dataRef.current.openEvent ? ['click', 'mousedown'].includes(dataRef.current.openEvent.type) : false;\n    }\n    function onMouseEnter(event) {\n      clearTimeout(timeoutRef.current);\n      blockMouseMoveRef.current = false;\n      if (mouseOnly && !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isMouseLikePointerType)(pointerTypeRef.current) || restMs > 0 && getDelay(delayRef.current, 'open') === 0) {\n        return;\n      }\n      const openDelay = getDelay(delayRef.current, 'open', pointerTypeRef.current);\n      if (openDelay) {\n        timeoutRef.current = setTimeout(() => {\n          onOpenChange(true, event, 'hover');\n        }, openDelay);\n      } else {\n        onOpenChange(true, event, 'hover');\n      }\n    }\n    function onMouseLeave(event) {\n      if (isClickLikeOpenEvent()) {\n        return;\n      }\n      unbindMouseMoveRef.current();\n      const doc = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(floating);\n      clearTimeout(restTimeoutRef.current);\n      if (handleCloseRef.current) {\n        // Prevent clearing `onScrollMouseLeave` timeout.\n        if (!open) {\n          clearTimeout(timeoutRef.current);\n        }\n        handlerRef.current = handleCloseRef.current(_objectSpread(_objectSpread({}, context), {}, {\n          tree,\n          x: event.clientX,\n          y: event.clientY,\n          onClose() {\n            clearPointerEvents();\n            cleanupMouseMoveHandler();\n            closeWithDelay(event, true, 'safe-polygon');\n          }\n        }));\n        const handler = handlerRef.current;\n        doc.addEventListener('mousemove', handler);\n        unbindMouseMoveRef.current = () => {\n          doc.removeEventListener('mousemove', handler);\n        };\n        return;\n      }\n\n      // Allow interactivity without `safePolygon` on touch devices. With a\n      // pointer, a short close delay is an alternative, so it should work\n      // consistently.\n      const shouldClose = pointerTypeRef.current === 'touch' ? !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(floating, event.relatedTarget) : true;\n      if (shouldClose) {\n        closeWithDelay(event);\n      }\n    }\n\n    // Ensure the floating element closes after scrolling even if the pointer\n    // did not move.\n    // https://github.com/floating-ui/floating-ui/discussions/1692\n    function onScrollMouseLeave(event) {\n      if (isClickLikeOpenEvent()) {\n        return;\n      }\n      handleCloseRef.current == null || handleCloseRef.current(_objectSpread(_objectSpread({}, context), {}, {\n        tree,\n        x: event.clientX,\n        y: event.clientY,\n        onClose() {\n          clearPointerEvents();\n          cleanupMouseMoveHandler();\n          closeWithDelay(event);\n        }\n      }))(event);\n    }\n    if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.isElement)(domReference)) {\n      const ref = domReference;\n      open && ref.addEventListener('mouseleave', onScrollMouseLeave);\n      floating == null || floating.addEventListener('mouseleave', onScrollMouseLeave);\n      move && ref.addEventListener('mousemove', onMouseEnter, {\n        once: true\n      });\n      ref.addEventListener('mouseenter', onMouseEnter);\n      ref.addEventListener('mouseleave', onMouseLeave);\n      return () => {\n        open && ref.removeEventListener('mouseleave', onScrollMouseLeave);\n        floating == null || floating.removeEventListener('mouseleave', onScrollMouseLeave);\n        move && ref.removeEventListener('mousemove', onMouseEnter);\n        ref.removeEventListener('mouseenter', onMouseEnter);\n        ref.removeEventListener('mouseleave', onMouseLeave);\n      };\n    }\n  }, [domReference, floating, enabled, context, mouseOnly, restMs, move, closeWithDelay, cleanupMouseMoveHandler, clearPointerEvents, onOpenChange, open, tree, delayRef, handleCloseRef, dataRef]);\n\n  // Block pointer-events of every element other than the reference and floating\n  // while the floating element is open and has a `handleClose` handler. Also\n  // handles nested floating elements.\n  // https://github.com/floating-ui/floating-ui/issues/1722\n  index(() => {\n    var _handleCloseRef$curre;\n    if (!enabled) {\n      return;\n    }\n    if (open && (_handleCloseRef$curre = handleCloseRef.current) != null && _handleCloseRef$curre.__options.blockPointerEvents && isHoverOpen()) {\n      const body = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(floating).body;\n      body.setAttribute(safePolygonIdentifier, '');\n      body.style.pointerEvents = 'none';\n      performedPointerEventsMutationRef.current = true;\n      if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.isElement)(domReference) && floating) {\n        var _tree$nodesRef$curren;\n        const ref = domReference;\n        const parentFloating = tree == null || (_tree$nodesRef$curren = tree.nodesRef.current.find(node => node.id === parentId)) == null || (_tree$nodesRef$curren = _tree$nodesRef$curren.context) == null ? void 0 : _tree$nodesRef$curren.elements.floating;\n        if (parentFloating) {\n          parentFloating.style.pointerEvents = '';\n        }\n        ref.style.pointerEvents = 'auto';\n        floating.style.pointerEvents = 'auto';\n        return () => {\n          ref.style.pointerEvents = '';\n          floating.style.pointerEvents = '';\n        };\n      }\n    }\n  }, [enabled, open, parentId, floating, domReference, tree, handleCloseRef, isHoverOpen]);\n  index(() => {\n    if (!open) {\n      pointerTypeRef.current = undefined;\n      cleanupMouseMoveHandler();\n      clearPointerEvents();\n    }\n  }, [open, cleanupMouseMoveHandler, clearPointerEvents]);\n\n  // biome-ignore lint/correctness/useExhaustiveDependencies: intentional\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    return () => {\n      cleanupMouseMoveHandler();\n      clearTimeout(timeoutRef.current);\n      clearTimeout(restTimeoutRef.current);\n      clearPointerEvents();\n    };\n  }, [enabled, domReference, cleanupMouseMoveHandler, clearPointerEvents]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    function setPointerRef(event) {\n      pointerTypeRef.current = event.pointerType;\n    }\n    return {\n      reference: {\n        onPointerDown: setPointerRef,\n        onPointerEnter: setPointerRef,\n        onMouseMove(event) {\n          if (open || restMs === 0) {\n            return;\n          }\n          clearTimeout(restTimeoutRef.current);\n          restTimeoutRef.current = setTimeout(() => {\n            if (!blockMouseMoveRef.current) {\n              onOpenChange(true, event.nativeEvent, 'hover');\n            }\n          }, restMs);\n        }\n      },\n      floating: {\n        onMouseEnter() {\n          clearTimeout(timeoutRef.current);\n        },\n        onMouseLeave(event) {\n          closeWithDelay(event.nativeEvent, false);\n        }\n      }\n    };\n  }, [enabled, restMs, open, onOpenChange, closeWithDelay]);\n}\nconst FloatingDelayGroupContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n  delay: 0,\n  initialDelay: 0,\n  timeoutMs: 0,\n  currentId: null,\n  setCurrentId: () => {},\n  setState: () => {},\n  isInstantPhase: false\n});\nconst useDelayGroupContext = () => react__WEBPACK_IMPORTED_MODULE_0__.useContext(FloatingDelayGroupContext);\n/**\n * Provides context for a group of floating elements that should share a\n * `delay`.\n * @see https://floating-ui.com/docs/FloatingDelayGroup\n */\nconst FloatingDelayGroup = _ref => {\n  let {\n    children,\n    delay,\n    timeoutMs = 0\n  } = _ref;\n  const [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useReducer((prev, next) => _objectSpread(_objectSpread({}, prev), next), {\n    delay,\n    timeoutMs,\n    initialDelay: delay,\n    currentId: null,\n    isInstantPhase: false\n  });\n  const initialCurrentIdRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const setCurrentId = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(currentId => {\n    setState({\n      currentId\n    });\n  }, []);\n  index(() => {\n    if (state.currentId) {\n      if (initialCurrentIdRef.current === null) {\n        initialCurrentIdRef.current = state.currentId;\n      } else {\n        setState({\n          isInstantPhase: true\n        });\n      }\n    } else {\n      setState({\n        isInstantPhase: false\n      });\n      initialCurrentIdRef.current = null;\n    }\n  }, [state.currentId]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(FloatingDelayGroupContext.Provider, {\n    value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => _objectSpread(_objectSpread({}, state), {}, {\n      setState,\n      setCurrentId\n    }), [state, setCurrentId])\n  }, children);\n};\n/**\n * Enables grouping when called inside a component that's a child of a\n * `FloatingDelayGroup`.\n * @see https://floating-ui.com/docs/FloatingDelayGroup\n */\nconst useDelayGroup = (_ref2, _ref3) => {\n  let {\n    open,\n    onOpenChange\n  } = _ref2;\n  let {\n    id\n  } = _ref3;\n  const {\n    currentId,\n    setCurrentId,\n    initialDelay,\n    setState,\n    timeoutMs\n  } = useDelayGroupContext();\n  index(() => {\n    if (currentId) {\n      setState({\n        delay: {\n          open: 1,\n          close: getDelay(initialDelay, 'close')\n        }\n      });\n      if (currentId !== id) {\n        onOpenChange(false);\n      }\n    }\n  }, [id, onOpenChange, setState, currentId, initialDelay]);\n  index(() => {\n    function unset() {\n      onOpenChange(false);\n      setState({\n        delay: initialDelay,\n        currentId: null\n      });\n    }\n    if (!open && currentId === id) {\n      if (timeoutMs) {\n        const timeout = window.setTimeout(unset, timeoutMs);\n        return () => {\n          clearTimeout(timeout);\n        };\n      }\n      unset();\n    }\n  }, [open, setState, currentId, id, onOpenChange, initialDelay, timeoutMs]);\n  index(() => {\n    if (open) {\n      setCurrentId(id);\n    }\n  }, [open, setCurrentId, id]);\n};\nfunction getAncestors(nodes, id) {\n  var _nodes$find;\n  let allAncestors = [];\n  let currentParentId = (_nodes$find = nodes.find(node => node.id === id)) == null ? void 0 : _nodes$find.parentId;\n  while (currentParentId) {\n    const currentNode = nodes.find(node => node.id === currentParentId);\n    currentParentId = currentNode == null ? void 0 : currentNode.parentId;\n    if (currentNode) {\n      allAncestors = allAncestors.concat(currentNode);\n    }\n  }\n  return allAncestors;\n}\nfunction getChildren(nodes, id) {\n  let allChildren = nodes.filter(node => {\n    var _node$context;\n    return node.parentId === id && ((_node$context = node.context) == null ? void 0 : _node$context.open);\n  });\n  let currentChildren = allChildren;\n  while (currentChildren.length) {\n    currentChildren = nodes.filter(node => {\n      var _currentChildren;\n      return (_currentChildren = currentChildren) == null ? void 0 : _currentChildren.some(n => {\n        var _node$context2;\n        return node.parentId === n.id && ((_node$context2 = node.context) == null ? void 0 : _node$context2.open);\n      });\n    });\n    allChildren = allChildren.concat(currentChildren);\n  }\n  return allChildren;\n}\nfunction getDeepestNode(nodes, id) {\n  let deepestNodeId;\n  let maxDepth = -1;\n  function findDeepest(nodeId, depth) {\n    if (depth > maxDepth) {\n      deepestNodeId = nodeId;\n      maxDepth = depth;\n    }\n    const children = getChildren(nodes, nodeId);\n    children.forEach(child => {\n      findDeepest(child.id, depth + 1);\n    });\n  }\n  findDeepest(id, 0);\n  return nodes.find(node => node.id === deepestNodeId);\n}\n\n// Modified to add conditional `aria-hidden` support:\n// https://github.com/theKashey/aria-hidden/blob/9220c8f4a4fd35f63bee5510a9f41a37264382d4/src/index.ts\nlet counterMap = /*#__PURE__*/new WeakMap();\nlet uncontrolledElementsSet = /*#__PURE__*/new WeakSet();\nlet markerMap = {};\nlet lockCount = 0;\nconst supportsInert = () => typeof HTMLElement !== 'undefined' && 'inert' in HTMLElement.prototype;\nconst unwrapHost = node => node && (node.host || unwrapHost(node.parentNode));\nconst correctElements = (parent, targets) => targets.map(target => {\n  if (parent.contains(target)) {\n    return target;\n  }\n  const correctedTarget = unwrapHost(target);\n  if (parent.contains(correctedTarget)) {\n    return correctedTarget;\n  }\n  return null;\n}).filter(x => x != null);\nfunction applyAttributeToOthers(uncorrectedAvoidElements, body, ariaHidden, inert) {\n  const markerName = 'data-floating-ui-inert';\n  const controlAttribute = inert ? 'inert' : ariaHidden ? 'aria-hidden' : null;\n  const avoidElements = correctElements(body, uncorrectedAvoidElements);\n  const elementsToKeep = new Set();\n  const elementsToStop = new Set(avoidElements);\n  const hiddenElements = [];\n  if (!markerMap[markerName]) {\n    markerMap[markerName] = new WeakMap();\n  }\n  const markerCounter = markerMap[markerName];\n  avoidElements.forEach(keep);\n  deep(body);\n  elementsToKeep.clear();\n  function keep(el) {\n    if (!el || elementsToKeep.has(el)) {\n      return;\n    }\n    elementsToKeep.add(el);\n    el.parentNode && keep(el.parentNode);\n  }\n  function deep(parent) {\n    if (!parent || elementsToStop.has(parent)) {\n      return;\n    }\n    Array.prototype.forEach.call(parent.children, node => {\n      if (elementsToKeep.has(node)) {\n        deep(node);\n      } else {\n        const attr = controlAttribute ? node.getAttribute(controlAttribute) : null;\n        const alreadyHidden = attr !== null && attr !== 'false';\n        const counterValue = (counterMap.get(node) || 0) + 1;\n        const markerValue = (markerCounter.get(node) || 0) + 1;\n        counterMap.set(node, counterValue);\n        markerCounter.set(node, markerValue);\n        hiddenElements.push(node);\n        if (counterValue === 1 && alreadyHidden) {\n          uncontrolledElementsSet.add(node);\n        }\n        if (markerValue === 1) {\n          node.setAttribute(markerName, '');\n        }\n        if (!alreadyHidden && controlAttribute) {\n          node.setAttribute(controlAttribute, 'true');\n        }\n      }\n    });\n  }\n  lockCount++;\n  return () => {\n    hiddenElements.forEach(element => {\n      const counterValue = (counterMap.get(element) || 0) - 1;\n      const markerValue = (markerCounter.get(element) || 0) - 1;\n      counterMap.set(element, counterValue);\n      markerCounter.set(element, markerValue);\n      if (!counterValue) {\n        if (!uncontrolledElementsSet.has(element) && controlAttribute) {\n          element.removeAttribute(controlAttribute);\n        }\n        uncontrolledElementsSet.delete(element);\n      }\n      if (!markerValue) {\n        element.removeAttribute(markerName);\n      }\n    });\n    lockCount--;\n    if (!lockCount) {\n      counterMap = new WeakMap();\n      counterMap = new WeakMap();\n      uncontrolledElementsSet = new WeakSet();\n      markerMap = {};\n    }\n  };\n}\nfunction markOthers(avoidElements, ariaHidden, inert) {\n  if (ariaHidden === void 0) {\n    ariaHidden = false;\n  }\n  if (inert === void 0) {\n    inert = false;\n  }\n  const body = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(avoidElements[0]).body;\n  return applyAttributeToOthers(avoidElements.concat(Array.from(body.querySelectorAll('[aria-live]'))), body, ariaHidden, inert);\n}\nconst getTabbableOptions = () => ({\n  getShadowRoot: true,\n  displayCheck:\n  // JSDOM does not support the `tabbable` library. To solve this we can\n  // check if `ResizeObserver` is a real function (not polyfilled), which\n  // determines if the current environment is JSDOM-like.\n  typeof ResizeObserver === 'function' && ResizeObserver.toString().includes('[native code]') ? 'full' : 'none'\n});\nfunction getTabbableIn(container, direction) {\n  const allTabbable = (0,tabbable__WEBPACK_IMPORTED_MODULE_7__.tabbable)(container, getTabbableOptions());\n  if (direction === 'prev') {\n    allTabbable.reverse();\n  }\n  const activeIndex = allTabbable.indexOf((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.activeElement)((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(container)));\n  const nextTabbableElements = allTabbable.slice(activeIndex + 1);\n  return nextTabbableElements[0];\n}\nfunction getNextTabbable() {\n  return getTabbableIn(document.body, 'next');\n}\nfunction getPreviousTabbable() {\n  return getTabbableIn(document.body, 'prev');\n}\nfunction isOutsideEvent(event, container) {\n  const containerElement = container || event.currentTarget;\n  const relatedTarget = event.relatedTarget;\n  return !relatedTarget || !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(containerElement, relatedTarget);\n}\nfunction disableFocusInside(container) {\n  const tabbableElements = (0,tabbable__WEBPACK_IMPORTED_MODULE_7__.tabbable)(container, getTabbableOptions());\n  tabbableElements.forEach(element => {\n    element.dataset.tabindex = element.getAttribute('tabindex') || '';\n    element.setAttribute('tabindex', '-1');\n  });\n}\nfunction enableFocusInside(container) {\n  const elements = container.querySelectorAll('[data-tabindex]');\n  elements.forEach(element => {\n    const tabindex = element.dataset.tabindex;\n    // biome-ignore lint/performance/noDelete: purity\n    delete element.dataset.tabindex;\n    if (tabindex) {\n      element.setAttribute('tabindex', tabindex);\n    } else {\n      element.removeAttribute('tabindex');\n    }\n  });\n}\n\n// See Diego Haz's Sandbox for making this logic work well on Safari/iOS:\n// https://codesandbox.io/s/tabbable-portal-f4tng?file=/src/FocusTrap.tsx\n\nconst HIDDEN_STYLES = {\n  border: 0,\n  clip: 'rect(0 0 0 0)',\n  height: '1px',\n  margin: '-1px',\n  overflow: 'hidden',\n  padding: 0,\n  position: 'fixed',\n  whiteSpace: 'nowrap',\n  width: '1px',\n  top: 0,\n  left: 0\n};\nlet timeoutId;\nfunction setActiveElementOnTab(event) {\n  if (event.key === 'Tab') {\n    event.target;\n    clearTimeout(timeoutId);\n  }\n}\nconst FocusGuard = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function FocusGuard(props, ref) {\n  const [role, setRole] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n  index(() => {\n    if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isSafari)()) {\n      // Unlike other screen readers such as NVDA and JAWS, the virtual cursor\n      // on VoiceOver does trigger the onFocus event, so we can use the focus\n      // trap element. On Safari, only buttons trigger the onFocus event.\n      // NB: \"group\" role in the Sandbox no longer appears to work, must be a\n      // button role.\n      setRole('button');\n    }\n    document.addEventListener('keydown', setActiveElementOnTab);\n    return () => {\n      document.removeEventListener('keydown', setActiveElementOnTab);\n    };\n  }, []);\n  const restProps = {\n    ref,\n    tabIndex: 0,\n    // Role is only for VoiceOver\n    role,\n    'aria-hidden': role ? undefined : true,\n    [createAttribute('focus-guard')]: '',\n    style: HIDDEN_STYLES\n  };\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", _extends({}, props, restProps));\n});\nconst PortalContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nconst attr = /*#__PURE__*/createAttribute('portal');\n\n/**\n * @see https://floating-ui.com/docs/FloatingPortal#usefloatingportalnode\n */\nfunction useFloatingPortalNode(_temp) {\n  let {\n    id,\n    root\n  } = _temp === void 0 ? {} : _temp;\n  const [portalNode, setPortalNode] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n  const uniqueId = useId();\n  const portalContext = usePortalContext();\n  const portalNodeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  index(() => {\n    return () => {\n      portalNode == null || portalNode.remove();\n      // Allow the subsequent layout effects to create a new node on updates.\n      // The portal node will still be cleaned up on unmount.\n      // https://github.com/floating-ui/floating-ui/issues/2454\n      queueMicrotask(() => {\n        portalNodeRef.current = null;\n      });\n    };\n  }, [portalNode]);\n  index(() => {\n    if (portalNodeRef.current) return;\n    const existingIdRoot = id ? document.getElementById(id) : null;\n    if (!existingIdRoot) return;\n    const subRoot = document.createElement('div');\n    subRoot.id = uniqueId;\n    subRoot.setAttribute(attr, '');\n    existingIdRoot.appendChild(subRoot);\n    portalNodeRef.current = subRoot;\n    setPortalNode(subRoot);\n  }, [id, uniqueId]);\n  index(() => {\n    if (portalNodeRef.current) return;\n    let container = root || (portalContext == null ? void 0 : portalContext.portalNode);\n    if (container && !(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.isElement)(container)) container = container.current;\n    container = container || document.body;\n    let idWrapper = null;\n    if (id) {\n      idWrapper = document.createElement('div');\n      idWrapper.id = id;\n      container.appendChild(idWrapper);\n    }\n    const subRoot = document.createElement('div');\n    subRoot.id = uniqueId;\n    subRoot.setAttribute(attr, '');\n    container = idWrapper || container;\n    container.appendChild(subRoot);\n    portalNodeRef.current = subRoot;\n    setPortalNode(subRoot);\n  }, [id, root, uniqueId, portalContext]);\n  return portalNode;\n}\n/**\n * Portals the floating element into a given container element — by default,\n * outside of the app root and into the body.\n * This is necessary to ensure the floating element can appear outside any\n * potential parent containers that cause clipping (such as `overflow: hidden`),\n * while retaining its location in the React tree.\n * @see https://floating-ui.com/docs/FloatingPortal\n */\nfunction FloatingPortal(_ref) {\n  let {\n    children,\n    id,\n    root = null,\n    preserveTabOrder = true\n  } = _ref;\n  const portalNode = useFloatingPortalNode({\n    id,\n    root\n  });\n  const [focusManagerState, setFocusManagerState] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n  const beforeOutsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const afterOutsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const beforeInsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const afterInsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const shouldRenderGuards =\n  // The FocusManager and therefore floating element are currently open/\n  // rendered.\n  !!focusManagerState &&\n  // Guards are only for non-modal focus management.\n  !focusManagerState.modal &&\n  // Don't render if unmount is transitioning.\n  focusManagerState.open && preserveTabOrder && !!(root || portalNode);\n\n  // https://codesandbox.io/s/tabbable-portal-f4tng?file=/src/TabbablePortal.tsx\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!portalNode || !preserveTabOrder || focusManagerState != null && focusManagerState.modal) {\n      return;\n    }\n\n    // Make sure elements inside the portal element are tabbable only when the\n    // portal has already been focused, either by tabbing into a focus trap\n    // element outside or using the mouse.\n    function onFocus(event) {\n      if (portalNode && isOutsideEvent(event)) {\n        const focusing = event.type === 'focusin';\n        const manageFocus = focusing ? enableFocusInside : disableFocusInside;\n        manageFocus(portalNode);\n      }\n    }\n    // Listen to the event on the capture phase so they run before the focus\n    // trap elements onFocus prop is called.\n    portalNode.addEventListener('focusin', onFocus, true);\n    portalNode.addEventListener('focusout', onFocus, true);\n    return () => {\n      portalNode.removeEventListener('focusin', onFocus, true);\n      portalNode.removeEventListener('focusout', onFocus, true);\n    };\n  }, [portalNode, preserveTabOrder, focusManagerState == null ? void 0 : focusManagerState.modal]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(PortalContext.Provider, {\n    value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n      preserveTabOrder,\n      beforeOutsideRef,\n      afterOutsideRef,\n      beforeInsideRef,\n      afterInsideRef,\n      portalNode,\n      setFocusManagerState\n    }), [preserveTabOrder, portalNode])\n  }, shouldRenderGuards && portalNode && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(FocusGuard, {\n    \"data-type\": \"outside\",\n    ref: beforeOutsideRef,\n    onFocus: event => {\n      if (isOutsideEvent(event, portalNode)) {\n        var _beforeInsideRef$curr;\n        (_beforeInsideRef$curr = beforeInsideRef.current) == null || _beforeInsideRef$curr.focus();\n      } else {\n        const prevTabbable = getPreviousTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);\n        prevTabbable == null || prevTabbable.focus();\n      }\n    }\n  }), shouldRenderGuards && portalNode && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n    \"aria-owns\": portalNode.id,\n    style: HIDDEN_STYLES\n  }), portalNode && /*#__PURE__*/(0,react_dom__WEBPACK_IMPORTED_MODULE_4__.createPortal)(children, portalNode), shouldRenderGuards && portalNode && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(FocusGuard, {\n    \"data-type\": \"outside\",\n    ref: afterOutsideRef,\n    onFocus: event => {\n      if (isOutsideEvent(event, portalNode)) {\n        var _afterInsideRef$curre;\n        (_afterInsideRef$curre = afterInsideRef.current) == null || _afterInsideRef$curre.focus();\n      } else {\n        const nextTabbable = getNextTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);\n        nextTabbable == null || nextTabbable.focus();\n        (focusManagerState == null ? void 0 : focusManagerState.closeOnFocusOut) && (focusManagerState == null ? void 0 : focusManagerState.onOpenChange(false, event.nativeEvent));\n      }\n    }\n  }));\n}\nconst usePortalContext = () => react__WEBPACK_IMPORTED_MODULE_0__.useContext(PortalContext);\nconst LIST_LIMIT = 20;\nlet previouslyFocusedElements = [];\nfunction addPreviouslyFocusedElement(element) {\n  previouslyFocusedElements = previouslyFocusedElements.filter(el => el.isConnected);\n  let tabbableEl = element;\n  if (!tabbableEl || (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.getNodeName)(tabbableEl) === 'body') return;\n  if (!(0,tabbable__WEBPACK_IMPORTED_MODULE_7__.isTabbable)(tabbableEl, getTabbableOptions())) {\n    const tabbableChild = (0,tabbable__WEBPACK_IMPORTED_MODULE_7__.tabbable)(tabbableEl, getTabbableOptions())[0];\n    if (!tabbableChild) return;\n    tabbableEl = tabbableChild;\n  }\n  previouslyFocusedElements.push(tabbableEl);\n  if (previouslyFocusedElements.length > LIST_LIMIT) {\n    previouslyFocusedElements = previouslyFocusedElements.slice(-LIST_LIMIT);\n  }\n}\nfunction getPreviouslyFocusedElement() {\n  return previouslyFocusedElements.slice().reverse().find(el => el.isConnected);\n}\nconst VisuallyHiddenDismiss = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function VisuallyHiddenDismiss(props, ref) {\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", _extends({}, props, {\n    type: \"button\",\n    ref: ref,\n    tabIndex: -1,\n    style: HIDDEN_STYLES\n  }));\n});\n/**\n * Provides focus management for the floating element.\n * @see https://floating-ui.com/docs/FloatingFocusManager\n */\nfunction FloatingFocusManager(props) {\n  const {\n    context,\n    children,\n    disabled = false,\n    order = ['content'],\n    guards: _guards = true,\n    initialFocus = 0,\n    returnFocus = true,\n    modal = true,\n    visuallyHiddenDismiss = false,\n    closeOnFocusOut = true\n  } = props;\n  const {\n    open,\n    refs,\n    nodeId,\n    onOpenChange,\n    events,\n    dataRef,\n    elements: {\n      domReference,\n      floating\n    }\n  } = context;\n  const ignoreInitialFocus = typeof initialFocus === 'number' && initialFocus < 0;\n  // If the reference is a combobox and is typeable (e.g. input/textarea),\n  // there are different focus semantics. The guards should not be rendered, but\n  // aria-hidden should be applied to all nodes still. Further, the visually\n  // hidden dismiss button should only appear at the end of the list, not the\n  // start.\n  const isUntrappedTypeableCombobox = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isTypeableCombobox)(domReference) && ignoreInitialFocus;\n\n  // Force the guards to be rendered if the `inert` attribute is not supported.\n  const guards = supportsInert() ? _guards : true;\n  const orderRef = useLatestRef(order);\n  const initialFocusRef = useLatestRef(initialFocus);\n  const returnFocusRef = useLatestRef(returnFocus);\n  const tree = useFloatingTree();\n  const portalContext = usePortalContext();\n  const startDismissButtonRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const endDismissButtonRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const preventReturnFocusRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  const isPointerDownRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  const isInsidePortal = portalContext != null;\n  const getTabbableContent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function (container) {\n    if (container === void 0) {\n      container = floating;\n    }\n    return container ? (0,tabbable__WEBPACK_IMPORTED_MODULE_7__.tabbable)(container, getTabbableOptions()) : [];\n  }, [floating]);\n  const getTabbableElements = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(container => {\n    const content = getTabbableContent(container);\n    return orderRef.current.map(type => {\n      if (domReference && type === 'reference') {\n        return domReference;\n      }\n      if (floating && type === 'floating') {\n        return floating;\n      }\n      return content;\n    }).filter(Boolean).flat();\n  }, [domReference, floating, orderRef, getTabbableContent]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (disabled || !modal) return;\n    function onKeyDown(event) {\n      if (event.key === 'Tab') {\n        // The focus guards have nothing to focus, so we need to stop the event.\n        if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(floating, (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.activeElement)((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(floating))) && getTabbableContent().length === 0 && !isUntrappedTypeableCombobox) {\n          (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n        }\n        const els = getTabbableElements();\n        const target = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getTarget)(event);\n        if (orderRef.current[0] === 'reference' && target === domReference) {\n          (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n          if (event.shiftKey) {\n            enqueueFocus(els[els.length - 1]);\n          } else {\n            enqueueFocus(els[1]);\n          }\n        }\n        if (orderRef.current[1] === 'floating' && target === floating && event.shiftKey) {\n          (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n          enqueueFocus(els[0]);\n        }\n      }\n    }\n    const doc = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(floating);\n    doc.addEventListener('keydown', onKeyDown);\n    return () => {\n      doc.removeEventListener('keydown', onKeyDown);\n    };\n  }, [disabled, domReference, floating, modal, orderRef, isUntrappedTypeableCombobox, getTabbableContent, getTabbableElements]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (disabled || !closeOnFocusOut) return;\n\n    // In Safari, buttons lose focus when pressing them.\n    function handlePointerDown() {\n      isPointerDownRef.current = true;\n      setTimeout(() => {\n        isPointerDownRef.current = false;\n      });\n    }\n    function handleFocusOutside(event) {\n      const relatedTarget = event.relatedTarget;\n      queueMicrotask(() => {\n        const movedToUnrelatedNode = !((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(domReference, relatedTarget) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(floating, relatedTarget) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(relatedTarget, floating) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(portalContext == null ? void 0 : portalContext.portalNode, relatedTarget) || relatedTarget != null && relatedTarget.hasAttribute(createAttribute('focus-guard')) || tree && (getChildren(tree.nodesRef.current, nodeId).find(node => {\n          var _node$context, _node$context2;\n          return (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)((_node$context = node.context) == null ? void 0 : _node$context.elements.floating, relatedTarget) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)((_node$context2 = node.context) == null ? void 0 : _node$context2.elements.domReference, relatedTarget);\n        }) || getAncestors(tree.nodesRef.current, nodeId).find(node => {\n          var _node$context3, _node$context4;\n          return ((_node$context3 = node.context) == null ? void 0 : _node$context3.elements.floating) === relatedTarget || ((_node$context4 = node.context) == null ? void 0 : _node$context4.elements.domReference) === relatedTarget;\n        })));\n\n        // Focus did not move inside the floating tree, and there are no tabbable\n        // portal guards to handle closing.\n        if (relatedTarget && movedToUnrelatedNode && !isPointerDownRef.current &&\n        // Fix React 18 Strict Mode returnFocus due to double rendering.\n        relatedTarget !== getPreviouslyFocusedElement()) {\n          preventReturnFocusRef.current = true;\n          onOpenChange(false, event);\n        }\n      });\n    }\n    if (floating && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.isHTMLElement)(domReference)) {\n      domReference.addEventListener('focusout', handleFocusOutside);\n      domReference.addEventListener('pointerdown', handlePointerDown);\n      !modal && floating.addEventListener('focusout', handleFocusOutside);\n      return () => {\n        domReference.removeEventListener('focusout', handleFocusOutside);\n        domReference.removeEventListener('pointerdown', handlePointerDown);\n        !modal && floating.removeEventListener('focusout', handleFocusOutside);\n      };\n    }\n  }, [disabled, domReference, floating, modal, nodeId, tree, portalContext, onOpenChange, closeOnFocusOut]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    var _portalContext$portal;\n    if (disabled) return;\n\n    // Don't hide portals nested within the parent portal.\n    const portalNodes = Array.from((portalContext == null || (_portalContext$portal = portalContext.portalNode) == null ? void 0 : _portalContext$portal.querySelectorAll(\"[\" + createAttribute('portal') + \"]\")) || []);\n    if (floating) {\n      const insideElements = [floating, ...portalNodes, startDismissButtonRef.current, endDismissButtonRef.current, orderRef.current.includes('reference') || isUntrappedTypeableCombobox ? domReference : null].filter(x => x != null);\n      const cleanup = modal || isUntrappedTypeableCombobox ? markOthers(insideElements, guards, !guards) : markOthers(insideElements);\n      return () => {\n        cleanup();\n      };\n    }\n  }, [disabled, domReference, floating, modal, orderRef, portalContext, isUntrappedTypeableCombobox, guards]);\n  index(() => {\n    if (disabled || !floating) return;\n    const doc = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(floating);\n    const previouslyFocusedElement = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.activeElement)(doc);\n\n    // Wait for any layout effect state setters to execute to set `tabIndex`.\n    queueMicrotask(() => {\n      const focusableElements = getTabbableElements(floating);\n      const initialFocusValue = initialFocusRef.current;\n      const elToFocus = (typeof initialFocusValue === 'number' ? focusableElements[initialFocusValue] : initialFocusValue.current) || floating;\n      const focusAlreadyInsideFloatingEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(floating, previouslyFocusedElement);\n      if (!ignoreInitialFocus && !focusAlreadyInsideFloatingEl && open) {\n        enqueueFocus(elToFocus, {\n          preventScroll: elToFocus === floating\n        });\n      }\n    });\n  }, [disabled, open, floating, ignoreInitialFocus, getTabbableElements, initialFocusRef]);\n  index(() => {\n    if (disabled || !floating) return;\n    let preventReturnFocusScroll = false;\n    const doc = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(floating);\n    const previouslyFocusedElement = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.activeElement)(doc);\n    const contextData = dataRef.current;\n    addPreviouslyFocusedElement(previouslyFocusedElement);\n\n    // Dismissing via outside press should always ignore `returnFocus` to\n    // prevent unwanted scrolling.\n    function onOpenChange(_ref) {\n      let {\n        reason,\n        event,\n        nested\n      } = _ref;\n      if (reason === 'escape-key' && refs.domReference.current) {\n        addPreviouslyFocusedElement(refs.domReference.current);\n      }\n      if (reason === 'hover' && event.type === 'mouseleave') {\n        preventReturnFocusRef.current = true;\n      }\n      if (reason !== 'outside-press') return;\n      if (nested) {\n        preventReturnFocusRef.current = false;\n        preventReturnFocusScroll = true;\n      } else {\n        preventReturnFocusRef.current = !((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isVirtualClick)(event) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isVirtualPointerEvent)(event));\n      }\n    }\n    events.on('openchange', onOpenChange);\n    return () => {\n      events.off('openchange', onOpenChange);\n      const activeEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.activeElement)(doc);\n      const isFocusInsideFloatingTree = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(floating, activeEl) || tree && getChildren(tree.nodesRef.current, nodeId).some(node => {\n        var _node$context5;\n        return (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)((_node$context5 = node.context) == null ? void 0 : _node$context5.elements.floating, activeEl);\n      });\n      const shouldFocusReference = isFocusInsideFloatingTree || contextData.openEvent && ['click', 'mousedown'].includes(contextData.openEvent.type);\n      if (shouldFocusReference && refs.domReference.current) {\n        addPreviouslyFocusedElement(refs.domReference.current);\n      }\n      const returnElement = getPreviouslyFocusedElement();\n      if (returnFocusRef.current && !preventReturnFocusRef.current && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.isHTMLElement)(returnElement) && (\n      // If the focus moved somewhere else after mount, avoid returning focus\n      // since it likely entered a different element which should be\n      // respected: https://github.com/floating-ui/floating-ui/issues/2607\n      returnElement !== activeEl && activeEl !== doc.body ? isFocusInsideFloatingTree : true)) {\n        enqueueFocus(returnElement, {\n          // When dismissing nested floating elements, by the time the rAF has\n          // executed, the menus will all have been unmounted. When they try\n          // to get focused, the calls get ignored — leaving the root\n          // reference focused as desired.\n          cancelPrevious: false,\n          preventScroll: preventReturnFocusScroll\n        });\n      }\n    };\n  }, [disabled, floating, returnFocusRef, dataRef, refs, events, tree, nodeId]);\n\n  // Synchronize the `context` & `modal` value to the FloatingPortal context.\n  // It will decide whether or not it needs to render its own guards.\n  index(() => {\n    if (disabled || !portalContext) return;\n    portalContext.setFocusManagerState({\n      modal,\n      closeOnFocusOut,\n      open,\n      onOpenChange,\n      refs\n    });\n    return () => {\n      portalContext.setFocusManagerState(null);\n    };\n  }, [disabled, portalContext, modal, open, onOpenChange, refs, closeOnFocusOut]);\n  index(() => {\n    if (disabled || !floating || typeof MutationObserver !== 'function' || ignoreInitialFocus) {\n      return;\n    }\n    const handleMutation = () => {\n      const tabIndex = floating.getAttribute('tabindex');\n      if (orderRef.current.includes('floating') || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.activeElement)((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(floating)) !== refs.domReference.current && getTabbableContent().length === 0) {\n        if (tabIndex !== '0') {\n          floating.setAttribute('tabindex', '0');\n        }\n      } else if (tabIndex !== '-1') {\n        floating.setAttribute('tabindex', '-1');\n      }\n    };\n    handleMutation();\n    const observer = new MutationObserver(handleMutation);\n    observer.observe(floating, {\n      childList: true,\n      subtree: true,\n      attributes: true\n    });\n    return () => {\n      observer.disconnect();\n    };\n  }, [disabled, floating, refs, orderRef, getTabbableContent, ignoreInitialFocus]);\n  function renderDismissButton(location) {\n    if (disabled || !visuallyHiddenDismiss || !modal) {\n      return null;\n    }\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(VisuallyHiddenDismiss, {\n      ref: location === 'start' ? startDismissButtonRef : endDismissButtonRef,\n      onClick: event => onOpenChange(false, event.nativeEvent)\n    }, typeof visuallyHiddenDismiss === 'string' ? visuallyHiddenDismiss : 'Dismiss');\n  }\n  const shouldRenderGuards = !disabled && guards && (isInsidePortal || modal);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, shouldRenderGuards && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(FocusGuard, {\n    \"data-type\": \"inside\",\n    ref: portalContext == null ? void 0 : portalContext.beforeInsideRef,\n    onFocus: event => {\n      if (modal) {\n        const els = getTabbableElements();\n        enqueueFocus(order[0] === 'reference' ? els[0] : els[els.length - 1]);\n      } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {\n        preventReturnFocusRef.current = false;\n        if (isOutsideEvent(event, portalContext.portalNode)) {\n          const nextTabbable = getNextTabbable() || domReference;\n          nextTabbable == null || nextTabbable.focus();\n        } else {\n          var _portalContext$before;\n          (_portalContext$before = portalContext.beforeOutsideRef.current) == null || _portalContext$before.focus();\n        }\n      }\n    }\n  }), !isUntrappedTypeableCombobox && renderDismissButton('start'), children, renderDismissButton('end'), shouldRenderGuards && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(FocusGuard, {\n    \"data-type\": \"inside\",\n    ref: portalContext == null ? void 0 : portalContext.afterInsideRef,\n    onFocus: event => {\n      if (modal) {\n        enqueueFocus(getTabbableElements()[0]);\n      } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {\n        if (closeOnFocusOut) {\n          preventReturnFocusRef.current = true;\n        }\n        if (isOutsideEvent(event, portalContext.portalNode)) {\n          const prevTabbable = getPreviousTabbable() || domReference;\n          prevTabbable == null || prevTabbable.focus();\n        } else {\n          var _portalContext$afterO;\n          (_portalContext$afterO = portalContext.afterOutsideRef.current) == null || _portalContext$afterO.focus();\n        }\n      }\n    }\n  }));\n}\nconst activeLocks = /*#__PURE__*/new Set();\n/**\n * Provides base styling for a fixed overlay element to dim content or block\n * pointer events behind a floating element.\n * It's a regular `<div>`, so it can be styled via any CSS solution you prefer.\n * @see https://floating-ui.com/docs/FloatingOverlay\n */\nconst FloatingOverlay = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function FloatingOverlay(_ref, ref) {\n  let {\n      lockScroll = false\n    } = _ref,\n    rest = _objectWithoutProperties(_ref, _excluded5);\n  const lockId = useId();\n  index(() => {\n    if (!lockScroll) return;\n    activeLocks.add(lockId);\n    const isIOS = /iP(hone|ad|od)|iOS/.test((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getPlatform)());\n    const bodyStyle = document.body.style;\n    // RTL <body> scrollbar\n    const scrollbarX = Math.round(document.documentElement.getBoundingClientRect().left) + document.documentElement.scrollLeft;\n    const paddingProp = scrollbarX ? 'paddingLeft' : 'paddingRight';\n    const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;\n    const scrollX = bodyStyle.left ? parseFloat(bodyStyle.left) : window.pageXOffset;\n    const scrollY = bodyStyle.top ? parseFloat(bodyStyle.top) : window.pageYOffset;\n    bodyStyle.overflow = 'hidden';\n    if (scrollbarWidth) {\n      bodyStyle[paddingProp] = scrollbarWidth + \"px\";\n    }\n\n    // Only iOS doesn't respect `overflow: hidden` on document.body, and this\n    // technique has fewer side effects.\n    if (isIOS) {\n      var _window$visualViewpor, _window$visualViewpor2;\n      // iOS 12 does not support `visualViewport`.\n      const offsetLeft = ((_window$visualViewpor = window.visualViewport) == null ? void 0 : _window$visualViewpor.offsetLeft) || 0;\n      const offsetTop = ((_window$visualViewpor2 = window.visualViewport) == null ? void 0 : _window$visualViewpor2.offsetTop) || 0;\n      Object.assign(bodyStyle, {\n        position: 'fixed',\n        top: -(scrollY - Math.floor(offsetTop)) + \"px\",\n        left: -(scrollX - Math.floor(offsetLeft)) + \"px\",\n        right: '0'\n      });\n    }\n    return () => {\n      activeLocks.delete(lockId);\n      if (activeLocks.size === 0) {\n        Object.assign(bodyStyle, {\n          overflow: '',\n          [paddingProp]: ''\n        });\n        if (isIOS) {\n          Object.assign(bodyStyle, {\n            position: '',\n            top: '',\n            left: '',\n            right: ''\n          });\n          window.scrollTo(scrollX, scrollY);\n        }\n      }\n    };\n  }, [lockId, lockScroll]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", _extends({\n    ref: ref\n  }, rest, {\n    style: _objectSpread({\n      position: 'fixed',\n      overflow: 'auto',\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    }, rest.style)\n  }));\n});\nfunction isButtonTarget(event) {\n  return (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.isHTMLElement)(event.target) && event.target.tagName === 'BUTTON';\n}\nfunction isSpaceIgnored(element) {\n  return (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isTypeableElement)(element);\n}\n/**\n * Opens or closes the floating element when clicking the reference element.\n * @see https://floating-ui.com/docs/useClick\n */\nfunction useClick(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    onOpenChange,\n    dataRef,\n    elements: {\n      domReference\n    }\n  } = context;\n  const {\n    enabled = true,\n    event: eventOption = 'click',\n    toggle = true,\n    ignoreMouse = false,\n    keyboardHandlers = true\n  } = props;\n  const pointerTypeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n  const didKeyDownRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    if (!enabled) return {};\n    return {\n      reference: {\n        onPointerDown(event) {\n          pointerTypeRef.current = event.pointerType;\n        },\n        onMouseDown(event) {\n          // Ignore all buttons except for the \"main\" button.\n          // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\n          if (event.button !== 0) {\n            return;\n          }\n          if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isMouseLikePointerType)(pointerTypeRef.current, true) && ignoreMouse) {\n            return;\n          }\n          if (eventOption === 'click') {\n            return;\n          }\n          if (open && toggle && (dataRef.current.openEvent ? dataRef.current.openEvent.type === 'mousedown' : true)) {\n            onOpenChange(false, event.nativeEvent, 'click');\n          } else {\n            // Prevent stealing focus from the floating element\n            event.preventDefault();\n            onOpenChange(true, event.nativeEvent, 'click');\n          }\n        },\n        onClick(event) {\n          if (eventOption === 'mousedown' && pointerTypeRef.current) {\n            pointerTypeRef.current = undefined;\n            return;\n          }\n          if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isMouseLikePointerType)(pointerTypeRef.current, true) && ignoreMouse) {\n            return;\n          }\n          if (open && toggle && (dataRef.current.openEvent ? dataRef.current.openEvent.type === 'click' : true)) {\n            onOpenChange(false, event.nativeEvent, 'click');\n          } else {\n            onOpenChange(true, event.nativeEvent, 'click');\n          }\n        },\n        onKeyDown(event) {\n          pointerTypeRef.current = undefined;\n          if (event.defaultPrevented || !keyboardHandlers || isButtonTarget(event)) {\n            return;\n          }\n          if (event.key === ' ' && !isSpaceIgnored(domReference)) {\n            // Prevent scrolling\n            event.preventDefault();\n            didKeyDownRef.current = true;\n          }\n          if (event.key === 'Enter') {\n            if (open && toggle) {\n              onOpenChange(false, event.nativeEvent, 'click');\n            } else {\n              onOpenChange(true, event.nativeEvent, 'click');\n            }\n          }\n        },\n        onKeyUp(event) {\n          if (event.defaultPrevented || !keyboardHandlers || isButtonTarget(event) || isSpaceIgnored(domReference)) {\n            return;\n          }\n          if (event.key === ' ' && didKeyDownRef.current) {\n            didKeyDownRef.current = false;\n            if (open && toggle) {\n              onOpenChange(false, event.nativeEvent, 'click');\n            } else {\n              onOpenChange(true, event.nativeEvent, 'click');\n            }\n          }\n        }\n      }\n    };\n  }, [enabled, dataRef, eventOption, ignoreMouse, keyboardHandlers, domReference, toggle, open, onOpenChange]);\n}\nfunction createVirtualElement(domRef, data) {\n  let offsetX = null;\n  let offsetY = null;\n  let isAutoUpdateEvent = false;\n  return {\n    contextElement: domRef.current || undefined,\n    getBoundingClientRect() {\n      var _domRef$current, _data$dataRef$current;\n      const domRect = ((_domRef$current = domRef.current) == null ? void 0 : _domRef$current.getBoundingClientRect()) || {\n        width: 0,\n        height: 0,\n        x: 0,\n        y: 0\n      };\n      const isXAxis = data.axis === 'x' || data.axis === 'both';\n      const isYAxis = data.axis === 'y' || data.axis === 'both';\n      const canTrackCursorOnAutoUpdate = ['mouseenter', 'mousemove'].includes(((_data$dataRef$current = data.dataRef.current.openEvent) == null ? void 0 : _data$dataRef$current.type) || '') && data.pointerType !== 'touch';\n      let width = domRect.width;\n      let height = domRect.height;\n      let x = domRect.x;\n      let y = domRect.y;\n      if (offsetX == null && data.x && isXAxis) {\n        offsetX = domRect.x - data.x;\n      }\n      if (offsetY == null && data.y && isYAxis) {\n        offsetY = domRect.y - data.y;\n      }\n      x -= offsetX || 0;\n      y -= offsetY || 0;\n      width = 0;\n      height = 0;\n      if (!isAutoUpdateEvent || canTrackCursorOnAutoUpdate) {\n        width = data.axis === 'y' ? domRect.width : 0;\n        height = data.axis === 'x' ? domRect.height : 0;\n        x = isXAxis && data.x != null ? data.x : x;\n        y = isYAxis && data.y != null ? data.y : y;\n      } else if (isAutoUpdateEvent && !canTrackCursorOnAutoUpdate) {\n        height = data.axis === 'x' ? domRect.height : height;\n        width = data.axis === 'y' ? domRect.width : width;\n      }\n      isAutoUpdateEvent = true;\n      return {\n        width,\n        height,\n        x,\n        y,\n        top: y,\n        right: x + width,\n        bottom: y + height,\n        left: x\n      };\n    }\n  };\n}\nfunction isMouseBasedEvent(event) {\n  return event != null && event.clientX != null;\n}\n/**\n * Positions the floating element relative to a client point (in the viewport),\n * such as the mouse position. By default, it follows the mouse cursor.\n * @see https://floating-ui.com/docs/useClientPoint\n */\nfunction useClientPoint(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    refs,\n    dataRef,\n    elements: {\n      floating\n    }\n  } = context;\n  const {\n    enabled = true,\n    axis = 'both',\n    x = null,\n    y = null\n  } = props;\n  const initialRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  const cleanupListenerRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const [pointerType, setPointerType] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n  const [reactive, setReactive] = react__WEBPACK_IMPORTED_MODULE_0__.useState([]);\n  const setReference = useEffectEvent((x, y) => {\n    if (initialRef.current) return;\n\n    // Prevent setting if the open event was not a mouse-like one\n    // (e.g. focus to open, then hover over the reference element).\n    // Only apply if the event exists.\n    if (dataRef.current.openEvent && !isMouseBasedEvent(dataRef.current.openEvent)) {\n      return;\n    }\n    refs.setPositionReference(createVirtualElement(refs.domReference, {\n      x,\n      y,\n      axis,\n      dataRef,\n      pointerType\n    }));\n  });\n  const handleReferenceEnterOrMove = useEffectEvent(event => {\n    if (x != null || y != null) return;\n    if (!open) {\n      setReference(event.clientX, event.clientY);\n    } else if (!cleanupListenerRef.current) {\n      // If there's no cleanup, there's no listener, but we want to ensure\n      // we add the listener if the cursor landed on the floating element and\n      // then back on the reference (i.e. it's interactive).\n      setReactive([]);\n    }\n  });\n\n  // If the pointer is a mouse-like pointer, we want to continue following the\n  // mouse even if the floating element is transitioning out. On touch\n  // devices, this is undesirable because the floating element will move to\n  // the dismissal touch point.\n  const openCheck = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isMouseLikePointerType)(pointerType) ? floating : open;\n  const addListener = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\n    // Explicitly specified `x`/`y` coordinates shouldn't add a listener.\n    if (!openCheck || !enabled || x != null || y != null) return;\n    const win = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.getWindow)(refs.floating.current);\n    function handleMouseMove(event) {\n      const target = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getTarget)(event);\n      if (!(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(refs.floating.current, target)) {\n        setReference(event.clientX, event.clientY);\n      } else {\n        win.removeEventListener('mousemove', handleMouseMove);\n        cleanupListenerRef.current = null;\n      }\n    }\n    if (!dataRef.current.openEvent || isMouseBasedEvent(dataRef.current.openEvent)) {\n      win.addEventListener('mousemove', handleMouseMove);\n      const cleanup = () => {\n        win.removeEventListener('mousemove', handleMouseMove);\n        cleanupListenerRef.current = null;\n      };\n      cleanupListenerRef.current = cleanup;\n      return cleanup;\n    }\n    refs.setPositionReference(refs.domReference.current);\n  }, [dataRef, enabled, openCheck, refs, setReference, x, y]);\n\n  // biome-ignore lint/correctness/useExhaustiveDependencies: intentionally specifying `reactive`\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    return addListener();\n  }, [addListener, reactive]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (enabled && !floating) {\n      initialRef.current = false;\n    }\n  }, [enabled, floating]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!enabled && open) {\n      initialRef.current = true;\n    }\n  }, [enabled, open]);\n  index(() => {\n    if (enabled && (x != null || y != null)) {\n      initialRef.current = false;\n      setReference(x, y);\n    }\n  }, [enabled, x, y, setReference]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    if (!enabled) return {};\n    function setPointerTypeRef(_ref) {\n      let {\n        pointerType\n      } = _ref;\n      setPointerType(pointerType);\n    }\n    return {\n      reference: {\n        onPointerDown: setPointerTypeRef,\n        onPointerEnter: setPointerTypeRef,\n        onMouseMove: handleReferenceEnterOrMove,\n        onMouseEnter: handleReferenceEnterOrMove\n      }\n    };\n  }, [enabled, handleReferenceEnterOrMove]);\n}\nconst bubbleHandlerKeys = {\n  pointerdown: 'onPointerDown',\n  mousedown: 'onMouseDown',\n  click: 'onClick'\n};\nconst captureHandlerKeys = {\n  pointerdown: 'onPointerDownCapture',\n  mousedown: 'onMouseDownCapture',\n  click: 'onClickCapture'\n};\nconst normalizeProp = normalizable => {\n  var _normalizable$escapeK, _normalizable$outside;\n  return {\n    escapeKey: typeof normalizable === 'boolean' ? normalizable : (_normalizable$escapeK = normalizable == null ? void 0 : normalizable.escapeKey) != null ? _normalizable$escapeK : false,\n    outsidePress: typeof normalizable === 'boolean' ? normalizable : (_normalizable$outside = normalizable == null ? void 0 : normalizable.outsidePress) != null ? _normalizable$outside : true\n  };\n};\n/**\n * Closes the floating element when a dismissal is requested — by default, when\n * the user presses the `escape` key or outside of the floating element.\n * @see https://floating-ui.com/docs/useDismiss\n */\nfunction useDismiss(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    onOpenChange,\n    nodeId,\n    elements: {\n      reference,\n      domReference,\n      floating\n    },\n    dataRef\n  } = context;\n  const {\n    enabled = true,\n    escapeKey = true,\n    outsidePress: unstable_outsidePress = true,\n    outsidePressEvent = 'pointerdown',\n    referencePress = false,\n    referencePressEvent = 'pointerdown',\n    ancestorScroll = false,\n    bubbles,\n    capture\n  } = props;\n  const tree = useFloatingTree();\n  const outsidePressFn = useEffectEvent(typeof unstable_outsidePress === 'function' ? unstable_outsidePress : () => false);\n  const outsidePress = typeof unstable_outsidePress === 'function' ? outsidePressFn : unstable_outsidePress;\n  const insideReactTreeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  const endedOrStartedInsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  const {\n    escapeKey: escapeKeyBubbles,\n    outsidePress: outsidePressBubbles\n  } = normalizeProp(bubbles);\n  const {\n    escapeKey: escapeKeyCapture,\n    outsidePress: outsidePressCapture\n  } = normalizeProp(capture);\n  const closeOnEscapeKeyDown = useEffectEvent(event => {\n    if (!open || !enabled || !escapeKey || event.key !== 'Escape') {\n      return;\n    }\n    const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];\n    if (!escapeKeyBubbles) {\n      event.stopPropagation();\n      if (children.length > 0) {\n        let shouldDismiss = true;\n        children.forEach(child => {\n          var _child$context;\n          if ((_child$context = child.context) != null && _child$context.open && !child.context.dataRef.current.__escapeKeyBubbles) {\n            shouldDismiss = false;\n            return;\n          }\n        });\n        if (!shouldDismiss) {\n          return;\n        }\n      }\n    }\n    onOpenChange(false, (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isReactEvent)(event) ? event.nativeEvent : event, 'escape-key');\n  });\n  const closeOnEscapeKeyDownCapture = useEffectEvent(event => {\n    var _getTarget2;\n    const callback = () => {\n      var _getTarget;\n      closeOnEscapeKeyDown(event);\n      (_getTarget = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getTarget)(event)) == null || _getTarget.removeEventListener('keydown', callback);\n    };\n    (_getTarget2 = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getTarget)(event)) == null || _getTarget2.addEventListener('keydown', callback);\n  });\n  const closeOnPressOutside = useEffectEvent(event => {\n    // Given developers can stop the propagation of the synthetic event,\n    // we can only be confident with a positive value.\n    const insideReactTree = insideReactTreeRef.current;\n    insideReactTreeRef.current = false;\n\n    // When click outside is lazy (`click` event), handle dragging.\n    // Don't close if:\n    // - The click started inside the floating element.\n    // - The click ended inside the floating element.\n    const endedOrStartedInside = endedOrStartedInsideRef.current;\n    endedOrStartedInsideRef.current = false;\n    if (outsidePressEvent === 'click' && endedOrStartedInside) {\n      return;\n    }\n    if (insideReactTree) {\n      return;\n    }\n    if (typeof outsidePress === 'function' && !outsidePress(event)) {\n      return;\n    }\n    const target = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getTarget)(event);\n    const inertSelector = \"[\" + createAttribute('inert') + \"]\";\n    const markers = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(floating).querySelectorAll(inertSelector);\n    let targetRootAncestor = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.isElement)(target) ? target : null;\n    while (targetRootAncestor && !(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.isLastTraversableNode)(targetRootAncestor)) {\n      const nextParent = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.getParentNode)(targetRootAncestor);\n      if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.isLastTraversableNode)(nextParent) || !(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.isElement)(nextParent)) {\n        break;\n      }\n      targetRootAncestor = nextParent;\n    }\n\n    // Check if the click occurred on a third-party element injected after the\n    // floating element rendered.\n    if (markers.length && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.isElement)(target) && !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isRootElement)(target) &&\n    // Clicked on a direct ancestor (e.g. FloatingOverlay).\n    !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(target, floating) &&\n    // If the target root element contains none of the markers, then the\n    // element was injected after the floating element rendered.\n    Array.from(markers).every(marker => !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(targetRootAncestor, marker))) {\n      return;\n    }\n\n    // Check if the click occurred on the scrollbar\n    if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.isHTMLElement)(target) && floating) {\n      // In Firefox, `target.scrollWidth > target.clientWidth` for inline\n      // elements.\n      const canScrollX = target.clientWidth > 0 && target.scrollWidth > target.clientWidth;\n      const canScrollY = target.clientHeight > 0 && target.scrollHeight > target.clientHeight;\n      let xCond = canScrollY && event.offsetX > target.clientWidth;\n\n      // In some browsers it is possible to change the <body> (or window)\n      // scrollbar to the left side, but is very rare and is difficult to\n      // check for. Plus, for modal dialogs with backdrops, it is more\n      // important that the backdrop is checked but not so much the window.\n      if (canScrollY) {\n        const isRTL = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.getComputedStyle)(target).direction === 'rtl';\n        if (isRTL) {\n          xCond = event.offsetX <= target.offsetWidth - target.clientWidth;\n        }\n      }\n      if (xCond || canScrollX && event.offsetY > target.clientHeight) {\n        return;\n      }\n    }\n    const targetIsInsideChildren = tree && getChildren(tree.nodesRef.current, nodeId).some(node => {\n      var _node$context;\n      return (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isEventTargetWithin)(event, (_node$context = node.context) == null ? void 0 : _node$context.elements.floating);\n    });\n    if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isEventTargetWithin)(event, floating) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isEventTargetWithin)(event, domReference) || targetIsInsideChildren) {\n      return;\n    }\n    const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];\n    if (children.length > 0) {\n      let shouldDismiss = true;\n      children.forEach(child => {\n        var _child$context2;\n        if ((_child$context2 = child.context) != null && _child$context2.open && !child.context.dataRef.current.__outsidePressBubbles) {\n          shouldDismiss = false;\n          return;\n        }\n      });\n      if (!shouldDismiss) {\n        return;\n      }\n    }\n    onOpenChange(false, event, 'outside-press');\n  });\n  const closeOnPressOutsideCapture = useEffectEvent(event => {\n    var _getTarget4;\n    const callback = () => {\n      var _getTarget3;\n      closeOnPressOutside(event);\n      (_getTarget3 = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getTarget)(event)) == null || _getTarget3.removeEventListener(outsidePressEvent, callback);\n    };\n    (_getTarget4 = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getTarget)(event)) == null || _getTarget4.addEventListener(outsidePressEvent, callback);\n  });\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!open || !enabled) {\n      return;\n    }\n    dataRef.current.__escapeKeyBubbles = escapeKeyBubbles;\n    dataRef.current.__outsidePressBubbles = outsidePressBubbles;\n    function onScroll(event) {\n      onOpenChange(false, event, 'ancestor-scroll');\n    }\n    const doc = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(floating);\n    escapeKey && doc.addEventListener('keydown', escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture);\n    outsidePress && doc.addEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);\n    let ancestors = [];\n    if (ancestorScroll) {\n      if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.isElement)(domReference)) {\n        ancestors = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.getOverflowAncestors)(domReference);\n      }\n      if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.isElement)(floating)) {\n        ancestors = ancestors.concat((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.getOverflowAncestors)(floating));\n      }\n      if (!(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.isElement)(reference) && reference && reference.contextElement) {\n        ancestors = ancestors.concat((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.getOverflowAncestors)(reference.contextElement));\n      }\n    }\n\n    // Ignore the visual viewport for scrolling dismissal (allow pinch-zoom)\n    ancestors = ancestors.filter(ancestor => {\n      var _doc$defaultView;\n      return ancestor !== ((_doc$defaultView = doc.defaultView) == null ? void 0 : _doc$defaultView.visualViewport);\n    });\n    ancestors.forEach(ancestor => {\n      ancestor.addEventListener('scroll', onScroll, {\n        passive: true\n      });\n    });\n    return () => {\n      escapeKey && doc.removeEventListener('keydown', escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture);\n      outsidePress && doc.removeEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);\n      ancestors.forEach(ancestor => {\n        ancestor.removeEventListener('scroll', onScroll);\n      });\n    };\n  }, [dataRef, floating, domReference, reference, escapeKey, outsidePress, outsidePressEvent, open, onOpenChange, ancestorScroll, enabled, escapeKeyBubbles, outsidePressBubbles, closeOnEscapeKeyDown, escapeKeyCapture, closeOnEscapeKeyDownCapture, closeOnPressOutside, outsidePressCapture, closeOnPressOutsideCapture]);\n\n  // biome-ignore lint/correctness/useExhaustiveDependencies: intentional\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    insideReactTreeRef.current = false;\n  }, [outsidePress, outsidePressEvent]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    return {\n      reference: {\n        onKeyDown: closeOnEscapeKeyDown,\n        [bubbleHandlerKeys[referencePressEvent]]: event => {\n          if (referencePress) {\n            onOpenChange(false, event.nativeEvent, 'reference-press');\n          }\n        }\n      },\n      floating: {\n        onKeyDown: closeOnEscapeKeyDown,\n        onMouseDown() {\n          endedOrStartedInsideRef.current = true;\n        },\n        onMouseUp() {\n          endedOrStartedInsideRef.current = true;\n        },\n        [captureHandlerKeys[outsidePressEvent]]: () => {\n          insideReactTreeRef.current = true;\n        }\n      }\n    };\n  }, [enabled, referencePress, outsidePressEvent, referencePressEvent, onOpenChange, closeOnEscapeKeyDown]);\n}\nlet devMessageSet;\nif (true) {\n  devMessageSet = /*#__PURE__*/new Set();\n}\n\n/**\n * Provides data to position a floating element and context to add interactions.\n * @see https://floating-ui.com/docs/useFloating\n */\nfunction useFloating(options) {\n  var _options$elements2;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    open = false,\n    onOpenChange: unstable_onOpenChange,\n    nodeId\n  } = options;\n  if (true) {\n    var _options$elements;\n    const err = 'Floating UI: Cannot pass a virtual element to the ' + '`elements.reference` option, as it must be a real DOM element. ' + 'Use `refs.setPositionReference` instead.';\n    if ((_options$elements = options.elements) != null && _options$elements.reference && !(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.isElement)(options.elements.reference)) {\n      var _devMessageSet;\n      if (!((_devMessageSet = devMessageSet) != null && _devMessageSet.has(err))) {\n        var _devMessageSet2;\n        (_devMessageSet2 = devMessageSet) == null || _devMessageSet2.add(err);\n        console.error(err);\n      }\n    }\n  }\n  const [_domReference, setDomReference] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n  const domReference = ((_options$elements2 = options.elements) == null ? void 0 : _options$elements2.reference) || _domReference;\n  const position = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_1__.useFloating)(options);\n  const tree = useFloatingTree();\n  const nested = useFloatingParentNodeId() != null;\n  const onOpenChange = useEffectEvent((open, event, reason) => {\n    if (open) {\n      dataRef.current.openEvent = event;\n    }\n    events.emit('openchange', {\n      open,\n      event,\n      reason,\n      nested\n    });\n    unstable_onOpenChange == null || unstable_onOpenChange(open, event, reason);\n  });\n  const domReferenceRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const dataRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef({});\n  const events = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => createPubSub())[0];\n  const floatingId = useId();\n  const setPositionReference = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(node => {\n    const positionReference = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.isElement)(node) ? {\n      getBoundingClientRect: () => node.getBoundingClientRect(),\n      contextElement: node\n    } : node;\n    position.refs.setReference(positionReference);\n  }, [position.refs]);\n  const setReference = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(node => {\n    if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.isElement)(node) || node === null) {\n      domReferenceRef.current = node;\n      setDomReference(node);\n    }\n\n    // Backwards-compatibility for passing a virtual element to `reference`\n    // after it has set the DOM reference.\n    if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.isElement)(position.refs.reference.current) || position.refs.reference.current === null ||\n    // Don't allow setting virtual elements using the old technique back to\n    // `null` to support `positionReference` + an unstable `reference`\n    // callback ref.\n    node !== null && !(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.isElement)(node)) {\n      position.refs.setReference(node);\n    }\n  }, [position.refs]);\n  const refs = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => _objectSpread(_objectSpread({}, position.refs), {}, {\n    setReference,\n    setPositionReference,\n    domReference: domReferenceRef\n  }), [position.refs, setReference, setPositionReference]);\n  const elements = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => _objectSpread(_objectSpread({}, position.elements), {}, {\n    domReference: domReference\n  }), [position.elements, domReference]);\n  const context = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => _objectSpread(_objectSpread({}, position), {}, {\n    refs,\n    elements,\n    dataRef,\n    nodeId,\n    floatingId,\n    events,\n    open,\n    onOpenChange\n  }), [position, nodeId, floatingId, events, open, onOpenChange, refs, elements]);\n  index(() => {\n    const node = tree == null ? void 0 : tree.nodesRef.current.find(node => node.id === nodeId);\n    if (node) {\n      node.context = context;\n    }\n  });\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => _objectSpread(_objectSpread({}, position), {}, {\n    context,\n    refs,\n    elements\n  }), [position, refs, elements, context]);\n}\n\n/**\n * Opens the floating element while the reference element has focus, like CSS\n * `:focus`.\n * @see https://floating-ui.com/docs/useFocus\n */\nfunction useFocus(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    onOpenChange,\n    events,\n    refs,\n    elements: {\n      domReference\n    }\n  } = context;\n  const {\n    enabled = true,\n    visibleOnly = true\n  } = props;\n  const blockFocusRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  const timeoutRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n  const keyboardModalityRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(true);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    const win = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.getWindow)(domReference);\n\n    // If the reference was focused and the user left the tab/window, and the\n    // floating element was not open, the focus should be blocked when they\n    // return to the tab/window.\n    function onBlur() {\n      if (!open && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.isHTMLElement)(domReference) && domReference === (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.activeElement)((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(domReference))) {\n        blockFocusRef.current = true;\n      }\n    }\n    function onKeyDown() {\n      keyboardModalityRef.current = true;\n    }\n    win.addEventListener('blur', onBlur);\n    win.addEventListener('keydown', onKeyDown, true);\n    return () => {\n      win.removeEventListener('blur', onBlur);\n      win.removeEventListener('keydown', onKeyDown, true);\n    };\n  }, [domReference, open, enabled]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    function onOpenChange(_ref) {\n      let {\n        reason\n      } = _ref;\n      if (reason === 'reference-press' || reason === 'escape-key') {\n        blockFocusRef.current = true;\n      }\n    }\n    events.on('openchange', onOpenChange);\n    return () => {\n      events.off('openchange', onOpenChange);\n    };\n  }, [events, enabled]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    return () => {\n      clearTimeout(timeoutRef.current);\n    };\n  }, []);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    return {\n      reference: {\n        onPointerDown(event) {\n          if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isVirtualPointerEvent)(event.nativeEvent)) return;\n          keyboardModalityRef.current = false;\n        },\n        onMouseLeave() {\n          blockFocusRef.current = false;\n        },\n        onFocus(event) {\n          if (blockFocusRef.current) return;\n          const target = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getTarget)(event.nativeEvent);\n          if (visibleOnly && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.isElement)(target)) {\n            try {\n              // Mac Safari unreliably matches `:focus-visible` on the reference\n              // if focus was outside the page initially - use the fallback\n              // instead.\n              if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isSafari)() && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isMac)()) throw Error();\n              if (!target.matches(':focus-visible')) return;\n            } catch (e) {\n              // Old browsers will throw an error when using `:focus-visible`.\n              if (!keyboardModalityRef.current && !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isTypeableElement)(target)) {\n                return;\n              }\n            }\n          }\n          onOpenChange(true, event.nativeEvent, 'focus');\n        },\n        onBlur(event) {\n          blockFocusRef.current = false;\n          const relatedTarget = event.relatedTarget;\n\n          // Hit the non-modal focus management portal guard. Focus will be\n          // moved into the floating element immediately after.\n          const movedToFocusGuard = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.isElement)(relatedTarget) && relatedTarget.hasAttribute(createAttribute('focus-guard')) && relatedTarget.getAttribute('data-type') === 'outside';\n\n          // Wait for the window blur listener to fire.\n          timeoutRef.current = window.setTimeout(() => {\n            const activeEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.activeElement)(domReference ? domReference.ownerDocument : document);\n\n            // Focus left the page, keep it open.\n            if (!relatedTarget && activeEl === domReference) return;\n\n            // When focusing the reference element (e.g. regular click), then\n            // clicking into the floating element, prevent it from hiding.\n            // Note: it must be focusable, e.g. `tabindex=\"-1\"`.\n            // We can not rely on relatedTarget to point to the correct element\n            // as it will only point to the shadow host of the newly focused element\n            // and not the element that actually has received focus if it is located\n            // inside a shadow root.\n            if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(refs.floating.current, activeEl) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(domReference, activeEl) || movedToFocusGuard) {\n              return;\n            }\n            onOpenChange(false, event.nativeEvent, 'focus');\n          });\n        }\n      }\n    };\n  }, [enabled, visibleOnly, domReference, refs, onOpenChange]);\n}\nconst ACTIVE_KEY = 'active';\nconst SELECTED_KEY = 'selected';\nfunction mergeProps(userProps, propsList, elementKey) {\n  const map = new Map();\n  const isItem = elementKey === 'item';\n  let domUserProps = userProps;\n  if (isItem && userProps) {\n    const {\n        [ACTIVE_KEY]: _,\n        [SELECTED_KEY]: __\n      } = userProps,\n      validProps = _objectWithoutProperties(userProps, [ACTIVE_KEY, SELECTED_KEY].map(_toPropertyKey));\n    domUserProps = validProps;\n  }\n  return _objectSpread(_objectSpread(_objectSpread({}, elementKey === 'floating' && {\n    tabIndex: -1\n  }), domUserProps), propsList.map(value => {\n    const propsOrGetProps = value ? value[elementKey] : null;\n    if (typeof propsOrGetProps === 'function') {\n      return userProps ? propsOrGetProps(userProps) : null;\n    }\n    return propsOrGetProps;\n  }).concat(userProps).reduce((acc, props) => {\n    if (!props) {\n      return acc;\n    }\n    Object.entries(props).forEach(_ref => {\n      let [key, value] = _ref;\n      if (isItem && [ACTIVE_KEY, SELECTED_KEY].includes(key)) {\n        return;\n      }\n      if (key.indexOf('on') === 0) {\n        if (!map.has(key)) {\n          map.set(key, []);\n        }\n        if (typeof value === 'function') {\n          var _map$get;\n          (_map$get = map.get(key)) == null || _map$get.push(value);\n          acc[key] = function () {\n            var _map$get2;\n            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n              args[_key] = arguments[_key];\n            }\n            return (_map$get2 = map.get(key)) == null ? void 0 : _map$get2.map(fn => fn(...args)).find(val => val !== undefined);\n          };\n        }\n      } else {\n        acc[key] = value;\n      }\n    });\n    return acc;\n  }, {}));\n}\n\n/**\n * Merges an array of interaction hooks' props into prop getters, allowing\n * event handler functions to be composed together without overwriting one\n * another.\n * @see https://floating-ui.com/docs/useInteractions\n */\nfunction useInteractions(propsList) {\n  if (propsList === void 0) {\n    propsList = [];\n  }\n  // The dependencies are a dynamic array, so we can't use the linter's\n  // suggestion to add it to the deps array.\n  const deps = propsList;\n\n  // biome-ignore lint/correctness/useExhaustiveDependencies: intentional\n  const getReferenceProps = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(userProps => mergeProps(userProps, propsList, 'reference'), deps);\n\n  // biome-ignore lint/correctness/useExhaustiveDependencies: intentional\n  const getFloatingProps = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(userProps => mergeProps(userProps, propsList, 'floating'), deps);\n\n  // biome-ignore lint/correctness/useExhaustiveDependencies: intentional\n  const getItemProps = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(userProps => mergeProps(userProps, propsList, 'item'),\n  // Granularly check for `item` changes, because the `getItemProps` getter\n  // should be as referentially stable as possible since it may be passed as\n  // a prop to many components. All `item` key values must therefore be\n  // memoized.\n  propsList.map(key => key == null ? void 0 : key.item));\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    getReferenceProps,\n    getFloatingProps,\n    getItemProps\n  }), [getReferenceProps, getFloatingProps, getItemProps]);\n}\nlet isPreventScrollSupported = false;\nfunction doSwitch(orientation, vertical, horizontal) {\n  switch (orientation) {\n    case 'vertical':\n      return vertical;\n    case 'horizontal':\n      return horizontal;\n    default:\n      return vertical || horizontal;\n  }\n}\nfunction isMainOrientationKey(key, orientation) {\n  const vertical = key === ARROW_UP || key === ARROW_DOWN;\n  const horizontal = key === ARROW_LEFT || key === ARROW_RIGHT;\n  return doSwitch(orientation, vertical, horizontal);\n}\nfunction isMainOrientationToEndKey(key, orientation, rtl) {\n  const vertical = key === ARROW_DOWN;\n  const horizontal = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;\n  return doSwitch(orientation, vertical, horizontal) || key === 'Enter' || key === ' ' || key === '';\n}\nfunction isCrossOrientationOpenKey(key, orientation, rtl) {\n  const vertical = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;\n  const horizontal = key === ARROW_DOWN;\n  return doSwitch(orientation, vertical, horizontal);\n}\nfunction isCrossOrientationCloseKey(key, orientation, rtl) {\n  const vertical = rtl ? key === ARROW_RIGHT : key === ARROW_LEFT;\n  const horizontal = key === ARROW_UP;\n  return doSwitch(orientation, vertical, horizontal);\n}\n/**\n * Adds arrow key-based navigation of a list of items, either using real DOM\n * focus or virtual focus.\n * @see https://floating-ui.com/docs/useListNavigation\n */\nfunction useListNavigation(context, props) {\n  const {\n    open,\n    onOpenChange,\n    refs,\n    elements: {\n      domReference,\n      floating\n    }\n  } = context;\n  const {\n    listRef,\n    activeIndex,\n    onNavigate: unstable_onNavigate = () => {},\n    enabled = true,\n    selectedIndex = null,\n    allowEscape = false,\n    loop = false,\n    nested = false,\n    rtl = false,\n    virtual = false,\n    focusItemOnOpen = 'auto',\n    focusItemOnHover = true,\n    openOnArrowKeyDown = true,\n    disabledIndices = undefined,\n    orientation = 'vertical',\n    cols = 1,\n    scrollItemIntoView = true,\n    virtualItemRef,\n    itemSizes,\n    dense = false\n  } = props;\n  if (true) {\n    if (allowEscape) {\n      if (!loop) {\n        console.warn(['Floating UI: `useListNavigation` looping must be enabled to allow', 'escaping.'].join(' '));\n      }\n      if (!virtual) {\n        console.warn(['Floating UI: `useListNavigation` must be virtual to allow', 'escaping.'].join(' '));\n      }\n    }\n    if (orientation === 'vertical' && cols > 1) {\n      console.warn(['Floating UI: In grid list navigation mode (`cols` > 1), the', '`orientation` should be either \"horizontal\" or \"both\".'].join(' '));\n    }\n  }\n  const parentId = useFloatingParentNodeId();\n  const tree = useFloatingTree();\n  const onNavigate = useEffectEvent(unstable_onNavigate);\n  const focusItemOnOpenRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(focusItemOnOpen);\n  const indexRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(selectedIndex != null ? selectedIndex : -1);\n  const keyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const isPointerModalityRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(true);\n  const previousOnNavigateRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(onNavigate);\n  const previousMountedRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(!!floating);\n  const forceSyncFocus = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  const forceScrollIntoViewRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  const disabledIndicesRef = useLatestRef(disabledIndices);\n  const latestOpenRef = useLatestRef(open);\n  const scrollItemIntoViewRef = useLatestRef(scrollItemIntoView);\n  const [activeId, setActiveId] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n  const [virtualId, setVirtualId] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n  const focusItem = useEffectEvent(function (listRef, indexRef, forceScrollIntoView) {\n    if (forceScrollIntoView === void 0) {\n      forceScrollIntoView = false;\n    }\n    const item = listRef.current[indexRef.current];\n    if (!item) return;\n    if (virtual) {\n      setActiveId(item.id);\n      tree == null || tree.events.emit('virtualfocus', item);\n      if (virtualItemRef) {\n        virtualItemRef.current = item;\n      }\n    } else {\n      enqueueFocus(item, {\n        preventScroll: true,\n        // Mac Safari does not move the virtual cursor unless the focus call\n        // is sync. However, for the very first focus call, we need to wait\n        // for the position to be ready in order to prevent unwanted\n        // scrolling. This means the virtual cursor will not move to the first\n        // item when first opening the floating element, but will on\n        // subsequent calls. `preventScroll` is supported in modern Safari,\n        // so we can use that instead.\n        // iOS Safari must be async or the first item will not be focused.\n        sync: (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isMac)() && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isSafari)() ? isPreventScrollSupported || forceSyncFocus.current : false\n      });\n    }\n    requestAnimationFrame(() => {\n      const scrollIntoViewOptions = scrollItemIntoViewRef.current;\n      const shouldScrollIntoView = scrollIntoViewOptions && item && (forceScrollIntoView || !isPointerModalityRef.current);\n      if (shouldScrollIntoView) {\n        // JSDOM doesn't support `.scrollIntoView()` but it's widely supported\n        // by all browsers.\n        item.scrollIntoView == null || item.scrollIntoView(typeof scrollIntoViewOptions === 'boolean' ? {\n          block: 'nearest',\n          inline: 'nearest'\n        } : scrollIntoViewOptions);\n      }\n    });\n  });\n  index(() => {\n    document.createElement('div').focus({\n      get preventScroll() {\n        isPreventScrollSupported = true;\n        return false;\n      }\n    });\n  }, []);\n\n  // Sync `selectedIndex` to be the `activeIndex` upon opening the floating\n  // element. Also, reset `activeIndex` upon closing the floating element.\n  index(() => {\n    if (!enabled) {\n      return;\n    }\n    if (open && floating) {\n      if (focusItemOnOpenRef.current && selectedIndex != null) {\n        // Regardless of the pointer modality, we want to ensure the selected\n        // item comes into view when the floating element is opened.\n        forceScrollIntoViewRef.current = true;\n        indexRef.current = selectedIndex;\n        onNavigate(selectedIndex);\n      }\n    } else if (previousMountedRef.current) {\n      // Since the user can specify `onNavigate` conditionally\n      // (onNavigate: open ? setActiveIndex : setSelectedIndex),\n      // we store and call the previous function.\n      indexRef.current = -1;\n      previousOnNavigateRef.current(null);\n    }\n  }, [enabled, open, floating, selectedIndex, onNavigate]);\n\n  // Sync `activeIndex` to be the focused item while the floating element is\n  // open.\n  index(() => {\n    if (!enabled) {\n      return;\n    }\n    if (open && floating) {\n      if (activeIndex == null) {\n        forceSyncFocus.current = false;\n        if (selectedIndex != null) {\n          return;\n        }\n\n        // Reset while the floating element was open (e.g. the list changed).\n        if (previousMountedRef.current) {\n          indexRef.current = -1;\n          focusItem(listRef, indexRef);\n        }\n\n        // Initial sync.\n        if (!previousMountedRef.current && focusItemOnOpenRef.current && (keyRef.current != null || focusItemOnOpenRef.current === true && keyRef.current == null)) {\n          let runs = 0;\n          const waitForListPopulated = () => {\n            if (listRef.current[0] == null) {\n              // Avoid letting the browser paint if possible on the first try,\n              // otherwise use rAF. Don't try more than twice, since something\n              // is wrong otherwise.\n              if (runs < 2) {\n                const scheduler = runs ? requestAnimationFrame : queueMicrotask;\n                scheduler(waitForListPopulated);\n              }\n              runs++;\n            } else {\n              indexRef.current = keyRef.current == null || isMainOrientationToEndKey(keyRef.current, orientation, rtl) || nested ? getMinIndex(listRef, disabledIndicesRef.current) : getMaxIndex(listRef, disabledIndicesRef.current);\n              keyRef.current = null;\n              onNavigate(indexRef.current);\n            }\n          };\n          waitForListPopulated();\n        }\n      } else if (!isIndexOutOfBounds(listRef, activeIndex)) {\n        indexRef.current = activeIndex;\n        focusItem(listRef, indexRef, forceScrollIntoViewRef.current);\n        forceScrollIntoViewRef.current = false;\n      }\n    }\n  }, [enabled, open, floating, activeIndex, selectedIndex, nested, listRef, orientation, rtl, onNavigate, focusItem, disabledIndicesRef]);\n\n  // Ensure the parent floating element has focus when a nested child closes\n  // to allow arrow key navigation to work after the pointer leaves the child.\n  index(() => {\n    var _nodes$find;\n    if (!enabled || floating || !tree || virtual || !previousMountedRef.current) {\n      return;\n    }\n    const nodes = tree.nodesRef.current;\n    const parent = (_nodes$find = nodes.find(node => node.id === parentId)) == null || (_nodes$find = _nodes$find.context) == null ? void 0 : _nodes$find.elements.floating;\n    const activeEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.activeElement)((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(floating));\n    const treeContainsActiveEl = nodes.some(node => node.context && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(node.context.elements.floating, activeEl));\n    if (parent && !treeContainsActiveEl && isPointerModalityRef.current) {\n      parent.focus({\n        preventScroll: true\n      });\n    }\n  }, [enabled, floating, tree, parentId, virtual]);\n  index(() => {\n    if (!enabled || !tree || !virtual || parentId) return;\n    function handleVirtualFocus(item) {\n      setVirtualId(item.id);\n      if (virtualItemRef) {\n        virtualItemRef.current = item;\n      }\n    }\n    tree.events.on('virtualfocus', handleVirtualFocus);\n    return () => {\n      tree.events.off('virtualfocus', handleVirtualFocus);\n    };\n  }, [enabled, tree, virtual, parentId, virtualItemRef]);\n  index(() => {\n    previousOnNavigateRef.current = onNavigate;\n    previousMountedRef.current = !!floating;\n  });\n  index(() => {\n    if (!open) {\n      keyRef.current = null;\n    }\n  }, [open]);\n  const hasActiveIndex = activeIndex != null;\n  const item = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    function syncCurrentTarget(currentTarget) {\n      if (!open) return;\n      const index = listRef.current.indexOf(currentTarget);\n      if (index !== -1) {\n        onNavigate(index);\n      }\n    }\n    const props = _objectSpread({\n      onFocus(_ref) {\n        let {\n          currentTarget\n        } = _ref;\n        syncCurrentTarget(currentTarget);\n      },\n      onClick: _ref2 => {\n        let {\n          currentTarget\n        } = _ref2;\n        return currentTarget.focus({\n          preventScroll: true\n        });\n      }\n    }, focusItemOnHover && {\n      onMouseMove(_ref3) {\n        let {\n          currentTarget\n        } = _ref3;\n        syncCurrentTarget(currentTarget);\n      },\n      onPointerLeave(_ref4) {\n        let {\n          pointerType\n        } = _ref4;\n        if (!isPointerModalityRef.current || pointerType === 'touch') {\n          return;\n        }\n        indexRef.current = -1;\n        focusItem(listRef, indexRef);\n        onNavigate(null);\n        if (!virtual) {\n          enqueueFocus(refs.floating.current, {\n            preventScroll: true\n          });\n        }\n      }\n    });\n    return props;\n  }, [open, refs, focusItem, focusItemOnHover, listRef, onNavigate, virtual]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    const disabledIndices = disabledIndicesRef.current;\n    function onKeyDown(event) {\n      isPointerModalityRef.current = false;\n      forceSyncFocus.current = true;\n\n      // If the floating element is animating out, ignore navigation. Otherwise,\n      // the `activeIndex` gets set to 0 despite not being open so the next time\n      // the user ArrowDowns, the first item won't be focused.\n      if (!latestOpenRef.current && event.currentTarget === refs.floating.current) {\n        return;\n      }\n      if (nested && isCrossOrientationCloseKey(event.key, orientation, rtl)) {\n        (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n        onOpenChange(false, event.nativeEvent, 'list-navigation');\n        if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.isHTMLElement)(domReference) && !virtual) {\n          domReference.focus();\n        }\n        return;\n      }\n      const currentIndex = indexRef.current;\n      const minIndex = getMinIndex(listRef, disabledIndices);\n      const maxIndex = getMaxIndex(listRef, disabledIndices);\n      if (event.key === 'Home') {\n        (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n        indexRef.current = minIndex;\n        onNavigate(indexRef.current);\n      }\n      if (event.key === 'End') {\n        (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n        indexRef.current = maxIndex;\n        onNavigate(indexRef.current);\n      }\n\n      // Grid navigation.\n      if (cols > 1) {\n        const sizes = itemSizes || Array.from({\n          length: listRef.current.length\n        }, () => ({\n          width: 1,\n          height: 1\n        }));\n        // To calculate movements on the grid, we use hypothetical cell indices\n        // as if every item was 1x1, then convert back to real indices.\n        const cellMap = buildCellMap(sizes, cols, dense);\n        const minGridIndex = cellMap.findIndex(index => index != null && !(disabledIndices != null && disabledIndices.includes(index)));\n        // last enabled index\n        const maxGridIndex = cellMap.reduce((foundIndex, index, cellIndex) => index != null && !(disabledIndices != null && disabledIndices.includes(index)) ? cellIndex : foundIndex, -1);\n        indexRef.current = cellMap[getGridNavigatedIndex({\n          current: cellMap.map(itemIndex => itemIndex != null ? listRef.current[itemIndex] : null)\n        }, {\n          event,\n          orientation,\n          loop,\n          cols,\n          // treat undefined (empty grid spaces) as disabled indices so we\n          // don't end up in them\n          disabledIndices: getCellIndices([...(disabledIndices || []), undefined], cellMap),\n          minIndex: minGridIndex,\n          maxIndex: maxGridIndex,\n          prevIndex: getCellIndexOfCorner(indexRef.current, sizes, cellMap, cols,\n          // use a corner matching the edge closest to the direction\n          // we're moving in so we don't end up in the same item. Prefer\n          // top/left over bottom/right.\n          event.key === ARROW_DOWN ? 'bl' : event.key === ARROW_RIGHT ? 'tr' : 'tl'),\n          stopEvent: true\n        })]; // navigated cell will never be nullish\n\n        onNavigate(indexRef.current);\n        if (orientation === 'both') {\n          return;\n        }\n      }\n      if (isMainOrientationKey(event.key, orientation)) {\n        (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n\n        // Reset the index if no item is focused.\n        if (open && !virtual && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.activeElement)(event.currentTarget.ownerDocument) === event.currentTarget) {\n          indexRef.current = isMainOrientationToEndKey(event.key, orientation, rtl) ? minIndex : maxIndex;\n          onNavigate(indexRef.current);\n          return;\n        }\n        if (isMainOrientationToEndKey(event.key, orientation, rtl)) {\n          if (loop) {\n            indexRef.current = currentIndex >= maxIndex ? allowEscape && currentIndex !== listRef.current.length ? -1 : minIndex : findNonDisabledIndex(listRef, {\n              startingIndex: currentIndex,\n              disabledIndices\n            });\n          } else {\n            indexRef.current = Math.min(maxIndex, findNonDisabledIndex(listRef, {\n              startingIndex: currentIndex,\n              disabledIndices\n            }));\n          }\n        } else {\n          if (loop) {\n            indexRef.current = currentIndex <= minIndex ? allowEscape && currentIndex !== -1 ? listRef.current.length : maxIndex : findNonDisabledIndex(listRef, {\n              startingIndex: currentIndex,\n              decrement: true,\n              disabledIndices\n            });\n          } else {\n            indexRef.current = Math.max(minIndex, findNonDisabledIndex(listRef, {\n              startingIndex: currentIndex,\n              decrement: true,\n              disabledIndices\n            }));\n          }\n        }\n        if (isIndexOutOfBounds(listRef, indexRef.current)) {\n          onNavigate(null);\n        } else {\n          onNavigate(indexRef.current);\n        }\n      }\n    }\n    function checkVirtualMouse(event) {\n      if (focusItemOnOpen === 'auto' && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isVirtualClick)(event.nativeEvent)) {\n        focusItemOnOpenRef.current = true;\n      }\n    }\n    function checkVirtualPointer(event) {\n      // `pointerdown` fires first, reset the state then perform the checks.\n      focusItemOnOpenRef.current = focusItemOnOpen;\n      if (focusItemOnOpen === 'auto' && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isVirtualPointerEvent)(event.nativeEvent)) {\n        focusItemOnOpenRef.current = true;\n      }\n    }\n    const ariaActiveDescendantProp = virtual && open && hasActiveIndex && {\n      'aria-activedescendant': virtualId || activeId\n    };\n    const activeItem = listRef.current.find(item => (item == null ? void 0 : item.id) === activeId);\n    return {\n      reference: _objectSpread(_objectSpread({}, ariaActiveDescendantProp), {}, {\n        onKeyDown(event) {\n          isPointerModalityRef.current = false;\n          const isArrowKey = event.key.indexOf('Arrow') === 0;\n          const isCrossOpenKey = isCrossOrientationOpenKey(event.key, orientation, rtl);\n          const isCrossCloseKey = isCrossOrientationCloseKey(event.key, orientation, rtl);\n          const isMainKey = isMainOrientationKey(event.key, orientation);\n          const isNavigationKey = (nested ? isCrossOpenKey : isMainKey) || event.key === 'Enter' || event.key.trim() === '';\n          if (virtual && open) {\n            const rootNode = tree == null ? void 0 : tree.nodesRef.current.find(node => node.parentId == null);\n            const deepestNode = tree && rootNode ? getDeepestNode(tree.nodesRef.current, rootNode.id) : null;\n            if (isArrowKey && deepestNode && virtualItemRef) {\n              const eventObject = new KeyboardEvent('keydown', {\n                key: event.key,\n                bubbles: true\n              });\n              if (isCrossOpenKey || isCrossCloseKey) {\n                var _deepestNode$context, _deepestNode$context2;\n                const isCurrentTarget = ((_deepestNode$context = deepestNode.context) == null ? void 0 : _deepestNode$context.elements.domReference) === event.currentTarget;\n                const dispatchItem = isCrossCloseKey && !isCurrentTarget ? (_deepestNode$context2 = deepestNode.context) == null ? void 0 : _deepestNode$context2.elements.domReference : isCrossOpenKey ? activeItem : null;\n                if (dispatchItem) {\n                  (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n                  dispatchItem.dispatchEvent(eventObject);\n                  setVirtualId(undefined);\n                }\n              }\n              if (isMainKey && deepestNode.context) {\n                if (deepestNode.context.open && deepestNode.parentId && event.currentTarget !== deepestNode.context.elements.domReference) {\n                  var _deepestNode$context$;\n                  (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n                  (_deepestNode$context$ = deepestNode.context.elements.domReference) == null || _deepestNode$context$.dispatchEvent(eventObject);\n                  return;\n                }\n              }\n            }\n            return onKeyDown(event);\n          }\n\n          // If a floating element should not open on arrow key down, avoid\n          // setting `activeIndex` while it's closed.\n          if (!open && !openOnArrowKeyDown && isArrowKey) {\n            return;\n          }\n          if (isNavigationKey) {\n            keyRef.current = nested && isMainKey ? null : event.key;\n          }\n          if (nested) {\n            if (isCrossOpenKey) {\n              (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n              if (open) {\n                indexRef.current = getMinIndex(listRef, disabledIndices);\n                onNavigate(indexRef.current);\n              } else {\n                onOpenChange(true, event.nativeEvent, 'list-navigation');\n              }\n            }\n            return;\n          }\n          if (isMainKey) {\n            if (selectedIndex != null) {\n              indexRef.current = selectedIndex;\n            }\n            (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n            if (!open && openOnArrowKeyDown) {\n              onOpenChange(true, event.nativeEvent, 'list-navigation');\n            } else {\n              onKeyDown(event);\n            }\n            if (open) {\n              onNavigate(indexRef.current);\n            }\n          }\n        },\n        onFocus() {\n          if (open) {\n            onNavigate(null);\n          }\n        },\n        onPointerDown: checkVirtualPointer,\n        onMouseDown: checkVirtualMouse,\n        onClick: checkVirtualMouse\n      }),\n      floating: _objectSpread(_objectSpread({\n        'aria-orientation': orientation === 'both' ? undefined : orientation\n      }, !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isTypeableCombobox)(domReference) && ariaActiveDescendantProp), {}, {\n        onKeyDown,\n        onPointerMove() {\n          isPointerModalityRef.current = true;\n        }\n      }),\n      item\n    };\n  }, [domReference, refs, activeId, virtualId, disabledIndicesRef, latestOpenRef, listRef, enabled, orientation, rtl, virtual, open, hasActiveIndex, nested, selectedIndex, openOnArrowKeyDown, allowEscape, cols, loop, focusItemOnOpen, onNavigate, onOpenChange, item, tree, virtualItemRef, itemSizes, dense]);\n}\nconst componentRoleToAriaRoleMap = /*#__PURE__*/new Map([['select', 'listbox'], ['combobox', 'listbox'], ['label', false]]);\n\n/**\n * Adds base screen reader props to the reference and floating elements for a\n * given floating element `role`.\n * @see https://floating-ui.com/docs/useRole\n */\nfunction useRole(context, props) {\n  var _componentRoleToAriaR;\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    floatingId\n  } = context;\n  const {\n    enabled = true,\n    role = 'dialog'\n  } = props;\n  const ariaRole = (_componentRoleToAriaR = componentRoleToAriaRoleMap.get(role)) != null ? _componentRoleToAriaR : role;\n  const referenceId = useId();\n  const parentId = useFloatingParentNodeId();\n  const isNested = parentId != null;\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    if (!enabled) return {};\n    const floatingProps = _objectSpread({\n      id: floatingId\n    }, ariaRole && {\n      role: ariaRole\n    });\n    if (ariaRole === 'tooltip' || role === 'label') {\n      return {\n        reference: {\n          [\"aria-\" + (role === 'label' ? 'labelledby' : 'describedby')]: open ? floatingId : undefined\n        },\n        floating: floatingProps\n      };\n    }\n    return {\n      reference: _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({\n        'aria-expanded': open ? 'true' : 'false',\n        'aria-haspopup': ariaRole === 'alertdialog' ? 'dialog' : ariaRole,\n        'aria-controls': open ? floatingId : undefined\n      }, ariaRole === 'listbox' && {\n        role: 'combobox'\n      }), ariaRole === 'menu' && {\n        id: referenceId\n      }), ariaRole === 'menu' && isNested && {\n        role: 'menuitem'\n      }), role === 'select' && {\n        'aria-autocomplete': 'none'\n      }), role === 'combobox' && {\n        'aria-autocomplete': 'list'\n      }),\n      floating: _objectSpread(_objectSpread({}, floatingProps), ariaRole === 'menu' && {\n        'aria-labelledby': referenceId\n      }),\n      item(_ref) {\n        let {\n          active,\n          selected\n        } = _ref;\n        const commonProps = _objectSpread({\n          role: 'option'\n        }, active && {\n          id: floatingId + \"-option\"\n        });\n\n        // For `menu`, we are unable to tell if the item is a `menuitemradio`\n        // or `menuitemcheckbox`. For backwards-compatibility reasons, also\n        // avoid defaulting to `menuitem` as it may overwrite custom role props.\n        switch (role) {\n          case 'select':\n            return _objectSpread(_objectSpread({}, commonProps), {}, {\n              'aria-selected': active && selected\n            });\n          case 'combobox':\n            {\n              return _objectSpread(_objectSpread({}, commonProps), active && {\n                'aria-selected': true\n              });\n            }\n        }\n        return {};\n      }\n    };\n  }, [enabled, role, ariaRole, open, floatingId, referenceId, isNested]);\n}\n\n// Converts a JS style key like `backgroundColor` to a CSS transition-property\n// like `background-color`.\nconst camelCaseToKebabCase = str => str.replace(/[A-Z]+(?![a-z])|[A-Z]/g, ($, ofs) => (ofs ? '-' : '') + $.toLowerCase());\nfunction execWithArgsOrReturn(valueOrFn, args) {\n  return typeof valueOrFn === 'function' ? valueOrFn(args) : valueOrFn;\n}\nfunction useDelayUnmount(open, durationMs) {\n  const [isMounted, setIsMounted] = react__WEBPACK_IMPORTED_MODULE_0__.useState(open);\n  if (open && !isMounted) {\n    setIsMounted(true);\n  }\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!open) {\n      const timeout = setTimeout(() => setIsMounted(false), durationMs);\n      return () => clearTimeout(timeout);\n    }\n  }, [open, durationMs]);\n  return isMounted;\n}\n/**\n * Provides a status string to apply CSS transitions to a floating element,\n * correctly handling placement-aware transitions.\n * @see https://floating-ui.com/docs/useTransition#usetransitionstatus\n */\nfunction useTransitionStatus(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    elements: {\n      floating\n    }\n  } = context;\n  const {\n    duration = 250\n  } = props;\n  const isNumberDuration = typeof duration === 'number';\n  const closeDuration = (isNumberDuration ? duration : duration.close) || 0;\n  const [initiated, setInitiated] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n  const [status, setStatus] = react__WEBPACK_IMPORTED_MODULE_0__.useState('unmounted');\n  const isMounted = useDelayUnmount(open, closeDuration);\n\n  // `initiated` check prevents this `setState` call from breaking\n  // <FloatingPortal />. This call is necessary to ensure subsequent opens\n  // after the initial one allows the correct side animation to play when the\n  // placement has changed.\n  index(() => {\n    if (initiated && !isMounted) {\n      setStatus('unmounted');\n    }\n  }, [initiated, isMounted]);\n  index(() => {\n    if (!floating) return;\n    if (open) {\n      setStatus('initial');\n      const frame = requestAnimationFrame(() => {\n        setStatus('open');\n      });\n      return () => {\n        cancelAnimationFrame(frame);\n      };\n    }\n    setInitiated(true);\n    setStatus('close');\n  }, [open, floating]);\n  return {\n    isMounted,\n    status\n  };\n}\n/**\n * Provides styles to apply CSS transitions to a floating element, correctly\n * handling placement-aware transitions. Wrapper around `useTransitionStatus`.\n * @see https://floating-ui.com/docs/useTransition#usetransitionstyles\n */\nfunction useTransitionStyles(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    initial: unstable_initial = {\n      opacity: 0\n    },\n    open: unstable_open,\n    close: unstable_close,\n    common: unstable_common,\n    duration = 250\n  } = props;\n  const placement = context.placement;\n  const side = placement.split('-')[0];\n  const fnArgs = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    side,\n    placement\n  }), [side, placement]);\n  const isNumberDuration = typeof duration === 'number';\n  const openDuration = (isNumberDuration ? duration : duration.open) || 0;\n  const closeDuration = (isNumberDuration ? duration : duration.close) || 0;\n  const [styles, setStyles] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => _objectSpread(_objectSpread({}, execWithArgsOrReturn(unstable_common, fnArgs)), execWithArgsOrReturn(unstable_initial, fnArgs)));\n  const {\n    isMounted,\n    status\n  } = useTransitionStatus(context, {\n    duration\n  });\n  const initialRef = useLatestRef(unstable_initial);\n  const openRef = useLatestRef(unstable_open);\n  const closeRef = useLatestRef(unstable_close);\n  const commonRef = useLatestRef(unstable_common);\n  index(() => {\n    const initialStyles = execWithArgsOrReturn(initialRef.current, fnArgs);\n    const closeStyles = execWithArgsOrReturn(closeRef.current, fnArgs);\n    const commonStyles = execWithArgsOrReturn(commonRef.current, fnArgs);\n    const openStyles = execWithArgsOrReturn(openRef.current, fnArgs) || Object.keys(initialStyles).reduce((acc, key) => {\n      acc[key] = '';\n      return acc;\n    }, {});\n    if (status === 'initial') {\n      setStyles(styles => _objectSpread(_objectSpread({\n        transitionProperty: styles.transitionProperty\n      }, commonStyles), initialStyles));\n    }\n    if (status === 'open') {\n      setStyles(_objectSpread(_objectSpread({\n        transitionProperty: Object.keys(openStyles).map(camelCaseToKebabCase).join(','),\n        transitionDuration: openDuration + \"ms\"\n      }, commonStyles), openStyles));\n    }\n    if (status === 'close') {\n      const styles = closeStyles || initialStyles;\n      setStyles(_objectSpread(_objectSpread({\n        transitionProperty: Object.keys(styles).map(camelCaseToKebabCase).join(','),\n        transitionDuration: closeDuration + \"ms\"\n      }, commonStyles), styles));\n    }\n  }, [closeDuration, closeRef, initialRef, openRef, commonRef, openDuration, status, fnArgs]);\n  return {\n    isMounted,\n    styles\n  };\n}\n\n/**\n * Provides a matching callback that can be used to focus an item as the user\n * types, often used in tandem with `useListNavigation()`.\n * @see https://floating-ui.com/docs/useTypeahead\n */\nfunction useTypeahead(context, props) {\n  var _ref;\n  const {\n    open,\n    dataRef\n  } = context;\n  const {\n    listRef,\n    activeIndex,\n    onMatch: unstable_onMatch,\n    onTypingChange: unstable_onTypingChange,\n    enabled = true,\n    findMatch = null,\n    resetMs = 750,\n    ignoreKeys = [],\n    selectedIndex = null\n  } = props;\n  const timeoutIdRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n  const stringRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef('');\n  const prevIndexRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef((_ref = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref : -1);\n  const matchIndexRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const onMatch = useEffectEvent(unstable_onMatch);\n  const onTypingChange = useEffectEvent(unstable_onTypingChange);\n  const findMatchRef = useLatestRef(findMatch);\n  const ignoreKeysRef = useLatestRef(ignoreKeys);\n  index(() => {\n    if (open) {\n      clearTimeout(timeoutIdRef.current);\n      matchIndexRef.current = null;\n      stringRef.current = '';\n    }\n  }, [open]);\n  index(() => {\n    // Sync arrow key navigation but not typeahead navigation.\n    if (open && stringRef.current === '') {\n      var _ref2;\n      prevIndexRef.current = (_ref2 = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref2 : -1;\n    }\n  }, [open, selectedIndex, activeIndex]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    function setTypingChange(value) {\n      if (value) {\n        if (!dataRef.current.typing) {\n          dataRef.current.typing = value;\n          onTypingChange(value);\n        }\n      } else {\n        if (dataRef.current.typing) {\n          dataRef.current.typing = value;\n          onTypingChange(value);\n        }\n      }\n    }\n    function getMatchingIndex(list, orderedList, string) {\n      const str = findMatchRef.current ? findMatchRef.current(orderedList, string) : orderedList.find(text => (text == null ? void 0 : text.toLocaleLowerCase().indexOf(string.toLocaleLowerCase())) === 0);\n      return str ? list.indexOf(str) : -1;\n    }\n    function onKeyDown(event) {\n      const listContent = listRef.current;\n      if (stringRef.current.length > 0 && stringRef.current[0] !== ' ') {\n        if (getMatchingIndex(listContent, listContent, stringRef.current) === -1) {\n          setTypingChange(false);\n        } else if (event.key === ' ') {\n          (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n        }\n      }\n      if (listContent == null || ignoreKeysRef.current.includes(event.key) ||\n      // Character key.\n      event.key.length !== 1 ||\n      // Modifier key.\n      event.ctrlKey || event.metaKey || event.altKey) {\n        return;\n      }\n      if (open && event.key !== ' ') {\n        (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n        setTypingChange(true);\n      }\n\n      // Bail out if the list contains a word like \"llama\" or \"aaron\". TODO:\n      // allow it in this case, too.\n      const allowRapidSuccessionOfFirstLetter = listContent.every(text => {\n        var _text$, _text$2;\n        return text ? ((_text$ = text[0]) == null ? void 0 : _text$.toLocaleLowerCase()) !== ((_text$2 = text[1]) == null ? void 0 : _text$2.toLocaleLowerCase()) : true;\n      });\n\n      // Allows the user to cycle through items that start with the same letter\n      // in rapid succession.\n      if (allowRapidSuccessionOfFirstLetter && stringRef.current === event.key) {\n        stringRef.current = '';\n        prevIndexRef.current = matchIndexRef.current;\n      }\n      stringRef.current += event.key;\n      clearTimeout(timeoutIdRef.current);\n      timeoutIdRef.current = setTimeout(() => {\n        stringRef.current = '';\n        prevIndexRef.current = matchIndexRef.current;\n        setTypingChange(false);\n      }, resetMs);\n      const prevIndex = prevIndexRef.current;\n      const index = getMatchingIndex(listContent, [...listContent.slice((prevIndex || 0) + 1), ...listContent.slice(0, (prevIndex || 0) + 1)], stringRef.current);\n      if (index !== -1) {\n        onMatch(index);\n        matchIndexRef.current = index;\n      } else if (event.key !== ' ') {\n        stringRef.current = '';\n        setTypingChange(false);\n      }\n    }\n    return {\n      reference: {\n        onKeyDown\n      },\n      floating: {\n        onKeyDown,\n        onKeyUp(event) {\n          if (event.key === ' ') {\n            setTypingChange(false);\n          }\n        }\n      }\n    };\n  }, [enabled, open, dataRef, listRef, resetMs, ignoreKeysRef, findMatchRef, onMatch, onTypingChange]);\n}\nfunction getArgsWithCustomFloatingHeight(state, height) {\n  return _objectSpread(_objectSpread({}, state), {}, {\n    rects: _objectSpread(_objectSpread({}, state.rects), {}, {\n      floating: _objectSpread(_objectSpread({}, state.rects.floating), {}, {\n        height\n      })\n    })\n  });\n}\n/**\n * Positions the floating element such that an inner element inside\n * of it is anchored to the reference element.\n * @see https://floating-ui.com/docs/inner\n */\nconst inner = props => ({\n  name: 'inner',\n  options: props,\n  async fn(state) {\n    const {\n        listRef,\n        overflowRef,\n        onFallbackChange,\n        offset: innerOffset = 0,\n        index = 0,\n        minItemsVisible = 4,\n        referenceOverflowThreshold = 0,\n        scrollRef\n      } = props,\n      detectOverflowOptions = _objectWithoutProperties(props, _excluded6);\n    const {\n      rects,\n      elements: {\n        floating\n      }\n    } = state;\n    const item = listRef.current[index];\n    if (true) {\n      if (!state.placement.startsWith('bottom')) {\n        console.warn(['Floating UI: `placement` side must be \"bottom\" when using the', '`inner` middleware.'].join(' '));\n      }\n    }\n    if (!item) {\n      return {};\n    }\n    const nextArgs = _objectSpread(_objectSpread({}, state), await (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_1__.offset)(-item.offsetTop - floating.clientTop - rects.reference.height / 2 - item.offsetHeight / 2 - innerOffset).fn(state));\n    const el = (scrollRef == null ? void 0 : scrollRef.current) || floating;\n    const overflow = await (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.detectOverflow)(getArgsWithCustomFloatingHeight(nextArgs, el.scrollHeight), detectOverflowOptions);\n    const refOverflow = await (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.detectOverflow)(nextArgs, _objectSpread(_objectSpread({}, detectOverflowOptions), {}, {\n      elementContext: 'reference'\n    }));\n    const diffY = Math.max(0, overflow.top);\n    const nextY = nextArgs.y + diffY;\n    const maxHeight = Math.max(0, el.scrollHeight - diffY - Math.max(0, overflow.bottom));\n    el.style.maxHeight = maxHeight + \"px\";\n    el.scrollTop = diffY;\n\n    // There is not enough space, fallback to standard anchored positioning\n    if (onFallbackChange) {\n      if (el.offsetHeight < item.offsetHeight * Math.min(minItemsVisible, listRef.current.length - 1) - 1 || refOverflow.top >= -referenceOverflowThreshold || refOverflow.bottom >= -referenceOverflowThreshold) {\n        (0,react_dom__WEBPACK_IMPORTED_MODULE_4__.flushSync)(() => onFallbackChange(true));\n      } else {\n        (0,react_dom__WEBPACK_IMPORTED_MODULE_4__.flushSync)(() => onFallbackChange(false));\n      }\n    }\n    if (overflowRef) {\n      overflowRef.current = await (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.detectOverflow)(getArgsWithCustomFloatingHeight(_objectSpread(_objectSpread({}, nextArgs), {}, {\n        y: nextY\n      }), el.offsetHeight), detectOverflowOptions);\n    }\n    return {\n      y: nextY\n    };\n  }\n});\n/**\n * Changes the `inner` middleware's `offset` upon a `wheel` event to\n * expand the floating element's height, revealing more list items.\n * @see https://floating-ui.com/docs/inner\n */\nfunction useInnerOffset(context, props) {\n  const {\n    open,\n    elements\n  } = context;\n  const {\n    enabled = true,\n    overflowRef,\n    scrollRef,\n    onChange: unstable_onChange\n  } = props;\n  const onChange = useEffectEvent(unstable_onChange);\n  const controlledScrollingRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  const prevScrollTopRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const initialOverflowRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    function onWheel(e) {\n      if (e.ctrlKey || !el || overflowRef.current == null) {\n        return;\n      }\n      const dY = e.deltaY;\n      const isAtTop = overflowRef.current.top >= -0.5;\n      const isAtBottom = overflowRef.current.bottom >= -0.5;\n      const remainingScroll = el.scrollHeight - el.clientHeight;\n      const sign = dY < 0 ? -1 : 1;\n      const method = dY < 0 ? 'max' : 'min';\n      if (el.scrollHeight <= el.clientHeight) {\n        return;\n      }\n      if (!isAtTop && dY > 0 || !isAtBottom && dY < 0) {\n        e.preventDefault();\n        (0,react_dom__WEBPACK_IMPORTED_MODULE_4__.flushSync)(() => {\n          onChange(d => d + Math[method](dY, remainingScroll * sign));\n        });\n      } else if (/firefox/i.test((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getUserAgent)())) {\n        // Needed to propagate scrolling during momentum scrolling phase once\n        // it gets limited by the boundary. UX improvement, not critical.\n        el.scrollTop += dY;\n      }\n    }\n    const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;\n    if (open && el) {\n      el.addEventListener('wheel', onWheel);\n\n      // Wait for the position to be ready.\n      requestAnimationFrame(() => {\n        prevScrollTopRef.current = el.scrollTop;\n        if (overflowRef.current != null) {\n          initialOverflowRef.current = _objectSpread({}, overflowRef.current);\n        }\n      });\n      return () => {\n        prevScrollTopRef.current = null;\n        initialOverflowRef.current = null;\n        el.removeEventListener('wheel', onWheel);\n      };\n    }\n  }, [enabled, open, elements.floating, overflowRef, scrollRef, onChange]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    return {\n      floating: {\n        onKeyDown() {\n          controlledScrollingRef.current = true;\n        },\n        onWheel() {\n          controlledScrollingRef.current = false;\n        },\n        onPointerMove() {\n          controlledScrollingRef.current = false;\n        },\n        onScroll() {\n          const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;\n          if (!overflowRef.current || !el || !controlledScrollingRef.current) {\n            return;\n          }\n          if (prevScrollTopRef.current !== null) {\n            const scrollDiff = el.scrollTop - prevScrollTopRef.current;\n            if (overflowRef.current.bottom < -0.5 && scrollDiff < -1 || overflowRef.current.top < -0.5 && scrollDiff > 1) {\n              (0,react_dom__WEBPACK_IMPORTED_MODULE_4__.flushSync)(() => onChange(d => d + scrollDiff));\n            }\n          }\n\n          // [Firefox] Wait for the height change to have been applied.\n          requestAnimationFrame(() => {\n            prevScrollTopRef.current = el.scrollTop;\n          });\n        }\n      }\n    };\n  }, [enabled, overflowRef, elements.floating, scrollRef, onChange]);\n}\nfunction isPointInPolygon(point, polygon) {\n  const [x, y] = point;\n  let isInside = false;\n  const length = polygon.length;\n  for (let i = 0, j = length - 1; i < length; j = i++) {\n    const [xi, yi] = polygon[i] || [0, 0];\n    const [xj, yj] = polygon[j] || [0, 0];\n    const intersect = yi >= y !== yj >= y && x <= (xj - xi) * (y - yi) / (yj - yi) + xi;\n    if (intersect) {\n      isInside = !isInside;\n    }\n  }\n  return isInside;\n}\nfunction isInside(point, rect) {\n  return point[0] >= rect.x && point[0] <= rect.x + rect.width && point[1] >= rect.y && point[1] <= rect.y + rect.height;\n}\n/**\n * Generates a safe polygon area that the user can traverse without closing the\n * floating element once leaving the reference element.\n * @see https://floating-ui.com/docs/useHover#safepolygon\n */\nfunction safePolygon(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    buffer = 0.5,\n    blockPointerEvents = false,\n    requireIntent = true\n  } = options;\n  let timeoutId;\n  let hasLanded = false;\n  let lastX = null;\n  let lastY = null;\n  let lastCursorTime = performance.now();\n  function getCursorSpeed(x, y) {\n    const currentTime = performance.now();\n    const elapsedTime = currentTime - lastCursorTime;\n    if (lastX === null || lastY === null || elapsedTime === 0) {\n      lastX = x;\n      lastY = y;\n      lastCursorTime = currentTime;\n      return null;\n    }\n    const deltaX = x - lastX;\n    const deltaY = y - lastY;\n    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n    const speed = distance / elapsedTime; // px / ms\n\n    lastX = x;\n    lastY = y;\n    lastCursorTime = currentTime;\n    return speed;\n  }\n  const fn = _ref => {\n    let {\n      x,\n      y,\n      placement,\n      elements,\n      onClose,\n      nodeId,\n      tree\n    } = _ref;\n    return function onMouseMove(event) {\n      function close() {\n        clearTimeout(timeoutId);\n        onClose();\n      }\n      clearTimeout(timeoutId);\n      if (!elements.domReference || !elements.floating || placement == null || x == null || y == null) {\n        return;\n      }\n      const {\n        clientX,\n        clientY\n      } = event;\n      const clientPoint = [clientX, clientY];\n      const target = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getTarget)(event);\n      const isLeave = event.type === 'mouseleave';\n      const isOverFloatingEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(elements.floating, target);\n      const isOverReferenceEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(elements.domReference, target);\n      const refRect = elements.domReference.getBoundingClientRect();\n      const rect = elements.floating.getBoundingClientRect();\n      const side = placement.split('-')[0];\n      const cursorLeaveFromRight = x > rect.right - rect.width / 2;\n      const cursorLeaveFromBottom = y > rect.bottom - rect.height / 2;\n      const isOverReferenceRect = isInside(clientPoint, refRect);\n      const isFloatingWider = rect.width > refRect.width;\n      const isFloatingTaller = rect.height > refRect.height;\n      const left = (isFloatingWider ? refRect : rect).left;\n      const right = (isFloatingWider ? refRect : rect).right;\n      const top = (isFloatingTaller ? refRect : rect).top;\n      const bottom = (isFloatingTaller ? refRect : rect).bottom;\n      if (isOverFloatingEl) {\n        hasLanded = true;\n        if (!isLeave) {\n          return;\n        }\n      }\n      if (isOverReferenceEl) {\n        hasLanded = false;\n      }\n      if (isOverReferenceEl && !isLeave) {\n        hasLanded = true;\n        return;\n      }\n\n      // Prevent overlapping floating element from being stuck in an open-close\n      // loop: https://github.com/floating-ui/floating-ui/issues/1910\n      if (isLeave && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.isElement)(event.relatedTarget) && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(elements.floating, event.relatedTarget)) {\n        return;\n      }\n\n      // If any nested child is open, abort.\n      if (tree && getChildren(tree.nodesRef.current, nodeId).some(_ref2 => {\n        let {\n          context\n        } = _ref2;\n        return context == null ? void 0 : context.open;\n      })) {\n        return;\n      }\n\n      // If the pointer is leaving from the opposite side, the \"buffer\" logic\n      // creates a point where the floating element remains open, but should be\n      // ignored.\n      // A constant of 1 handles floating point rounding errors.\n      if (side === 'top' && y >= refRect.bottom - 1 || side === 'bottom' && y <= refRect.top + 1 || side === 'left' && x >= refRect.right - 1 || side === 'right' && x <= refRect.left + 1) {\n        return close();\n      }\n\n      // Ignore when the cursor is within the rectangular trough between the\n      // two elements. Since the triangle is created from the cursor point,\n      // which can start beyond the ref element's edge, traversing back and\n      // forth from the ref to the floating element can cause it to close. This\n      // ensures it always remains open in that case.\n      let rectPoly = [];\n      switch (side) {\n        case 'top':\n          rectPoly = [[left, refRect.top + 1], [left, rect.bottom - 1], [right, rect.bottom - 1], [right, refRect.top + 1]];\n          break;\n        case 'bottom':\n          rectPoly = [[left, rect.top + 1], [left, refRect.bottom - 1], [right, refRect.bottom - 1], [right, rect.top + 1]];\n          break;\n        case 'left':\n          rectPoly = [[rect.right - 1, bottom], [rect.right - 1, top], [refRect.left + 1, top], [refRect.left + 1, bottom]];\n          break;\n        case 'right':\n          rectPoly = [[refRect.right - 1, bottom], [refRect.right - 1, top], [rect.left + 1, top], [rect.left + 1, bottom]];\n          break;\n      }\n      function getPolygon(_ref3) {\n        let [x, y] = _ref3;\n        switch (side) {\n          case 'top':\n            {\n              const cursorPointOne = [isFloatingWider ? x + buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y + buffer + 1];\n              const cursorPointTwo = [isFloatingWider ? x - buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y + buffer + 1];\n              const commonPoints = [[rect.left, cursorLeaveFromRight ? rect.bottom - buffer : isFloatingWider ? rect.bottom - buffer : rect.top], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.bottom - buffer : rect.top : rect.bottom - buffer]];\n              return [cursorPointOne, cursorPointTwo, ...commonPoints];\n            }\n          case 'bottom':\n            {\n              const cursorPointOne = [isFloatingWider ? x + buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y - buffer];\n              const cursorPointTwo = [isFloatingWider ? x - buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y - buffer];\n              const commonPoints = [[rect.left, cursorLeaveFromRight ? rect.top + buffer : isFloatingWider ? rect.top + buffer : rect.bottom], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.top + buffer : rect.bottom : rect.top + buffer]];\n              return [cursorPointOne, cursorPointTwo, ...commonPoints];\n            }\n          case 'left':\n            {\n              const cursorPointOne = [x + buffer + 1, isFloatingTaller ? y + buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const cursorPointTwo = [x + buffer + 1, isFloatingTaller ? y - buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const commonPoints = [[cursorLeaveFromBottom ? rect.right - buffer : isFloatingTaller ? rect.right - buffer : rect.left, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.right - buffer : rect.left : rect.right - buffer, rect.bottom]];\n              return [...commonPoints, cursorPointOne, cursorPointTwo];\n            }\n          case 'right':\n            {\n              const cursorPointOne = [x - buffer, isFloatingTaller ? y + buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const cursorPointTwo = [x - buffer, isFloatingTaller ? y - buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const commonPoints = [[cursorLeaveFromBottom ? rect.left + buffer : isFloatingTaller ? rect.left + buffer : rect.right, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.left + buffer : rect.right : rect.left + buffer, rect.bottom]];\n              return [cursorPointOne, cursorPointTwo, ...commonPoints];\n            }\n        }\n      }\n      if (isPointInPolygon([clientX, clientY], rectPoly)) {\n        return;\n      }\n      if (hasLanded && !isOverReferenceRect) {\n        return close();\n      }\n      if (!isLeave && requireIntent) {\n        const cursorSpeed = getCursorSpeed(event.clientX, event.clientY);\n        const cursorSpeedThreshold = 0.1;\n        if (cursorSpeed !== null && cursorSpeed < cursorSpeedThreshold) {\n          return close();\n        }\n      }\n      if (!isPointInPolygon([clientX, clientY], getPolygon([x, y]))) {\n        close();\n      } else if (!hasLanded && requireIntent) {\n        timeoutId = window.setTimeout(close, 40);\n      }\n    };\n  };\n  fn.__options = {\n    blockPointerEvents\n  };\n  return fn;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3JlYWN0L2Rpc3QvZmxvYXRpbmctdWkucmVhY3QubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBK0I7QUFDNEI7QUFDK087QUFDL1A7QUFDbUY7QUFDa0U7QUFDOUM7QUFDbEc7QUFDSTs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTaUQsWUFBWUEsQ0FBQ0MsSUFBSSxFQUFFO0VBQzFCO0VBQ0EsT0FBT2xELDBDQUFhLENBQUMsTUFBTTtJQUN6QixJQUFJa0QsSUFBSSxDQUFDRSxLQUFLLENBQUNDLEdBQUcsSUFBSUEsR0FBRyxJQUFJLElBQUksQ0FBQyxFQUFFO01BQ2xDLE9BQU8sSUFBSTtJQUNiO0lBQ0EsT0FBT0MsS0FBSyxJQUFJO01BQ2RKLElBQUksQ0FBQ0ssT0FBTyxDQUFDRixHQUFHLElBQUk7UUFDbEIsSUFBSSxPQUFPQSxHQUFHLEtBQUssVUFBVSxFQUFFO1VBQzdCQSxHQUFHLENBQUNDLEtBQUssQ0FBQztRQUNaLENBQUMsTUFBTSxJQUFJRCxHQUFHLElBQUksSUFBSSxFQUFFO1VBQ3RCQSxHQUFHLENBQUNHLE9BQU8sR0FBR0YsS0FBSztRQUNyQjtNQUNGLENBQUMsQ0FBQztJQUNKLENBQUM7RUFDSCxDQUFDLEVBQUVKLElBQUksQ0FBQztBQUNWOztBQUVBO0FBQ0EsTUFBTU8sa0JBQWtCLEdBQUd6RCx5TEFBSyxDQUFDLGFBQWEsb0JBQW9CLENBQUMwRCxRQUFRLENBQUMsQ0FBQyxDQUFDO0FBQzlFLE1BQU1DLHNCQUFzQixHQUFHRixrQkFBa0IsS0FBS0csRUFBRSxJQUFJQSxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQ2pFLFNBQVNDLGNBQWNBLENBQUNDLFFBQVEsRUFBRTtFQUNoQyxNQUFNVCxHQUFHLEdBQUdyRCx5Q0FBWSxDQUFDLE1BQU07SUFDN0Is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O1FBQ2xEO01BQ0Y7TUFDQSxJQUFJdkIsU0FBUyxJQUFJLENBQUNvQixtQkFBbUIsRUFBRTtRQUNyQyxPQUFPN2tCLEtBQUssQ0FBQyxDQUFDO01BQ2hCO01BQ0EsSUFBSSxDQUFDdWtCLE9BQU8sSUFBSWYsYUFBYSxFQUFFO1FBQzdCLE1BQU02QixXQUFXLEdBQUd0QixjQUFjLENBQUNoNEIsS0FBSyxDQUFDNlIsT0FBTyxFQUFFN1IsS0FBSyxDQUFDOFIsT0FBTyxDQUFDO1FBQ2hFLE1BQU15bkIsb0JBQW9CLEdBQUcsR0FBRztRQUNoQyxJQUFJRCxXQUFXLEtBQUssSUFBSSxJQUFJQSxXQUFXLEdBQUdDLG9CQUFvQixFQUFFO1VBQzlELE9BQU90bEIsS0FBSyxDQUFDLENBQUM7UUFDaEI7TUFDRjtNQUNBLElBQUksQ0FBQzRpQixnQkFBZ0IsQ0FBQyxDQUFDaGxCLE9BQU8sRUFBRUMsT0FBTyxDQUFDLEVBQUVvbkIsVUFBVSxDQUFDLENBQUNqdEIsQ0FBQyxFQUFFRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUU7UUFDN0Q4SCxLQUFLLENBQUMsQ0FBQztNQUNULENBQUMsTUFBTSxJQUFJLENBQUN5akIsU0FBUyxJQUFJRCxhQUFhLEVBQUU7UUFDdEM5ZCxTQUFTLEdBQUd2RixNQUFNLENBQUNqRCxVQUFVLENBQUM4QyxLQUFLLEVBQUUsRUFBRSxDQUFDO01BQzFDO0lBQ0YsQ0FBQztFQUNILENBQUM7RUFDRHhXLEVBQUUsQ0FBQzRVLFNBQVMsR0FBRztJQUNiQztFQUNGLENBQUM7RUFDRCxPQUFPN1UsRUFBRTtBQUNYIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEVyZmFuXFxEZXNrdG9wXFwy2b7YsdmI2pjZhyDbjCDZhdit2YXYryDYudix2YHYp9mGINix2LbYp9uM24xcXEVyZmFuZGV2XFwuZnJvbnRlbmRcXG5vZGVfbW9kdWxlc1xcQGZsb2F0aW5nLXVpXFxyZWFjdFxcZGlzdFxcZmxvYXRpbmctdWkucmVhY3QubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUxheW91dEVmZmVjdCwgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBzdG9wRXZlbnQsIGdldERvY3VtZW50LCBpc01vdXNlTGlrZVBvaW50ZXJUeXBlLCBjb250YWlucywgYWN0aXZlRWxlbWVudCwgaXNTYWZhcmksIGlzVHlwZWFibGVDb21ib2JveCwgaXNWaXJ0dWFsQ2xpY2ssIGlzVmlydHVhbFBvaW50ZXJFdmVudCwgZ2V0VGFyZ2V0LCBnZXRQbGF0Zm9ybSwgaXNUeXBlYWJsZUVsZW1lbnQsIGlzUmVhY3RFdmVudCwgaXNSb290RWxlbWVudCwgaXNFdmVudFRhcmdldFdpdGhpbiwgaXNNYWMsIGdldFVzZXJBZ2VudCB9IGZyb20gJ0BmbG9hdGluZy11aS9yZWFjdC91dGlscyc7XG5pbXBvcnQgeyBmbG9vciB9IGZyb20gJ0BmbG9hdGluZy11aS91dGlscyc7XG5pbXBvcnQgeyBwbGF0Zm9ybSwgZ2V0T3ZlcmZsb3dBbmNlc3RvcnMsIHVzZUZsb2F0aW5nIGFzIHVzZUZsb2F0aW5nJDEsIG9mZnNldCwgZGV0ZWN0T3ZlcmZsb3cgfSBmcm9tICdAZmxvYXRpbmctdWkvcmVhY3QtZG9tJztcbmV4cG9ydCB7IGFycm93LCBhdXRvUGxhY2VtZW50LCBhdXRvVXBkYXRlLCBjb21wdXRlUG9zaXRpb24sIGRldGVjdE92ZXJmbG93LCBmbGlwLCBnZXRPdmVyZmxvd0FuY2VzdG9ycywgaGlkZSwgaW5saW5lLCBsaW1pdFNoaWZ0LCBvZmZzZXQsIHBsYXRmb3JtLCBzaGlmdCwgc2l6ZSB9IGZyb20gJ0BmbG9hdGluZy11aS9yZWFjdC1kb20nO1xuaW1wb3J0IHsgaXNFbGVtZW50LCBpc0hUTUxFbGVtZW50LCBnZXROb2RlTmFtZSwgZ2V0V2luZG93LCBpc0xhc3RUcmF2ZXJzYWJsZU5vZGUsIGdldFBhcmVudE5vZGUsIGdldENvbXB1dGVkU3R5bGUgfSBmcm9tICdAZmxvYXRpbmctdWkvdXRpbHMvZG9tJztcbmltcG9ydCB7IHRhYmJhYmxlLCBpc1RhYmJhYmxlIH0gZnJvbSAndGFiYmFibGUnO1xuaW1wb3J0IHsgY3JlYXRlUG9ydGFsLCBmbHVzaFN5bmMgfSBmcm9tICdyZWFjdC1kb20nO1xuXG4vKipcbiAqIE1lcmdlcyBhbiBhcnJheSBvZiByZWZzIGludG8gYSBzaW5nbGUgbWVtb2l6ZWQgY2FsbGJhY2sgcmVmIG9yIGBudWxsYC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9yZWFjdC11dGlscyN1c2VtZXJnZXJlZnNcbiAqL1xuZnVuY3Rpb24gdXNlTWVyZ2VSZWZzKHJlZnMpIHtcbiAgLy8gYmlvbWUtaWdub3JlIGxpbnQvY29ycmVjdG5lc3MvdXNlRXhoYXVzdGl2ZURlcGVuZGVuY2llczogaW50ZW50aW9uYWxcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGlmIChyZWZzLmV2ZXJ5KHJlZiA9PiByZWYgPT0gbnVsbCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUgPT4ge1xuICAgICAgcmVmcy5mb3JFYWNoKHJlZiA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmVmKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZWYgIT0gbnVsbCkge1xuICAgICAgICAgIHJlZi5jdXJyZW50ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gIH0sIHJlZnMpO1xufVxuXG4vLyBgdG9TdHJpbmcoKWAgcHJldmVudHMgYnVuZGxlcnMgZnJvbSB0cnlpbmcgdG8gYGltcG9ydCB7IHVzZUluc2VydGlvbkVmZmVjdCB9IGZyb20gJ3JlYWN0J2BcbmNvbnN0IHVzZUluc2VydGlvbkVmZmVjdCA9IFJlYWN0Wy8qI19fUFVSRV9fKi8ndXNlSW5zZXJ0aW9uRWZmZWN0Jy50b1N0cmluZygpXTtcbmNvbnN0IHVzZVNhZmVJbnNlcnRpb25FZmZlY3QgPSB1c2VJbnNlcnRpb25FZmZlY3QgfHwgKGZuID0+IGZuKCkpO1xuZnVuY3Rpb24gdXNlRWZmZWN0RXZlbnQoY2FsbGJhY2spIHtcbiAgY29uc3QgcmVmID0gUmVhY3QudXNlUmVmKCgpID0+IHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjYWxsIGFuIGV2ZW50IGhhbmRsZXIgd2hpbGUgcmVuZGVyaW5nLicpO1xuICAgIH1cbiAgfSk7XG4gIHVzZVNhZmVJbnNlcnRpb25FZmZlY3QoKCkgPT4ge1xuICAgIHJlZi5jdXJyZW50ID0gY2FsbGJhY2s7XG4gIH0pO1xuICByZXR1cm4gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHJlZi5jdXJyZW50ID09IG51bGwgPyB2b2lkIDAgOiByZWYuY3VycmVudCguLi5hcmdzKTtcbiAgfSwgW10pO1xufVxuXG5jb25zdCBBUlJPV19VUCA9ICdBcnJvd1VwJztcbmNvbnN0IEFSUk9XX0RPV04gPSAnQXJyb3dEb3duJztcbmNvbnN0IEFSUk9XX0xFRlQgPSAnQXJyb3dMZWZ0JztcbmNvbnN0IEFSUk9XX1JJR0hUID0gJ0Fycm93UmlnaHQnO1xuZnVuY3Rpb24gaXNEaWZmZXJlbnRSb3coaW5kZXgsIGNvbHMsIHByZXZSb3cpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoaW5kZXggLyBjb2xzKSAhPT0gcHJldlJvdztcbn1cbmZ1bmN0aW9uIGlzSW5kZXhPdXRPZkJvdW5kcyhsaXN0UmVmLCBpbmRleCkge1xuICByZXR1cm4gaW5kZXggPCAwIHx8IGluZGV4ID49IGxpc3RSZWYuY3VycmVudC5sZW5ndGg7XG59XG5mdW5jdGlvbiBnZXRNaW5JbmRleChsaXN0UmVmLCBkaXNhYmxlZEluZGljZXMpIHtcbiAgcmV0dXJuIGZpbmROb25EaXNhYmxlZEluZGV4KGxpc3RSZWYsIHtcbiAgICBkaXNhYmxlZEluZGljZXNcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRNYXhJbmRleChsaXN0UmVmLCBkaXNhYmxlZEluZGljZXMpIHtcbiAgcmV0dXJuIGZpbmROb25EaXNhYmxlZEluZGV4KGxpc3RSZWYsIHtcbiAgICBkZWNyZW1lbnQ6IHRydWUsXG4gICAgc3RhcnRpbmdJbmRleDogbGlzdFJlZi5jdXJyZW50Lmxlbmd0aCxcbiAgICBkaXNhYmxlZEluZGljZXNcbiAgfSk7XG59XG5mdW5jdGlvbiBmaW5kTm9uRGlzYWJsZWRJbmRleChsaXN0UmVmLCBfdGVtcCkge1xuICBsZXQge1xuICAgIHN0YXJ0aW5nSW5kZXggPSAtMSxcbiAgICBkZWNyZW1lbnQgPSBmYWxzZSxcbiAgICBkaXNhYmxlZEluZGljZXMsXG4gICAgYW1vdW50ID0gMVxuICB9ID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXA7XG4gIGNvbnN0IGxpc3QgPSBsaXN0UmVmLmN1cnJlbnQ7XG4gIGNvbnN0IGlzRGlzYWJsZWRJbmRleCA9IGRpc2FibGVkSW5kaWNlcyA/IGluZGV4ID0+IGRpc2FibGVkSW5kaWNlcy5pbmNsdWRlcyhpbmRleCkgOiBpbmRleCA9PiB7XG4gICAgY29uc3QgZWxlbWVudCA9IGxpc3RbaW5kZXhdO1xuICAgIHJldHVybiBlbGVtZW50ID09IG51bGwgfHwgZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJykgfHwgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2FyaWEtZGlzYWJsZWQnKSA9PT0gJ3RydWUnO1xuICB9O1xuICBsZXQgaW5kZXggPSBzdGFydGluZ0luZGV4O1xuICBkbyB7XG4gICAgaW5kZXggKz0gZGVjcmVtZW50ID8gLWFtb3VudCA6IGFtb3VudDtcbiAgfSB3aGlsZSAoaW5kZXggPj0gMCAmJiBpbmRleCA8PSBsaXN0Lmxlbmd0aCAtIDEgJiYgaXNEaXNhYmxlZEluZGV4KGluZGV4KSk7XG4gIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIGdldEdyaWROYXZpZ2F0ZWRJbmRleChlbGVtZW50c1JlZiwgX3JlZikge1xuICBsZXQge1xuICAgIGV2ZW50LFxuICAgIG9yaWVudGF0aW9uLFxuICAgIGxvb3AsXG4gICAgY29scyxcbiAgICBkaXNhYmxlZEluZGljZXMsXG4gICAgbWluSW5kZXgsXG4gICAgbWF4SW5kZXgsXG4gICAgcHJldkluZGV4LFxuICAgIHN0b3BFdmVudDogc3RvcCA9IGZhbHNlXG4gIH0gPSBfcmVmO1xuICBsZXQgbmV4dEluZGV4ID0gcHJldkluZGV4O1xuICBpZiAoZXZlbnQua2V5ID09PSBBUlJPV19VUCkge1xuICAgIHN0b3AgJiYgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICBpZiAocHJldkluZGV4ID09PSAtMSkge1xuICAgICAgbmV4dEluZGV4ID0gbWF4SW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRJbmRleCA9IGZpbmROb25EaXNhYmxlZEluZGV4KGVsZW1lbnRzUmVmLCB7XG4gICAgICAgIHN0YXJ0aW5nSW5kZXg6IG5leHRJbmRleCxcbiAgICAgICAgYW1vdW50OiBjb2xzLFxuICAgICAgICBkZWNyZW1lbnQ6IHRydWUsXG4gICAgICAgIGRpc2FibGVkSW5kaWNlc1xuICAgICAgfSk7XG4gICAgICBpZiAobG9vcCAmJiAocHJldkluZGV4IC0gY29scyA8IG1pbkluZGV4IHx8IG5leHRJbmRleCA8IDApKSB7XG4gICAgICAgIGNvbnN0IGNvbCA9IHByZXZJbmRleCAlIGNvbHM7XG4gICAgICAgIGNvbnN0IG1heENvbCA9IG1heEluZGV4ICUgY29scztcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gbWF4SW5kZXggLSAobWF4Q29sIC0gY29sKTtcbiAgICAgICAgaWYgKG1heENvbCA9PT0gY29sKSB7XG4gICAgICAgICAgbmV4dEluZGV4ID0gbWF4SW5kZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dEluZGV4ID0gbWF4Q29sID4gY29sID8gb2Zmc2V0IDogb2Zmc2V0IC0gY29scztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNJbmRleE91dE9mQm91bmRzKGVsZW1lbnRzUmVmLCBuZXh0SW5kZXgpKSB7XG4gICAgICBuZXh0SW5kZXggPSBwcmV2SW5kZXg7XG4gICAgfVxuICB9XG4gIGlmIChldmVudC5rZXkgPT09IEFSUk9XX0RPV04pIHtcbiAgICBzdG9wICYmIHN0b3BFdmVudChldmVudCk7XG4gICAgaWYgKHByZXZJbmRleCA9PT0gLTEpIHtcbiAgICAgIG5leHRJbmRleCA9IG1pbkluZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0SW5kZXggPSBmaW5kTm9uRGlzYWJsZWRJbmRleChlbGVtZW50c1JlZiwge1xuICAgICAgICBzdGFydGluZ0luZGV4OiBwcmV2SW5kZXgsXG4gICAgICAgIGFtb3VudDogY29scyxcbiAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICB9KTtcbiAgICAgIGlmIChsb29wICYmIHByZXZJbmRleCArIGNvbHMgPiBtYXhJbmRleCkge1xuICAgICAgICBuZXh0SW5kZXggPSBmaW5kTm9uRGlzYWJsZWRJbmRleChlbGVtZW50c1JlZiwge1xuICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IHByZXZJbmRleCAlIGNvbHMgLSBjb2xzLFxuICAgICAgICAgIGFtb3VudDogY29scyxcbiAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0luZGV4T3V0T2ZCb3VuZHMoZWxlbWVudHNSZWYsIG5leHRJbmRleCkpIHtcbiAgICAgIG5leHRJbmRleCA9IHByZXZJbmRleDtcbiAgICB9XG4gIH1cblxuICAvLyBSZW1haW5zIG9uIHRoZSBzYW1lIHJvdy9jb2x1bW4uXG4gIGlmIChvcmllbnRhdGlvbiA9PT0gJ2JvdGgnKSB7XG4gICAgY29uc3QgcHJldlJvdyA9IGZsb29yKHByZXZJbmRleCAvIGNvbHMpO1xuICAgIGlmIChldmVudC5rZXkgPT09IEFSUk9XX1JJR0hUKSB7XG4gICAgICBzdG9wICYmIHN0b3BFdmVudChldmVudCk7XG4gICAgICBpZiAocHJldkluZGV4ICUgY29scyAhPT0gY29scyAtIDEpIHtcbiAgICAgICAgbmV4dEluZGV4ID0gZmluZE5vbkRpc2FibGVkSW5kZXgoZWxlbWVudHNSZWYsIHtcbiAgICAgICAgICBzdGFydGluZ0luZGV4OiBwcmV2SW5kZXgsXG4gICAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobG9vcCAmJiBpc0RpZmZlcmVudFJvdyhuZXh0SW5kZXgsIGNvbHMsIHByZXZSb3cpKSB7XG4gICAgICAgICAgbmV4dEluZGV4ID0gZmluZE5vbkRpc2FibGVkSW5kZXgoZWxlbWVudHNSZWYsIHtcbiAgICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IHByZXZJbmRleCAtIHByZXZJbmRleCAlIGNvbHMgLSAxLFxuICAgICAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobG9vcCkge1xuICAgICAgICBuZXh0SW5kZXggPSBmaW5kTm9uRGlzYWJsZWRJbmRleChlbGVtZW50c1JlZiwge1xuICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IHByZXZJbmRleCAtIHByZXZJbmRleCAlIGNvbHMgLSAxLFxuICAgICAgICAgIGRpc2FibGVkSW5kaWNlc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0RpZmZlcmVudFJvdyhuZXh0SW5kZXgsIGNvbHMsIHByZXZSb3cpKSB7XG4gICAgICAgIG5leHRJbmRleCA9IHByZXZJbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGV2ZW50LmtleSA9PT0gQVJST1dfTEVGVCkge1xuICAgICAgc3RvcCAmJiBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgaWYgKHByZXZJbmRleCAlIGNvbHMgIT09IDApIHtcbiAgICAgICAgbmV4dEluZGV4ID0gZmluZE5vbkRpc2FibGVkSW5kZXgoZWxlbWVudHNSZWYsIHtcbiAgICAgICAgICBzdGFydGluZ0luZGV4OiBwcmV2SW5kZXgsXG4gICAgICAgICAgZGlzYWJsZWRJbmRpY2VzLFxuICAgICAgICAgIGRlY3JlbWVudDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGxvb3AgJiYgaXNEaWZmZXJlbnRSb3cobmV4dEluZGV4LCBjb2xzLCBwcmV2Um93KSkge1xuICAgICAgICAgIG5leHRJbmRleCA9IGZpbmROb25EaXNhYmxlZEluZGV4KGVsZW1lbnRzUmVmLCB7XG4gICAgICAgICAgICBzdGFydGluZ0luZGV4OiBwcmV2SW5kZXggKyAoY29scyAtIHByZXZJbmRleCAlIGNvbHMpLFxuICAgICAgICAgICAgZGVjcmVtZW50OiB0cnVlLFxuICAgICAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobG9vcCkge1xuICAgICAgICBuZXh0SW5kZXggPSBmaW5kTm9uRGlzYWJsZWRJbmRleChlbGVtZW50c1JlZiwge1xuICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IHByZXZJbmRleCArIChjb2xzIC0gcHJldkluZGV4ICUgY29scyksXG4gICAgICAgICAgZGVjcmVtZW50OiB0cnVlLFxuICAgICAgICAgIGRpc2FibGVkSW5kaWNlc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0RpZmZlcmVudFJvdyhuZXh0SW5kZXgsIGNvbHMsIHByZXZSb3cpKSB7XG4gICAgICAgIG5leHRJbmRleCA9IHByZXZJbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbGFzdFJvdyA9IGZsb29yKG1heEluZGV4IC8gY29scykgPT09IHByZXZSb3c7XG4gICAgaWYgKGlzSW5kZXhPdXRPZkJvdW5kcyhlbGVtZW50c1JlZiwgbmV4dEluZGV4KSkge1xuICAgICAgaWYgKGxvb3AgJiYgbGFzdFJvdykge1xuICAgICAgICBuZXh0SW5kZXggPSBldmVudC5rZXkgPT09IEFSUk9XX0xFRlQgPyBtYXhJbmRleCA6IGZpbmROb25EaXNhYmxlZEluZGV4KGVsZW1lbnRzUmVmLCB7XG4gICAgICAgICAgc3RhcnRpbmdJbmRleDogcHJldkluZGV4IC0gcHJldkluZGV4ICUgY29scyAtIDEsXG4gICAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dEluZGV4ID0gcHJldkluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbmV4dEluZGV4O1xufVxuXG4vKiogRm9yIGVhY2ggY2VsbCBpbmRleCwgZ2V0cyB0aGUgaXRlbSBpbmRleCB0aGF0IG9jY3VwaWVzIHRoYXQgY2VsbCAqL1xuZnVuY3Rpb24gYnVpbGRDZWxsTWFwKHNpemVzLCBjb2xzLCBkZW5zZSkge1xuICBjb25zdCBjZWxsTWFwID0gW107XG4gIGxldCBzdGFydEluZGV4ID0gMDtcbiAgc2l6ZXMuZm9yRWFjaCgoX3JlZjIsIGluZGV4KSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IF9yZWYyO1xuICAgIGlmICh3aWR0aCA+IGNvbHMpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW0Zsb2F0aW5nIFVJXTogSW52YWxpZCBncmlkIC0gaXRlbSB3aWR0aCBhdCBpbmRleCBcIiArIGluZGV4ICsgXCIgaXMgZ3JlYXRlciB0aGFuIGdyaWQgY29sdW1uc1wiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGl0ZW1QbGFjZWQgPSBmYWxzZTtcbiAgICBpZiAoZGVuc2UpIHtcbiAgICAgIHN0YXJ0SW5kZXggPSAwO1xuICAgIH1cbiAgICB3aGlsZSAoIWl0ZW1QbGFjZWQpIHtcbiAgICAgIGNvbnN0IHRhcmdldENlbGxzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdpZHRoOyBpKyspIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBoZWlnaHQ7IGorKykge1xuICAgICAgICAgIHRhcmdldENlbGxzLnB1c2goc3RhcnRJbmRleCArIGkgKyBqICogY29scyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzdGFydEluZGV4ICUgY29scyArIHdpZHRoIDw9IGNvbHMgJiYgdGFyZ2V0Q2VsbHMuZXZlcnkoY2VsbCA9PiBjZWxsTWFwW2NlbGxdID09IG51bGwpKSB7XG4gICAgICAgIHRhcmdldENlbGxzLmZvckVhY2goY2VsbCA9PiB7XG4gICAgICAgICAgY2VsbE1hcFtjZWxsXSA9IGluZGV4O1xuICAgICAgICB9KTtcbiAgICAgICAgaXRlbVBsYWNlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFydEluZGV4Kys7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvLyBjb252ZXJ0IGludG8gYSBub24tc3BhcnNlIGFycmF5XG4gIHJldHVybiBbLi4uY2VsbE1hcF07XG59XG5cbi8qKiBHZXRzIGNlbGwgaW5kZXggb2YgYW4gaXRlbSdzIGNvcm5lciBvciAtMSB3aGVuIGluZGV4IGlzIC0xLiAqL1xuZnVuY3Rpb24gZ2V0Q2VsbEluZGV4T2ZDb3JuZXIoaW5kZXgsIHNpemVzLCBjZWxsTWFwLCBjb2xzLCBjb3JuZXIpIHtcbiAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIC0xO1xuICBjb25zdCBmaXJzdENlbGxJbmRleCA9IGNlbGxNYXAuaW5kZXhPZihpbmRleCk7XG4gIHN3aXRjaCAoY29ybmVyKSB7XG4gICAgY2FzZSAndGwnOlxuICAgICAgcmV0dXJuIGZpcnN0Q2VsbEluZGV4O1xuICAgIGNhc2UgJ3RyJzpcbiAgICAgIHJldHVybiBmaXJzdENlbGxJbmRleCArIHNpemVzW2luZGV4XS53aWR0aCAtIDE7XG4gICAgY2FzZSAnYmwnOlxuICAgICAgcmV0dXJuIGZpcnN0Q2VsbEluZGV4ICsgKHNpemVzW2luZGV4XS5oZWlnaHQgLSAxKSAqIGNvbHM7XG4gICAgY2FzZSAnYnInOlxuICAgICAgcmV0dXJuIGNlbGxNYXAubGFzdEluZGV4T2YoaW5kZXgpO1xuICB9XG59XG5cbi8qKiBHZXRzIGFsbCBjZWxsIGluZGljZXMgdGhhdCBjb3JyZXNwb25kIHRvIHRoZSBzcGVjaWZpZWQgaW5kaWNlcyAqL1xuZnVuY3Rpb24gZ2V0Q2VsbEluZGljZXMoaW5kaWNlcywgY2VsbE1hcCkge1xuICByZXR1cm4gY2VsbE1hcC5mbGF0TWFwKChpbmRleCwgY2VsbEluZGV4KSA9PiBpbmRpY2VzLmluY2x1ZGVzKGluZGV4KSA/IFtjZWxsSW5kZXhdIDogW10pO1xufVxuXG5sZXQgcmFmSWQgPSAwO1xuZnVuY3Rpb24gZW5xdWV1ZUZvY3VzKGVsLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIHByZXZlbnRTY3JvbGwgPSBmYWxzZSxcbiAgICBjYW5jZWxQcmV2aW91cyA9IHRydWUsXG4gICAgc3luYyA9IGZhbHNlXG4gIH0gPSBvcHRpb25zO1xuICBjYW5jZWxQcmV2aW91cyAmJiBjYW5jZWxBbmltYXRpb25GcmFtZShyYWZJZCk7XG4gIGNvbnN0IGV4ZWMgPSAoKSA9PiBlbCA9PSBudWxsID8gdm9pZCAwIDogZWwuZm9jdXMoe1xuICAgIHByZXZlbnRTY3JvbGxcbiAgfSk7XG4gIGlmIChzeW5jKSB7XG4gICAgZXhlYygpO1xuICB9IGVsc2Uge1xuICAgIHJhZklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGV4ZWMpO1xuICB9XG59XG5cbnZhciBpbmRleCA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyB1c2VMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3Q7XG5cbmZ1bmN0aW9uIHNvcnRCeURvY3VtZW50UG9zaXRpb24oYSwgYikge1xuICBjb25zdCBwb3NpdGlvbiA9IGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYik7XG4gIGlmIChwb3NpdGlvbiAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HIHx8IHBvc2l0aW9uICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9DT05UQUlORURfQlkpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgaWYgKHBvc2l0aW9uICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9QUkVDRURJTkcgfHwgcG9zaXRpb24gJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0NPTlRBSU5TKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBhcmVNYXBzRXF1YWwobWFwMSwgbWFwMikge1xuICBpZiAobWFwMS5zaXplICE9PSBtYXAyLnNpemUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgbWFwMS5lbnRyaWVzKCkpIHtcbiAgICBpZiAodmFsdWUgIT09IG1hcDIuZ2V0KGtleSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5jb25zdCBGbG9hdGluZ0xpc3RDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQoe1xuICByZWdpc3RlcjogKCkgPT4ge30sXG4gIHVucmVnaXN0ZXI6ICgpID0+IHt9LFxuICBtYXA6IC8qI19fUFVSRV9fKi9uZXcgTWFwKCksXG4gIGVsZW1lbnRzUmVmOiB7XG4gICAgY3VycmVudDogW11cbiAgfVxufSk7XG4vKipcbiAqIFByb3ZpZGVzIGNvbnRleHQgZm9yIGEgbGlzdCBvZiBpdGVtcyB3aXRoaW4gdGhlIGZsb2F0aW5nIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvRmxvYXRpbmdMaXN0XG4gKi9cbmZ1bmN0aW9uIEZsb2F0aW5nTGlzdChfcmVmKSB7XG4gIGxldCB7XG4gICAgY2hpbGRyZW4sXG4gICAgZWxlbWVudHNSZWYsXG4gICAgbGFiZWxzUmVmXG4gIH0gPSBfcmVmO1xuICBjb25zdCBbbWFwLCBzZXRNYXBdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gbmV3IE1hcCgpKTtcbiAgY29uc3QgcmVnaXN0ZXIgPSBSZWFjdC51c2VDYWxsYmFjayhub2RlID0+IHtcbiAgICBzZXRNYXAocHJldk1hcCA9PiBuZXcgTWFwKHByZXZNYXApLnNldChub2RlLCBudWxsKSk7XG4gIH0sIFtdKTtcbiAgY29uc3QgdW5yZWdpc3RlciA9IFJlYWN0LnVzZUNhbGxiYWNrKG5vZGUgPT4ge1xuICAgIHNldE1hcChwcmV2TWFwID0+IHtcbiAgICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAocHJldk1hcCk7XG4gICAgICBtYXAuZGVsZXRlKG5vZGUpO1xuICAgICAgcmV0dXJuIG1hcDtcbiAgICB9KTtcbiAgfSwgW10pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgY29uc3QgbmV3TWFwID0gbmV3IE1hcChtYXApO1xuICAgIGNvbnN0IG5vZGVzID0gQXJyYXkuZnJvbShuZXdNYXAua2V5cygpKS5zb3J0KHNvcnRCeURvY3VtZW50UG9zaXRpb24pO1xuICAgIG5vZGVzLmZvckVhY2goKG5vZGUsIGluZGV4KSA9PiB7XG4gICAgICBuZXdNYXAuc2V0KG5vZGUsIGluZGV4KTtcbiAgICB9KTtcbiAgICBpZiAoIWFyZU1hcHNFcXVhbChtYXAsIG5ld01hcCkpIHtcbiAgICAgIHNldE1hcChuZXdNYXApO1xuICAgIH1cbiAgfSwgW21hcF0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRmxvYXRpbmdMaXN0Q29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgICByZWdpc3RlcixcbiAgICAgIHVucmVnaXN0ZXIsXG4gICAgICBtYXAsXG4gICAgICBlbGVtZW50c1JlZixcbiAgICAgIGxhYmVsc1JlZlxuICAgIH0pLCBbcmVnaXN0ZXIsIHVucmVnaXN0ZXIsIG1hcCwgZWxlbWVudHNSZWYsIGxhYmVsc1JlZl0pXG4gIH0sIGNoaWxkcmVuKTtcbn1cbi8qKlxuICogVXNlZCB0byByZWdpc3RlciBhIGxpc3QgaXRlbSBhbmQgaXRzIGluZGV4IChET00gcG9zaXRpb24pIGluIHRoZVxuICogYEZsb2F0aW5nTGlzdGAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvRmxvYXRpbmdMaXN0I3VzZWxpc3RpdGVtXG4gKi9cbmZ1bmN0aW9uIHVzZUxpc3RJdGVtKF90ZW1wKSB7XG4gIGxldCB7XG4gICAgbGFiZWxcbiAgfSA9IF90ZW1wID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wO1xuICBjb25zdCBbaW5kZXgkMSwgc2V0SW5kZXhdID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IGNvbXBvbmVudFJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3Qge1xuICAgIHJlZ2lzdGVyLFxuICAgIHVucmVnaXN0ZXIsXG4gICAgbWFwLFxuICAgIGVsZW1lbnRzUmVmLFxuICAgIGxhYmVsc1JlZlxuICB9ID0gUmVhY3QudXNlQ29udGV4dChGbG9hdGluZ0xpc3RDb250ZXh0KTtcbiAgY29uc3QgcmVmID0gUmVhY3QudXNlQ2FsbGJhY2sobm9kZSA9PiB7XG4gICAgY29tcG9uZW50UmVmLmN1cnJlbnQgPSBub2RlO1xuICAgIGlmIChpbmRleCQxICE9PSBudWxsKSB7XG4gICAgICBlbGVtZW50c1JlZi5jdXJyZW50W2luZGV4JDFdID0gbm9kZTtcbiAgICAgIGlmIChsYWJlbHNSZWYpIHtcbiAgICAgICAgdmFyIF9ub2RlJHRleHRDb250ZW50O1xuICAgICAgICBjb25zdCBpc0xhYmVsRGVmaW5lZCA9IGxhYmVsICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIGxhYmVsc1JlZi5jdXJyZW50W2luZGV4JDFdID0gaXNMYWJlbERlZmluZWQgPyBsYWJlbCA6IChfbm9kZSR0ZXh0Q29udGVudCA9IG5vZGUgPT0gbnVsbCA/IHZvaWQgMCA6IG5vZGUudGV4dENvbnRlbnQpICE9IG51bGwgPyBfbm9kZSR0ZXh0Q29udGVudCA6IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9LCBbaW5kZXgkMSwgZWxlbWVudHNSZWYsIGxhYmVsc1JlZiwgbGFiZWxdKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGNvbnN0IG5vZGUgPSBjb21wb25lbnRSZWYuY3VycmVudDtcbiAgICBpZiAobm9kZSkge1xuICAgICAgcmVnaXN0ZXIobm9kZSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB1bnJlZ2lzdGVyKG5vZGUpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFtyZWdpc3RlciwgdW5yZWdpc3Rlcl0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgY29uc3QgaW5kZXggPSBjb21wb25lbnRSZWYuY3VycmVudCA/IG1hcC5nZXQoY29tcG9uZW50UmVmLmN1cnJlbnQpIDogbnVsbDtcbiAgICBpZiAoaW5kZXggIT0gbnVsbCkge1xuICAgICAgc2V0SW5kZXgoaW5kZXgpO1xuICAgIH1cbiAgfSwgW21hcF0pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIHJlZixcbiAgICBpbmRleDogaW5kZXgkMSA9PSBudWxsID8gLTEgOiBpbmRleCQxXG4gIH0pLCBbaW5kZXgkMSwgcmVmXSk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckpzeChyZW5kZXIsIGNvbXB1dGVkUHJvcHMpIHtcbiAgaWYgKHR5cGVvZiByZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gcmVuZGVyKGNvbXB1dGVkUHJvcHMpO1xuICB9XG4gIGlmIChyZW5kZXIpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNsb25lRWxlbWVudChyZW5kZXIsIGNvbXB1dGVkUHJvcHMpO1xuICB9XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBjb21wdXRlZFByb3BzKTtcbn1cbmNvbnN0IENvbXBvc2l0ZUNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dCh7XG4gIGFjdGl2ZUluZGV4OiAwLFxuICBvbk5hdmlnYXRlOiAoKSA9PiB7fVxufSk7XG5jb25zdCBob3Jpem9udGFsS2V5cyA9IFtBUlJPV19MRUZULCBBUlJPV19SSUdIVF07XG5jb25zdCB2ZXJ0aWNhbEtleXMgPSBbQVJST1dfVVAsIEFSUk9XX0RPV05dO1xuY29uc3QgYWxsS2V5cyA9IFsuLi5ob3Jpem9udGFsS2V5cywgLi4udmVydGljYWxLZXlzXTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc2luZ2xlIHRhYiBzdG9wIHdob3NlIGl0ZW1zIGFyZSBuYXZpZ2F0ZWQgYnkgYXJyb3cga2V5cywgd2hpY2hcbiAqIHByb3ZpZGVzIGxpc3QgbmF2aWdhdGlvbiBvdXRzaWRlIG9mIGZsb2F0aW5nIGVsZW1lbnQgY29udGV4dHMuXG4gKlxuICogVGhpcyBpcyB1c2VmdWwgdG8gZW5hYmxlIG5hdmlnYXRpb24gb2YgYSBsaXN0IG9mIGl0ZW1zIHRoYXQgYXJlbuKAmXQgcGFydCBvZiBhXG4gKiBmbG9hdGluZyBlbGVtZW50LiBBIG1lbnViYXIgaXMgYW4gZXhhbXBsZSBvZiBhIGNvbXBvc2l0ZSwgd2l0aCBlYWNoIHJlZmVyZW5jZVxuICogZWxlbWVudCBiZWluZyBhbiBpdGVtLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL0NvbXBvc2l0ZVxuICovXG5jb25zdCBDb21wb3NpdGUgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBDb21wb3NpdGUoX3JlZiwgZm9yd2FyZGVkUmVmKSB7XG4gIGxldCB7XG4gICAgcmVuZGVyLFxuICAgIG9yaWVudGF0aW9uID0gJ2JvdGgnLFxuICAgIGxvb3AgPSB0cnVlLFxuICAgIGNvbHMgPSAxLFxuICAgIGRpc2FibGVkSW5kaWNlcyA9IFtdLFxuICAgIGFjdGl2ZUluZGV4OiBleHRlcm5hbEFjdGl2ZUluZGV4LFxuICAgIG9uTmF2aWdhdGU6IGV4dGVybmFsU2V0QWN0aXZlSW5kZXgsXG4gICAgaXRlbVNpemVzLFxuICAgIGRlbnNlID0gZmFsc2UsXG4gICAgLi4ucHJvcHNcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IFtpbnRlcm5hbEFjdGl2ZUluZGV4LCBpbnRlcm5hbFNldEFjdGl2ZUluZGV4XSA9IFJlYWN0LnVzZVN0YXRlKDApO1xuICBjb25zdCBhY3RpdmVJbmRleCA9IGV4dGVybmFsQWN0aXZlSW5kZXggIT0gbnVsbCA/IGV4dGVybmFsQWN0aXZlSW5kZXggOiBpbnRlcm5hbEFjdGl2ZUluZGV4O1xuICBjb25zdCBvbk5hdmlnYXRlID0gdXNlRWZmZWN0RXZlbnQoZXh0ZXJuYWxTZXRBY3RpdmVJbmRleCAhPSBudWxsID8gZXh0ZXJuYWxTZXRBY3RpdmVJbmRleCA6IGludGVybmFsU2V0QWN0aXZlSW5kZXgpO1xuICBjb25zdCBlbGVtZW50c1JlZiA9IFJlYWN0LnVzZVJlZihbXSk7XG4gIGNvbnN0IHJlbmRlckVsZW1lbnRQcm9wcyA9IHJlbmRlciAmJiB0eXBlb2YgcmVuZGVyICE9PSAnZnVuY3Rpb24nID8gcmVuZGVyLnByb3BzIDoge307XG4gIGNvbnN0IGNvbnRleHRWYWx1ZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICBhY3RpdmVJbmRleCxcbiAgICBvbk5hdmlnYXRlXG4gIH0pLCBbYWN0aXZlSW5kZXgsIG9uTmF2aWdhdGVdKTtcbiAgY29uc3QgaXNHcmlkID0gY29scyA+IDE7XG4gIGZ1bmN0aW9uIGhhbmRsZUtleURvd24oZXZlbnQpIHtcbiAgICBpZiAoIWFsbEtleXMuaW5jbHVkZXMoZXZlbnQua2V5KSkgcmV0dXJuO1xuICAgIGxldCBuZXh0SW5kZXggPSBhY3RpdmVJbmRleDtcbiAgICBpZiAoaXNHcmlkKSB7XG4gICAgICBjb25zdCBzaXplcyA9IGl0ZW1TaXplcyB8fCBBcnJheS5mcm9tKHtcbiAgICAgICAgbGVuZ3RoOiBlbGVtZW50c1JlZi5jdXJyZW50Lmxlbmd0aFxuICAgICAgfSwgKCkgPT4gKHtcbiAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgIGhlaWdodDogMVxuICAgICAgfSkpO1xuICAgICAgLy8gVG8gY2FsY3VsYXRlIG1vdmVtZW50cyBvbiB0aGUgZ3JpZCwgd2UgdXNlIGh5cG90aGV0aWNhbCBjZWxsIGluZGljZXNcbiAgICAgIC8vIGFzIGlmIGV2ZXJ5IGl0ZW0gd2FzIDF4MSwgdGhlbiBjb252ZXJ0IGJhY2sgdG8gcmVhbCBpbmRpY2VzLlxuICAgICAgY29uc3QgY2VsbE1hcCA9IGJ1aWxkQ2VsbE1hcChzaXplcywgY29scywgZGVuc2UpO1xuICAgICAgY29uc3QgbWluR3JpZEluZGV4ID0gY2VsbE1hcC5maW5kSW5kZXgoaW5kZXggPT4gaW5kZXggIT0gbnVsbCAmJiAhZGlzYWJsZWRJbmRpY2VzLmluY2x1ZGVzKGluZGV4KSk7XG4gICAgICAvLyBsYXN0IGVuYWJsZWQgaW5kZXhcbiAgICAgIGNvbnN0IG1heEdyaWRJbmRleCA9IGNlbGxNYXAucmVkdWNlKChmb3VuZEluZGV4LCBpbmRleCwgY2VsbEluZGV4KSA9PiBpbmRleCAhPSBudWxsICYmICEoZGlzYWJsZWRJbmRpY2VzICE9IG51bGwgJiYgZGlzYWJsZWRJbmRpY2VzLmluY2x1ZGVzKGluZGV4KSkgPyBjZWxsSW5kZXggOiBmb3VuZEluZGV4LCAtMSk7XG4gICAgICBuZXh0SW5kZXggPSBjZWxsTWFwW2dldEdyaWROYXZpZ2F0ZWRJbmRleCh7XG4gICAgICAgIGN1cnJlbnQ6IGNlbGxNYXAubWFwKGl0ZW1JbmRleCA9PiBpdGVtSW5kZXggPyBlbGVtZW50c1JlZi5jdXJyZW50W2l0ZW1JbmRleF0gOiBudWxsKVxuICAgICAgfSwge1xuICAgICAgICBldmVudCxcbiAgICAgICAgb3JpZW50YXRpb24sXG4gICAgICAgIGxvb3AsXG4gICAgICAgIGNvbHMsXG4gICAgICAgIC8vIHRyZWF0IHVuZGVmaW5lZCAoZW1wdHkgZ3JpZCBzcGFjZXMpIGFzIGRpc2FibGVkIGluZGljZXMgc28gd2VcbiAgICAgICAgLy8gZG9uJ3QgZW5kIHVwIGluIHRoZW1cbiAgICAgICAgZGlzYWJsZWRJbmRpY2VzOiBnZXRDZWxsSW5kaWNlcyhbLi4uZGlzYWJsZWRJbmRpY2VzLCB1bmRlZmluZWRdLCBjZWxsTWFwKSxcbiAgICAgICAgbWluSW5kZXg6IG1pbkdyaWRJbmRleCxcbiAgICAgICAgbWF4SW5kZXg6IG1heEdyaWRJbmRleCxcbiAgICAgICAgcHJldkluZGV4OiBnZXRDZWxsSW5kZXhPZkNvcm5lcihhY3RpdmVJbmRleCwgc2l6ZXMsIGNlbGxNYXAsIGNvbHMsXG4gICAgICAgIC8vIHVzZSBhIGNvcm5lciBtYXRjaGluZyB0aGUgZWRnZSBjbG9zZXN0IHRvIHRoZSBkaXJlY3Rpb24gd2UncmVcbiAgICAgICAgLy8gbW92aW5nIGluIHNvIHdlIGRvbid0IGVuZCB1cCBpbiB0aGUgc2FtZSBpdGVtLiBQcmVmZXJcbiAgICAgICAgLy8gdG9wL2xlZnQgb3ZlciBib3R0b20vcmlnaHQuXG4gICAgICAgIGV2ZW50LmtleSA9PT0gQVJST1dfRE9XTiA/ICdibCcgOiBldmVudC5rZXkgPT09IEFSUk9XX1JJR0hUID8gJ3RyJyA6ICd0bCcpXG4gICAgICB9KV07IC8vIG5hdmlnYXRlZCBjZWxsIHdpbGwgbmV2ZXIgYmUgbnVsbGlzaFxuICAgIH1cbiAgICBjb25zdCBtaW5JbmRleCA9IGdldE1pbkluZGV4KGVsZW1lbnRzUmVmLCBkaXNhYmxlZEluZGljZXMpO1xuICAgIGNvbnN0IG1heEluZGV4ID0gZ2V0TWF4SW5kZXgoZWxlbWVudHNSZWYsIGRpc2FibGVkSW5kaWNlcyk7XG4gICAgY29uc3QgdG9FbmRLZXlzID0ge1xuICAgICAgaG9yaXpvbnRhbDogW0FSUk9XX1JJR0hUXSxcbiAgICAgIHZlcnRpY2FsOiBbQVJST1dfRE9XTl0sXG4gICAgICBib3RoOiBbQVJST1dfUklHSFQsIEFSUk9XX0RPV05dXG4gICAgfVtvcmllbnRhdGlvbl07XG4gICAgY29uc3QgdG9TdGFydEtleXMgPSB7XG4gICAgICBob3Jpem9udGFsOiBbQVJST1dfTEVGVF0sXG4gICAgICB2ZXJ0aWNhbDogW0FSUk9XX1VQXSxcbiAgICAgIGJvdGg6IFtBUlJPV19MRUZULCBBUlJPV19VUF1cbiAgICB9W29yaWVudGF0aW9uXTtcbiAgICBjb25zdCBwcmV2ZW50ZWRLZXlzID0gaXNHcmlkID8gYWxsS2V5cyA6IHtcbiAgICAgIGhvcml6b250YWw6IGhvcml6b250YWxLZXlzLFxuICAgICAgdmVydGljYWw6IHZlcnRpY2FsS2V5cyxcbiAgICAgIGJvdGg6IGFsbEtleXNcbiAgICB9W29yaWVudGF0aW9uXTtcbiAgICBpZiAobmV4dEluZGV4ID09PSBhY3RpdmVJbmRleCAmJiBbLi4udG9FbmRLZXlzLCAuLi50b1N0YXJ0S2V5c10uaW5jbHVkZXMoZXZlbnQua2V5KSkge1xuICAgICAgaWYgKGxvb3AgJiYgbmV4dEluZGV4ID09PSBtYXhJbmRleCAmJiB0b0VuZEtleXMuaW5jbHVkZXMoZXZlbnQua2V5KSkge1xuICAgICAgICBuZXh0SW5kZXggPSBtaW5JbmRleDtcbiAgICAgIH0gZWxzZSBpZiAobG9vcCAmJiBuZXh0SW5kZXggPT09IG1pbkluZGV4ICYmIHRvU3RhcnRLZXlzLmluY2x1ZGVzKGV2ZW50LmtleSkpIHtcbiAgICAgICAgbmV4dEluZGV4ID0gbWF4SW5kZXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0SW5kZXggPSBmaW5kTm9uRGlzYWJsZWRJbmRleChlbGVtZW50c1JlZiwge1xuICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IG5leHRJbmRleCxcbiAgICAgICAgICBkZWNyZW1lbnQ6IHRvU3RhcnRLZXlzLmluY2x1ZGVzKGV2ZW50LmtleSksXG4gICAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmV4dEluZGV4ICE9PSBhY3RpdmVJbmRleCAmJiAhaXNJbmRleE91dE9mQm91bmRzKGVsZW1lbnRzUmVmLCBuZXh0SW5kZXgpKSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGlmIChwcmV2ZW50ZWRLZXlzLmluY2x1ZGVzKGV2ZW50LmtleSkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICAgIG9uTmF2aWdhdGUobmV4dEluZGV4KTtcblxuICAgICAgLy8gV2FpdCBmb3IgRm9jdXNNYW5hZ2VyIGByZXR1cm5Gb2N1c2AgdG8gZXhlY3V0ZS5cbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgZW5xdWV1ZUZvY3VzKGVsZW1lbnRzUmVmLmN1cnJlbnRbbmV4dEluZGV4XSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgY29uc3QgY29tcHV0ZWRQcm9wcyA9IHtcbiAgICAuLi5wcm9wcyxcbiAgICAuLi5yZW5kZXJFbGVtZW50UHJvcHMsXG4gICAgcmVmOiBmb3J3YXJkZWRSZWYsXG4gICAgJ2FyaWEtb3JpZW50YXRpb24nOiBvcmllbnRhdGlvbiA9PT0gJ2JvdGgnID8gdW5kZWZpbmVkIDogb3JpZW50YXRpb24sXG4gICAgb25LZXlEb3duKGUpIHtcbiAgICAgIHByb3BzLm9uS2V5RG93biA9PSBudWxsIHx8IHByb3BzLm9uS2V5RG93bihlKTtcbiAgICAgIHJlbmRlckVsZW1lbnRQcm9wcy5vbktleURvd24gPT0gbnVsbCB8fCByZW5kZXJFbGVtZW50UHJvcHMub25LZXlEb3duKGUpO1xuICAgICAgaGFuZGxlS2V5RG93bihlKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb3NpdGVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGNvbnRleHRWYWx1ZVxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGbG9hdGluZ0xpc3QsIHtcbiAgICBlbGVtZW50c1JlZjogZWxlbWVudHNSZWZcbiAgfSwgcmVuZGVySnN4KHJlbmRlciwgY29tcHV0ZWRQcm9wcykpKTtcbn0pO1xuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvQ29tcG9zaXRlXG4gKi9cbmNvbnN0IENvbXBvc2l0ZUl0ZW0gPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBDb21wb3NpdGVJdGVtKF9yZWYyLCBmb3J3YXJkZWRSZWYpIHtcbiAgbGV0IHtcbiAgICByZW5kZXIsXG4gICAgLi4ucHJvcHNcbiAgfSA9IF9yZWYyO1xuICBjb25zdCByZW5kZXJFbGVtZW50UHJvcHMgPSByZW5kZXIgJiYgdHlwZW9mIHJlbmRlciAhPT0gJ2Z1bmN0aW9uJyA/IHJlbmRlci5wcm9wcyA6IHt9O1xuICBjb25zdCB7XG4gICAgYWN0aXZlSW5kZXgsXG4gICAgb25OYXZpZ2F0ZVxuICB9ID0gUmVhY3QudXNlQ29udGV4dChDb21wb3NpdGVDb250ZXh0KTtcbiAgY29uc3Qge1xuICAgIHJlZixcbiAgICBpbmRleFxuICB9ID0gdXNlTGlzdEl0ZW0oKTtcbiAgY29uc3QgbWVyZ2VkUmVmID0gdXNlTWVyZ2VSZWZzKFtyZWYsIGZvcndhcmRlZFJlZiwgcmVuZGVyRWxlbWVudFByb3BzLnJlZl0pO1xuICBjb25zdCBpc0FjdGl2ZSA9IGFjdGl2ZUluZGV4ID09PSBpbmRleDtcbiAgY29uc3QgY29tcHV0ZWRQcm9wcyA9IHtcbiAgICAuLi5wcm9wcyxcbiAgICAuLi5yZW5kZXJFbGVtZW50UHJvcHMsXG4gICAgcmVmOiBtZXJnZWRSZWYsXG4gICAgdGFiSW5kZXg6IGlzQWN0aXZlID8gMCA6IC0xLFxuICAgICdkYXRhLWFjdGl2ZSc6IGlzQWN0aXZlID8gJycgOiB1bmRlZmluZWQsXG4gICAgb25Gb2N1cyhlKSB7XG4gICAgICBwcm9wcy5vbkZvY3VzID09IG51bGwgfHwgcHJvcHMub25Gb2N1cyhlKTtcbiAgICAgIHJlbmRlckVsZW1lbnRQcm9wcy5vbkZvY3VzID09IG51bGwgfHwgcmVuZGVyRWxlbWVudFByb3BzLm9uRm9jdXMoZSk7XG4gICAgICBvbk5hdmlnYXRlKGluZGV4KTtcbiAgICB9XG4gIH07XG4gIHJldHVybiByZW5kZXJKc3gocmVuZGVyLCBjb21wdXRlZFByb3BzKTtcbn0pO1xuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxubGV0IHNlcnZlckhhbmRvZmZDb21wbGV0ZSA9IGZhbHNlO1xubGV0IGNvdW50ID0gMDtcbmNvbnN0IGdlbklkID0gKCkgPT4gXCJmbG9hdGluZy11aS1cIiArIGNvdW50Kys7XG5mdW5jdGlvbiB1c2VGbG9hdGluZ0lkKCkge1xuICBjb25zdCBbaWQsIHNldElkXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IHNlcnZlckhhbmRvZmZDb21wbGV0ZSA/IGdlbklkKCkgOiB1bmRlZmluZWQpO1xuXG4gIC8vIGJpb21lLWlnbm9yZSBsaW50L2NvcnJlY3RuZXNzL3VzZUV4aGF1c3RpdmVEZXBlbmRlbmNpZXM6IGludGVudGlvbmFsXG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoaWQgPT0gbnVsbCkge1xuICAgICAgc2V0SWQoZ2VuSWQoKSk7XG4gICAgfVxuICB9LCBbXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFzZXJ2ZXJIYW5kb2ZmQ29tcGxldGUpIHtcbiAgICAgIHNlcnZlckhhbmRvZmZDb21wbGV0ZSA9IHRydWU7XG4gICAgfVxuICB9LCBbXSk7XG4gIHJldHVybiBpZDtcbn1cblxuLy8gYHRvU3RyaW5nKClgIHByZXZlbnRzIGJ1bmRsZXJzIGZyb20gdHJ5aW5nIHRvIGBpbXBvcnQgeyB1c2VJZCB9IGZyb20gJ3JlYWN0J2BcbmNvbnN0IHVzZVJlYWN0SWQgPSBSZWFjdFsvKiNfX1BVUkVfXyovJ3VzZUlkJy50b1N0cmluZygpXTtcblxuLyoqXG4gKiBVc2VzIFJlYWN0IDE4J3MgYnVpbHQtaW4gYHVzZUlkKClgIHdoZW4gYXZhaWxhYmxlLCBvciBmYWxscyBiYWNrIHRvIGFcbiAqIHNsaWdodGx5IGxlc3MgcGVyZm9ybWFudCAocmVxdWlyaW5nIGEgZG91YmxlIHJlbmRlcikgaW1wbGVtZW50YXRpb24gZm9yXG4gKiBlYXJsaWVyIFJlYWN0IHZlcnNpb25zLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3JlYWN0LXV0aWxzI3VzZWlkXG4gKi9cbmNvbnN0IHVzZUlkID0gdXNlUmVhY3RJZCB8fCB1c2VGbG9hdGluZ0lkO1xuXG4vKipcbiAqIFJlbmRlcnMgYSBwb2ludGluZyBhcnJvdyB0cmlhbmdsZS5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9GbG9hdGluZ0Fycm93XG4gKi9cbmNvbnN0IEZsb2F0aW5nQXJyb3cgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBGbG9hdGluZ0Fycm93KF9yZWYsIHJlZikge1xuICBsZXQge1xuICAgIGNvbnRleHQ6IHtcbiAgICAgIHBsYWNlbWVudCxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIGZsb2F0aW5nXG4gICAgICB9LFxuICAgICAgbWlkZGxld2FyZURhdGE6IHtcbiAgICAgICAgYXJyb3dcbiAgICAgIH1cbiAgICB9LFxuICAgIHdpZHRoID0gMTQsXG4gICAgaGVpZ2h0ID0gNyxcbiAgICB0aXBSYWRpdXMgPSAwLFxuICAgIHN0cm9rZVdpZHRoID0gMCxcbiAgICBzdGF0aWNPZmZzZXQsXG4gICAgc3Ryb2tlLFxuICAgIGQsXG4gICAgc3R5bGU6IHtcbiAgICAgIHRyYW5zZm9ybSxcbiAgICAgIC4uLnJlc3RTdHlsZVxuICAgIH0gPSB7fSxcbiAgICAuLi5yZXN0XG4gIH0gPSBfcmVmO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKCFyZWYpIHtcbiAgICAgIGNvbnNvbGUud2FybignRmxvYXRpbmcgVUk6IFRoZSBgcmVmYCBwcm9wIGlzIHJlcXVpcmVkIGZvciB0aGUgYEZsb2F0aW5nQXJyb3dgJywgJ2NvbXBvbmVudC4nKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgY2xpcFBhdGhJZCA9IHVzZUlkKCk7XG4gIGlmICghZmxvYXRpbmcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIFN0cm9rZXMgbXVzdCBiZSBkb3VibGUgdGhlIGJvcmRlciB3aWR0aCwgdGhpcyBlbnN1cmVzIHRoZSBzdHJva2UncyB3aWR0aFxuICAvLyB3b3JrcyBhcyB5b3UnZCBleHBlY3QuXG4gIHN0cm9rZVdpZHRoICo9IDI7XG4gIGNvbnN0IGhhbGZTdHJva2VXaWR0aCA9IHN0cm9rZVdpZHRoIC8gMjtcbiAgY29uc3Qgc3ZnWCA9IHdpZHRoIC8gMiAqICh0aXBSYWRpdXMgLyAtOCArIDEpO1xuICBjb25zdCBzdmdZID0gaGVpZ2h0IC8gMiAqIHRpcFJhZGl1cyAvIDQ7XG4gIGNvbnN0IFtzaWRlLCBhbGlnbm1lbnRdID0gcGxhY2VtZW50LnNwbGl0KCctJyk7XG4gIGNvbnN0IGlzUlRMID0gcGxhdGZvcm0uaXNSVEwoZmxvYXRpbmcpO1xuICBjb25zdCBpc0N1c3RvbVNoYXBlID0gISFkO1xuICBjb25zdCBpc1ZlcnRpY2FsU2lkZSA9IHNpZGUgPT09ICd0b3AnIHx8IHNpZGUgPT09ICdib3R0b20nO1xuICBjb25zdCB5T2Zmc2V0UHJvcCA9IHN0YXRpY09mZnNldCAmJiBhbGlnbm1lbnQgPT09ICdlbmQnID8gJ2JvdHRvbScgOiAndG9wJztcbiAgbGV0IHhPZmZzZXRQcm9wID0gc3RhdGljT2Zmc2V0ICYmIGFsaWdubWVudCA9PT0gJ2VuZCcgPyAncmlnaHQnIDogJ2xlZnQnO1xuICBpZiAoc3RhdGljT2Zmc2V0ICYmIGlzUlRMKSB7XG4gICAgeE9mZnNldFByb3AgPSBhbGlnbm1lbnQgPT09ICdlbmQnID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgfVxuICBjb25zdCBhcnJvd1ggPSAoYXJyb3cgPT0gbnVsbCA/IHZvaWQgMCA6IGFycm93LngpICE9IG51bGwgPyBzdGF0aWNPZmZzZXQgfHwgYXJyb3cueCA6ICcnO1xuICBjb25zdCBhcnJvd1kgPSAoYXJyb3cgPT0gbnVsbCA/IHZvaWQgMCA6IGFycm93LnkpICE9IG51bGwgPyBzdGF0aWNPZmZzZXQgfHwgYXJyb3cueSA6ICcnO1xuICBjb25zdCBkVmFsdWUgPSBkIHx8XG4gIC8vIGJpb21lLWlnbm9yZSBsaW50L3N0eWxlL3VzZVRlbXBsYXRlOiByZWFkYWJpbGl0eVxuICAnTTAsMCcgKyAoXCIgSFwiICsgd2lkdGgpICsgKFwiIExcIiArICh3aWR0aCAtIHN2Z1gpICsgXCIsXCIgKyAoaGVpZ2h0IC0gc3ZnWSkpICsgKFwiIFFcIiArIHdpZHRoIC8gMiArIFwiLFwiICsgaGVpZ2h0ICsgXCIgXCIgKyBzdmdYICsgXCIsXCIgKyAoaGVpZ2h0IC0gc3ZnWSkpICsgJyBaJztcbiAgY29uc3Qgcm90YXRpb24gPSB7XG4gICAgdG9wOiBpc0N1c3RvbVNoYXBlID8gJ3JvdGF0ZSgxODBkZWcpJyA6ICcnLFxuICAgIGxlZnQ6IGlzQ3VzdG9tU2hhcGUgPyAncm90YXRlKDkwZGVnKScgOiAncm90YXRlKC05MGRlZyknLFxuICAgIGJvdHRvbTogaXNDdXN0b21TaGFwZSA/ICcnIDogJ3JvdGF0ZSgxODBkZWcpJyxcbiAgICByaWdodDogaXNDdXN0b21TaGFwZSA/ICdyb3RhdGUoLTkwZGVnKScgOiAncm90YXRlKDkwZGVnKSdcbiAgfVtzaWRlXTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIF9leHRlbmRzKHt9LCByZXN0LCB7XG4gICAgXCJhcmlhLWhpZGRlblwiOiB0cnVlLFxuICAgIHJlZjogcmVmLFxuICAgIHdpZHRoOiBpc0N1c3RvbVNoYXBlID8gd2lkdGggOiB3aWR0aCArIHN0cm9rZVdpZHRoLFxuICAgIGhlaWdodDogd2lkdGgsXG4gICAgdmlld0JveDogXCIwIDAgXCIgKyB3aWR0aCArIFwiIFwiICsgKGhlaWdodCA+IHdpZHRoID8gaGVpZ2h0IDogd2lkdGgpLFxuICAgIHN0eWxlOiB7XG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJyxcbiAgICAgIFt4T2Zmc2V0UHJvcF06IGFycm93WCxcbiAgICAgIFt5T2Zmc2V0UHJvcF06IGFycm93WSxcbiAgICAgIFtzaWRlXTogaXNWZXJ0aWNhbFNpZGUgfHwgaXNDdXN0b21TaGFwZSA/ICcxMDAlJyA6IFwiY2FsYygxMDAlIC0gXCIgKyBzdHJva2VXaWR0aCAvIDIgKyBcInB4KVwiLFxuICAgICAgdHJhbnNmb3JtOiBcIlwiICsgcm90YXRpb24gKyAodHJhbnNmb3JtICE9IG51bGwgPyB0cmFuc2Zvcm0gOiAnJyksXG4gICAgICAuLi5yZXN0U3R5bGVcbiAgICB9XG4gIH0pLCBzdHJva2VXaWR0aCA+IDAgJiYgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICBjbGlwUGF0aDogXCJ1cmwoI1wiICsgY2xpcFBhdGhJZCArIFwiKVwiLFxuICAgIGZpbGw6IFwibm9uZVwiLFxuICAgIHN0cm9rZTogc3Ryb2tlXG4gICAgLy8gQWNjb3VudCBmb3IgdGhlIHN0cm9rZSBvbiB0aGUgZmlsbCBwYXRoIHJlbmRlcmVkIGJlbG93LlxuICAgICxcbiAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGggKyAoZCA/IDAgOiAxKSxcbiAgICBkOiBkVmFsdWVcbiAgfSksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgc3Ryb2tlOiBzdHJva2VXaWR0aCAmJiAhZCA/IHJlc3QuZmlsbCA6ICdub25lJyxcbiAgICBkOiBkVmFsdWVcbiAgfSksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiY2xpcFBhdGhcIiwge1xuICAgIGlkOiBjbGlwUGF0aElkXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwicmVjdFwiLCB7XG4gICAgeDogLWhhbGZTdHJva2VXaWR0aCxcbiAgICB5OiBoYWxmU3Ryb2tlV2lkdGggKiAoaXNDdXN0b21TaGFwZSA/IC0xIDogMSksXG4gICAgd2lkdGg6IHdpZHRoICsgc3Ryb2tlV2lkdGgsXG4gICAgaGVpZ2h0OiB3aWR0aFxuICB9KSkpO1xufSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZVB1YlN1YigpIHtcbiAgY29uc3QgbWFwID0gbmV3IE1hcCgpO1xuICByZXR1cm4ge1xuICAgIGVtaXQoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHZhciBfbWFwJGdldDtcbiAgICAgIChfbWFwJGdldCA9IG1hcC5nZXQoZXZlbnQpKSA9PSBudWxsIHx8IF9tYXAkZ2V0LmZvckVhY2goaGFuZGxlciA9PiBoYW5kbGVyKGRhdGEpKTtcbiAgICB9LFxuICAgIG9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgbWFwLnNldChldmVudCwgWy4uLihtYXAuZ2V0KGV2ZW50KSB8fCBbXSksIGxpc3RlbmVyXSk7XG4gICAgfSxcbiAgICBvZmYoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgX21hcCRnZXQyO1xuICAgICAgbWFwLnNldChldmVudCwgKChfbWFwJGdldDIgPSBtYXAuZ2V0KGV2ZW50KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9tYXAkZ2V0Mi5maWx0ZXIobCA9PiBsICE9PSBsaXN0ZW5lcikpIHx8IFtdKTtcbiAgICB9XG4gIH07XG59XG5cbmNvbnN0IEZsb2F0aW5nTm9kZUNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbmNvbnN0IEZsb2F0aW5nVHJlZUNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwYXJlbnQgbm9kZSBpZCBmb3IgbmVzdGVkIGZsb2F0aW5nIGVsZW1lbnRzLCBpZiBhdmFpbGFibGUuXG4gKiBSZXR1cm5zIGBudWxsYCBmb3IgdG9wLWxldmVsIGZsb2F0aW5nIGVsZW1lbnRzLlxuICovXG5jb25zdCB1c2VGbG9hdGluZ1BhcmVudE5vZGVJZCA9ICgpID0+IHtcbiAgdmFyIF9SZWFjdCR1c2VDb250ZXh0O1xuICByZXR1cm4gKChfUmVhY3QkdXNlQ29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoRmxvYXRpbmdOb2RlQ29udGV4dCkpID09IG51bGwgPyB2b2lkIDAgOiBfUmVhY3QkdXNlQ29udGV4dC5pZCkgfHwgbnVsbDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbmVhcmVzdCBmbG9hdGluZyB0cmVlIGNvbnRleHQsIGlmIGF2YWlsYWJsZS5cbiAqL1xuY29uc3QgdXNlRmxvYXRpbmdUcmVlID0gKCkgPT4gUmVhY3QudXNlQ29udGV4dChGbG9hdGluZ1RyZWVDb250ZXh0KTtcblxuLyoqXG4gKiBSZWdpc3RlcnMgYSBub2RlIGludG8gdGhlIGBGbG9hdGluZ1RyZWVgLCByZXR1cm5pbmcgaXRzIGlkLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL0Zsb2F0aW5nVHJlZVxuICovXG5mdW5jdGlvbiB1c2VGbG9hdGluZ05vZGVJZChjdXN0b21QYXJlbnRJZCkge1xuICBjb25zdCBpZCA9IHVzZUlkKCk7XG4gIGNvbnN0IHRyZWUgPSB1c2VGbG9hdGluZ1RyZWUoKTtcbiAgY29uc3QgcmVhY3RQYXJlbnRJZCA9IHVzZUZsb2F0aW5nUGFyZW50Tm9kZUlkKCk7XG4gIGNvbnN0IHBhcmVudElkID0gY3VzdG9tUGFyZW50SWQgfHwgcmVhY3RQYXJlbnRJZDtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICBpZCxcbiAgICAgIHBhcmVudElkXG4gICAgfTtcbiAgICB0cmVlID09IG51bGwgfHwgdHJlZS5hZGROb2RlKG5vZGUpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB0cmVlID09IG51bGwgfHwgdHJlZS5yZW1vdmVOb2RlKG5vZGUpO1xuICAgIH07XG4gIH0sIFt0cmVlLCBpZCwgcGFyZW50SWRdKTtcbiAgcmV0dXJuIGlkO1xufVxuXG4vKipcbiAqIFByb3ZpZGVzIHBhcmVudCBub2RlIGNvbnRleHQgZm9yIG5lc3RlZCBmbG9hdGluZyBlbGVtZW50cy5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9GbG9hdGluZ1RyZWVcbiAqL1xuZnVuY3Rpb24gRmxvYXRpbmdOb2RlKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBjaGlsZHJlbixcbiAgICBpZFxuICB9ID0gX3JlZjtcbiAgY29uc3QgcGFyZW50SWQgPSB1c2VGbG9hdGluZ1BhcmVudE5vZGVJZCgpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRmxvYXRpbmdOb2RlQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgICBpZCxcbiAgICAgIHBhcmVudElkXG4gICAgfSksIFtpZCwgcGFyZW50SWRdKVxuICB9LCBjaGlsZHJlbik7XG59XG5cbi8qKlxuICogUHJvdmlkZXMgY29udGV4dCBmb3IgbmVzdGVkIGZsb2F0aW5nIGVsZW1lbnRzIHdoZW4gdGhleSBhcmUgbm90IGNoaWxkcmVuIG9mXG4gKiBlYWNoIG90aGVyIG9uIHRoZSBET00uXG4gKiBUaGlzIGlzIG5vdCBuZWNlc3NhcnkgaW4gYWxsIGNhc2VzLCBleGNlcHQgd2hlbiB0aGVyZSBtdXN0IGJlIGV4cGxpY2l0IGNvbW11bmljYXRpb24gYmV0d2VlbiBwYXJlbnQgYW5kIGNoaWxkIGZsb2F0aW5nIGVsZW1lbnRzLiBJdCBpcyBuZWNlc3NhcnkgZm9yOlxuICogLSBUaGUgYGJ1YmJsZXNgIG9wdGlvbiBpbiB0aGUgYHVzZURpc21pc3MoKWAgSG9va1xuICogLSBOZXN0ZWQgdmlydHVhbCBsaXN0IG5hdmlnYXRpb25cbiAqIC0gTmVzdGVkIGZsb2F0aW5nIGVsZW1lbnRzIHRoYXQgZWFjaCBvcGVuIG9uIGhvdmVyXG4gKiAtIEN1c3RvbSBjb21tdW5pY2F0aW9uIGJldHdlZW4gcGFyZW50IGFuZCBjaGlsZCBmbG9hdGluZyBlbGVtZW50c1xuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL0Zsb2F0aW5nVHJlZVxuICovXG5mdW5jdGlvbiBGbG9hdGluZ1RyZWUoX3JlZjIpIHtcbiAgbGV0IHtcbiAgICBjaGlsZHJlblxuICB9ID0gX3JlZjI7XG4gIGNvbnN0IG5vZGVzUmVmID0gUmVhY3QudXNlUmVmKFtdKTtcbiAgY29uc3QgYWRkTm9kZSA9IFJlYWN0LnVzZUNhbGxiYWNrKG5vZGUgPT4ge1xuICAgIG5vZGVzUmVmLmN1cnJlbnQgPSBbLi4ubm9kZXNSZWYuY3VycmVudCwgbm9kZV07XG4gIH0sIFtdKTtcbiAgY29uc3QgcmVtb3ZlTm9kZSA9IFJlYWN0LnVzZUNhbGxiYWNrKG5vZGUgPT4ge1xuICAgIG5vZGVzUmVmLmN1cnJlbnQgPSBub2Rlc1JlZi5jdXJyZW50LmZpbHRlcihuID0+IG4gIT09IG5vZGUpO1xuICB9LCBbXSk7XG4gIGNvbnN0IGV2ZW50cyA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IGNyZWF0ZVB1YlN1YigpKVswXTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZsb2F0aW5nVHJlZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgICAgbm9kZXNSZWYsXG4gICAgICBhZGROb2RlLFxuICAgICAgcmVtb3ZlTm9kZSxcbiAgICAgIGV2ZW50c1xuICAgIH0pLCBbYWRkTm9kZSwgcmVtb3ZlTm9kZSwgZXZlbnRzXSlcbiAgfSwgY2hpbGRyZW4pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBdHRyaWJ1dGUobmFtZSkge1xuICByZXR1cm4gXCJkYXRhLWZsb2F0aW5nLXVpLVwiICsgbmFtZTtcbn1cblxuZnVuY3Rpb24gdXNlTGF0ZXN0UmVmKHZhbHVlKSB7XG4gIGNvbnN0IHJlZiA9IHVzZVJlZih2YWx1ZSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlZjtcbn1cblxuY29uc3Qgc2FmZVBvbHlnb25JZGVudGlmaWVyID0gLyojX19QVVJFX18qL2NyZWF0ZUF0dHJpYnV0ZSgnc2FmZS1wb2x5Z29uJyk7XG5mdW5jdGlvbiBnZXREZWxheSh2YWx1ZSwgcHJvcCwgcG9pbnRlclR5cGUpIHtcbiAgaWYgKHBvaW50ZXJUeXBlICYmICFpc01vdXNlTGlrZVBvaW50ZXJUeXBlKHBvaW50ZXJUeXBlKSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gdm9pZCAwIDogdmFsdWVbcHJvcF07XG59XG4vKipcbiAqIE9wZW5zIHRoZSBmbG9hdGluZyBlbGVtZW50IHdoaWxlIGhvdmVyaW5nIG92ZXIgdGhlIHJlZmVyZW5jZSBlbGVtZW50LCBsaWtlXG4gKiBDU1MgYDpob3ZlcmAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlSG92ZXJcbiAqL1xuZnVuY3Rpb24gdXNlSG92ZXIoY29udGV4dCwgcHJvcHMpIHtcbiAgaWYgKHByb3BzID09PSB2b2lkIDApIHtcbiAgICBwcm9wcyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBvcGVuLFxuICAgIG9uT3BlbkNoYW5nZSxcbiAgICBkYXRhUmVmLFxuICAgIGV2ZW50cyxcbiAgICBlbGVtZW50czoge1xuICAgICAgZG9tUmVmZXJlbmNlLFxuICAgICAgZmxvYXRpbmdcbiAgICB9LFxuICAgIHJlZnNcbiAgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IHtcbiAgICBlbmFibGVkID0gdHJ1ZSxcbiAgICBkZWxheSA9IDAsXG4gICAgaGFuZGxlQ2xvc2UgPSBudWxsLFxuICAgIG1vdXNlT25seSA9IGZhbHNlLFxuICAgIHJlc3RNcyA9IDAsXG4gICAgbW92ZSA9IHRydWVcbiAgfSA9IHByb3BzO1xuICBjb25zdCB0cmVlID0gdXNlRmxvYXRpbmdUcmVlKCk7XG4gIGNvbnN0IHBhcmVudElkID0gdXNlRmxvYXRpbmdQYXJlbnROb2RlSWQoKTtcbiAgY29uc3QgaGFuZGxlQ2xvc2VSZWYgPSB1c2VMYXRlc3RSZWYoaGFuZGxlQ2xvc2UpO1xuICBjb25zdCBkZWxheVJlZiA9IHVzZUxhdGVzdFJlZihkZWxheSk7XG4gIGNvbnN0IHBvaW50ZXJUeXBlUmVmID0gUmVhY3QudXNlUmVmKCk7XG4gIGNvbnN0IHRpbWVvdXRSZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgY29uc3QgaGFuZGxlclJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICBjb25zdCByZXN0VGltZW91dFJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICBjb25zdCBibG9ja01vdXNlTW92ZVJlZiA9IFJlYWN0LnVzZVJlZih0cnVlKTtcbiAgY29uc3QgcGVyZm9ybWVkUG9pbnRlckV2ZW50c011dGF0aW9uUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgdW5iaW5kTW91c2VNb3ZlUmVmID0gUmVhY3QudXNlUmVmKCgpID0+IHt9KTtcbiAgY29uc3QgaXNIb3Zlck9wZW4gPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgdmFyIF9kYXRhUmVmJGN1cnJlbnQkb3BlbjtcbiAgICBjb25zdCB0eXBlID0gKF9kYXRhUmVmJGN1cnJlbnQkb3BlbiA9IGRhdGFSZWYuY3VycmVudC5vcGVuRXZlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YVJlZiRjdXJyZW50JG9wZW4udHlwZTtcbiAgICByZXR1cm4gKHR5cGUgPT0gbnVsbCA/IHZvaWQgMCA6IHR5cGUuaW5jbHVkZXMoJ21vdXNlJykpICYmIHR5cGUgIT09ICdtb3VzZWRvd24nO1xuICB9LCBbZGF0YVJlZl0pO1xuXG4gIC8vIFdoZW4gY2xvc2luZyBiZWZvcmUgb3BlbmluZywgY2xlYXIgdGhlIGRlbGF5IHRpbWVvdXRzIHRvIGNhbmNlbCBpdFxuICAvLyBmcm9tIHNob3dpbmcuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uT3BlbkNoYW5nZShfcmVmKSB7XG4gICAgICBsZXQge1xuICAgICAgICBvcGVuXG4gICAgICB9ID0gX3JlZjtcbiAgICAgIGlmICghb3Blbikge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHJlc3RUaW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgICAgICBibG9ja01vdXNlTW92ZVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZXZlbnRzLm9uKCdvcGVuY2hhbmdlJywgb25PcGVuQ2hhbmdlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZXZlbnRzLm9mZignb3BlbmNoYW5nZScsIG9uT3BlbkNoYW5nZSk7XG4gICAgfTtcbiAgfSwgW2VuYWJsZWQsIGV2ZW50c10pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCB8fCAhaGFuZGxlQ2xvc2VSZWYuY3VycmVudCB8fCAhb3Blbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbkxlYXZlKGV2ZW50KSB7XG4gICAgICBpZiAoaXNIb3Zlck9wZW4oKSkge1xuICAgICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50LCAnaG92ZXInKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaHRtbCA9IGdldERvY3VtZW50KGZsb2F0aW5nKS5kb2N1bWVudEVsZW1lbnQ7XG4gICAgaHRtbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgb25MZWF2ZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGh0bWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIG9uTGVhdmUpO1xuICAgIH07XG4gIH0sIFtmbG9hdGluZywgb3Blbiwgb25PcGVuQ2hhbmdlLCBlbmFibGVkLCBoYW5kbGVDbG9zZVJlZiwgaXNIb3Zlck9wZW5dKTtcbiAgY29uc3QgY2xvc2VXaXRoRGVsYXkgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZXZlbnQsIHJ1bkVsc2VCcmFuY2gsIHJlYXNvbikge1xuICAgIGlmIChydW5FbHNlQnJhbmNoID09PSB2b2lkIDApIHtcbiAgICAgIHJ1bkVsc2VCcmFuY2ggPSB0cnVlO1xuICAgIH1cbiAgICBpZiAocmVhc29uID09PSB2b2lkIDApIHtcbiAgICAgIHJlYXNvbiA9ICdob3Zlcic7XG4gICAgfVxuICAgIGNvbnN0IGNsb3NlRGVsYXkgPSBnZXREZWxheShkZWxheVJlZi5jdXJyZW50LCAnY2xvc2UnLCBwb2ludGVyVHlwZVJlZi5jdXJyZW50KTtcbiAgICBpZiAoY2xvc2VEZWxheSAmJiAhaGFuZGxlclJlZi5jdXJyZW50KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgIHRpbWVvdXRSZWYuY3VycmVudCA9IHNldFRpbWVvdXQoKCkgPT4gb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudCwgcmVhc29uKSwgY2xvc2VEZWxheSk7XG4gICAgfSBlbHNlIGlmIChydW5FbHNlQnJhbmNoKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgIG9uT3BlbkNoYW5nZShmYWxzZSwgZXZlbnQsIHJlYXNvbik7XG4gICAgfVxuICB9LCBbZGVsYXlSZWYsIG9uT3BlbkNoYW5nZV0pO1xuICBjb25zdCBjbGVhbnVwTW91c2VNb3ZlSGFuZGxlciA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICB1bmJpbmRNb3VzZU1vdmVSZWYuY3VycmVudCgpO1xuICAgIGhhbmRsZXJSZWYuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgfSwgW10pO1xuICBjb25zdCBjbGVhclBvaW50ZXJFdmVudHMgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKHBlcmZvcm1lZFBvaW50ZXJFdmVudHNNdXRhdGlvblJlZi5jdXJyZW50KSB7XG4gICAgICBjb25zdCBib2R5ID0gZ2V0RG9jdW1lbnQocmVmcy5mbG9hdGluZy5jdXJyZW50KS5ib2R5O1xuICAgICAgYm9keS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJyc7XG4gICAgICBib2R5LnJlbW92ZUF0dHJpYnV0ZShzYWZlUG9seWdvbklkZW50aWZpZXIpO1xuICAgICAgcGVyZm9ybWVkUG9pbnRlckV2ZW50c011dGF0aW9uUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9XG4gIH0sIFtyZWZzXSk7XG5cbiAgLy8gUmVnaXN0ZXJpbmcgdGhlIG1vdXNlIGV2ZW50cyBvbiB0aGUgcmVmZXJlbmNlIGRpcmVjdGx5IHRvIGJ5cGFzcyBSZWFjdCdzXG4gIC8vIGRlbGVnYXRpb24gc3lzdGVtLiBJZiB0aGUgY3Vyc29yIHdhcyBvbiBhIGRpc2FibGVkIGVsZW1lbnQgYW5kIHRoZW4gZW50ZXJlZFxuICAvLyB0aGUgcmVmZXJlbmNlIChubyBnYXApLCBgbW91c2VlbnRlcmAgZG9lc24ndCBmaXJlIGluIHRoZSBkZWxlZ2F0aW9uIHN5c3RlbS5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNDbGlja0xpa2VPcGVuRXZlbnQoKSB7XG4gICAgICByZXR1cm4gZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudCA/IFsnY2xpY2snLCAnbW91c2Vkb3duJ10uaW5jbHVkZXMoZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudC50eXBlKSA6IGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbk1vdXNlRW50ZXIoZXZlbnQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgICAgYmxvY2tNb3VzZU1vdmVSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgaWYgKG1vdXNlT25seSAmJiAhaXNNb3VzZUxpa2VQb2ludGVyVHlwZShwb2ludGVyVHlwZVJlZi5jdXJyZW50KSB8fCByZXN0TXMgPiAwICYmIGdldERlbGF5KGRlbGF5UmVmLmN1cnJlbnQsICdvcGVuJykgPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3BlbkRlbGF5ID0gZ2V0RGVsYXkoZGVsYXlSZWYuY3VycmVudCwgJ29wZW4nLCBwb2ludGVyVHlwZVJlZi5jdXJyZW50KTtcbiAgICAgIGlmIChvcGVuRGVsYXkpIHtcbiAgICAgICAgdGltZW91dFJlZi5jdXJyZW50ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgb25PcGVuQ2hhbmdlKHRydWUsIGV2ZW50LCAnaG92ZXInKTtcbiAgICAgICAgfSwgb3BlbkRlbGF5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uT3BlbkNoYW5nZSh0cnVlLCBldmVudCwgJ2hvdmVyJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uTW91c2VMZWF2ZShldmVudCkge1xuICAgICAgaWYgKGlzQ2xpY2tMaWtlT3BlbkV2ZW50KCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdW5iaW5kTW91c2VNb3ZlUmVmLmN1cnJlbnQoKTtcbiAgICAgIGNvbnN0IGRvYyA9IGdldERvY3VtZW50KGZsb2F0aW5nKTtcbiAgICAgIGNsZWFyVGltZW91dChyZXN0VGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgIGlmIChoYW5kbGVDbG9zZVJlZi5jdXJyZW50KSB7XG4gICAgICAgIC8vIFByZXZlbnQgY2xlYXJpbmcgYG9uU2Nyb2xsTW91c2VMZWF2ZWAgdGltZW91dC5cbiAgICAgICAgaWYgKCFvcGVuKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlclJlZi5jdXJyZW50ID0gaGFuZGxlQ2xvc2VSZWYuY3VycmVudCh7XG4gICAgICAgICAgLi4uY29udGV4dCxcbiAgICAgICAgICB0cmVlLFxuICAgICAgICAgIHg6IGV2ZW50LmNsaWVudFgsXG4gICAgICAgICAgeTogZXZlbnQuY2xpZW50WSxcbiAgICAgICAgICBvbkNsb3NlKCkge1xuICAgICAgICAgICAgY2xlYXJQb2ludGVyRXZlbnRzKCk7XG4gICAgICAgICAgICBjbGVhbnVwTW91c2VNb3ZlSGFuZGxlcigpO1xuICAgICAgICAgICAgY2xvc2VXaXRoRGVsYXkoZXZlbnQsIHRydWUsICdzYWZlLXBvbHlnb24nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gaGFuZGxlclJlZi5jdXJyZW50O1xuICAgICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgaGFuZGxlcik7XG4gICAgICAgIHVuYmluZE1vdXNlTW92ZVJlZi5jdXJyZW50ID0gKCkgPT4ge1xuICAgICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBoYW5kbGVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBBbGxvdyBpbnRlcmFjdGl2aXR5IHdpdGhvdXQgYHNhZmVQb2x5Z29uYCBvbiB0b3VjaCBkZXZpY2VzLiBXaXRoIGFcbiAgICAgIC8vIHBvaW50ZXIsIGEgc2hvcnQgY2xvc2UgZGVsYXkgaXMgYW4gYWx0ZXJuYXRpdmUsIHNvIGl0IHNob3VsZCB3b3JrXG4gICAgICAvLyBjb25zaXN0ZW50bHkuXG4gICAgICBjb25zdCBzaG91bGRDbG9zZSA9IHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQgPT09ICd0b3VjaCcgPyAhY29udGFpbnMoZmxvYXRpbmcsIGV2ZW50LnJlbGF0ZWRUYXJnZXQpIDogdHJ1ZTtcbiAgICAgIGlmIChzaG91bGRDbG9zZSkge1xuICAgICAgICBjbG9zZVdpdGhEZWxheShldmVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIHRoZSBmbG9hdGluZyBlbGVtZW50IGNsb3NlcyBhZnRlciBzY3JvbGxpbmcgZXZlbiBpZiB0aGUgcG9pbnRlclxuICAgIC8vIGRpZCBub3QgbW92ZS5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmxvYXRpbmctdWkvZmxvYXRpbmctdWkvZGlzY3Vzc2lvbnMvMTY5MlxuICAgIGZ1bmN0aW9uIG9uU2Nyb2xsTW91c2VMZWF2ZShldmVudCkge1xuICAgICAgaWYgKGlzQ2xpY2tMaWtlT3BlbkV2ZW50KCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaGFuZGxlQ2xvc2VSZWYuY3VycmVudCA9PSBudWxsIHx8IGhhbmRsZUNsb3NlUmVmLmN1cnJlbnQoe1xuICAgICAgICAuLi5jb250ZXh0LFxuICAgICAgICB0cmVlLFxuICAgICAgICB4OiBldmVudC5jbGllbnRYLFxuICAgICAgICB5OiBldmVudC5jbGllbnRZLFxuICAgICAgICBvbkNsb3NlKCkge1xuICAgICAgICAgIGNsZWFyUG9pbnRlckV2ZW50cygpO1xuICAgICAgICAgIGNsZWFudXBNb3VzZU1vdmVIYW5kbGVyKCk7XG4gICAgICAgICAgY2xvc2VXaXRoRGVsYXkoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9KShldmVudCk7XG4gICAgfVxuICAgIGlmIChpc0VsZW1lbnQoZG9tUmVmZXJlbmNlKSkge1xuICAgICAgY29uc3QgcmVmID0gZG9tUmVmZXJlbmNlO1xuICAgICAgb3BlbiAmJiByZWYuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIG9uU2Nyb2xsTW91c2VMZWF2ZSk7XG4gICAgICBmbG9hdGluZyA9PSBudWxsIHx8IGZsb2F0aW5nLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBvblNjcm9sbE1vdXNlTGVhdmUpO1xuICAgICAgbW92ZSAmJiByZWYuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Nb3VzZUVudGVyLCB7XG4gICAgICAgIG9uY2U6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmVmLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCBvbk1vdXNlRW50ZXIpO1xuICAgICAgcmVmLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBvbk1vdXNlTGVhdmUpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgb3BlbiAmJiByZWYucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIG9uU2Nyb2xsTW91c2VMZWF2ZSk7XG4gICAgICAgIGZsb2F0aW5nID09IG51bGwgfHwgZmxvYXRpbmcucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIG9uU2Nyb2xsTW91c2VMZWF2ZSk7XG4gICAgICAgIG1vdmUgJiYgcmVmLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uTW91c2VFbnRlcik7XG4gICAgICAgIHJlZi5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgb25Nb3VzZUVudGVyKTtcbiAgICAgICAgcmVmLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBvbk1vdXNlTGVhdmUpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFtkb21SZWZlcmVuY2UsIGZsb2F0aW5nLCBlbmFibGVkLCBjb250ZXh0LCBtb3VzZU9ubHksIHJlc3RNcywgbW92ZSwgY2xvc2VXaXRoRGVsYXksIGNsZWFudXBNb3VzZU1vdmVIYW5kbGVyLCBjbGVhclBvaW50ZXJFdmVudHMsIG9uT3BlbkNoYW5nZSwgb3BlbiwgdHJlZSwgZGVsYXlSZWYsIGhhbmRsZUNsb3NlUmVmLCBkYXRhUmVmXSk7XG5cbiAgLy8gQmxvY2sgcG9pbnRlci1ldmVudHMgb2YgZXZlcnkgZWxlbWVudCBvdGhlciB0aGFuIHRoZSByZWZlcmVuY2UgYW5kIGZsb2F0aW5nXG4gIC8vIHdoaWxlIHRoZSBmbG9hdGluZyBlbGVtZW50IGlzIG9wZW4gYW5kIGhhcyBhIGBoYW5kbGVDbG9zZWAgaGFuZGxlci4gQWxzb1xuICAvLyBoYW5kbGVzIG5lc3RlZCBmbG9hdGluZyBlbGVtZW50cy5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zsb2F0aW5nLXVpL2Zsb2F0aW5nLXVpL2lzc3Vlcy8xNzIyXG4gIGluZGV4KCgpID0+IHtcbiAgICB2YXIgX2hhbmRsZUNsb3NlUmVmJGN1cnJlO1xuICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAob3BlbiAmJiAoX2hhbmRsZUNsb3NlUmVmJGN1cnJlID0gaGFuZGxlQ2xvc2VSZWYuY3VycmVudCkgIT0gbnVsbCAmJiBfaGFuZGxlQ2xvc2VSZWYkY3VycmUuX19vcHRpb25zLmJsb2NrUG9pbnRlckV2ZW50cyAmJiBpc0hvdmVyT3BlbigpKSB7XG4gICAgICBjb25zdCBib2R5ID0gZ2V0RG9jdW1lbnQoZmxvYXRpbmcpLmJvZHk7XG4gICAgICBib2R5LnNldEF0dHJpYnV0ZShzYWZlUG9seWdvbklkZW50aWZpZXIsICcnKTtcbiAgICAgIGJvZHkuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICAgIHBlcmZvcm1lZFBvaW50ZXJFdmVudHNNdXRhdGlvblJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIGlmIChpc0VsZW1lbnQoZG9tUmVmZXJlbmNlKSAmJiBmbG9hdGluZykge1xuICAgICAgICB2YXIgX3RyZWUkbm9kZXNSZWYkY3VycmVuO1xuICAgICAgICBjb25zdCByZWYgPSBkb21SZWZlcmVuY2U7XG4gICAgICAgIGNvbnN0IHBhcmVudEZsb2F0aW5nID0gdHJlZSA9PSBudWxsIHx8IChfdHJlZSRub2Rlc1JlZiRjdXJyZW4gPSB0cmVlLm5vZGVzUmVmLmN1cnJlbnQuZmluZChub2RlID0+IG5vZGUuaWQgPT09IHBhcmVudElkKSkgPT0gbnVsbCB8fCAoX3RyZWUkbm9kZXNSZWYkY3VycmVuID0gX3RyZWUkbm9kZXNSZWYkY3VycmVuLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfdHJlZSRub2Rlc1JlZiRjdXJyZW4uZWxlbWVudHMuZmxvYXRpbmc7XG4gICAgICAgIGlmIChwYXJlbnRGbG9hdGluZykge1xuICAgICAgICAgIHBhcmVudEZsb2F0aW5nLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnJztcbiAgICAgICAgfVxuICAgICAgICByZWYuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdhdXRvJztcbiAgICAgICAgZmxvYXRpbmcuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdhdXRvJztcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICByZWYuc3R5bGUucG9pbnRlckV2ZW50cyA9ICcnO1xuICAgICAgICAgIGZsb2F0aW5nLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnJztcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtlbmFibGVkLCBvcGVuLCBwYXJlbnRJZCwgZmxvYXRpbmcsIGRvbVJlZmVyZW5jZSwgdHJlZSwgaGFuZGxlQ2xvc2VSZWYsIGlzSG92ZXJPcGVuXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoIW9wZW4pIHtcbiAgICAgIHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICBjbGVhbnVwTW91c2VNb3ZlSGFuZGxlcigpO1xuICAgICAgY2xlYXJQb2ludGVyRXZlbnRzKCk7XG4gICAgfVxuICB9LCBbb3BlbiwgY2xlYW51cE1vdXNlTW92ZUhhbmRsZXIsIGNsZWFyUG9pbnRlckV2ZW50c10pO1xuXG4gIC8vIGJpb21lLWlnbm9yZSBsaW50L2NvcnJlY3RuZXNzL3VzZUV4aGF1c3RpdmVEZXBlbmRlbmNpZXM6IGludGVudGlvbmFsXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNsZWFudXBNb3VzZU1vdmVIYW5kbGVyKCk7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgIGNsZWFyVGltZW91dChyZXN0VGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgIGNsZWFyUG9pbnRlckV2ZW50cygpO1xuICAgIH07XG4gIH0sIFtlbmFibGVkLCBkb21SZWZlcmVuY2UsIGNsZWFudXBNb3VzZU1vdmVIYW5kbGVyLCBjbGVhclBvaW50ZXJFdmVudHNdKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRQb2ludGVyUmVmKGV2ZW50KSB7XG4gICAgICBwb2ludGVyVHlwZVJlZi5jdXJyZW50ID0gZXZlbnQucG9pbnRlclR5cGU7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICByZWZlcmVuY2U6IHtcbiAgICAgICAgb25Qb2ludGVyRG93bjogc2V0UG9pbnRlclJlZixcbiAgICAgICAgb25Qb2ludGVyRW50ZXI6IHNldFBvaW50ZXJSZWYsXG4gICAgICAgIG9uTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgICAgICAgaWYgKG9wZW4gfHwgcmVzdE1zID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNsZWFyVGltZW91dChyZXN0VGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgICAgICByZXN0VGltZW91dFJlZi5jdXJyZW50ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWJsb2NrTW91c2VNb3ZlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgb25PcGVuQ2hhbmdlKHRydWUsIGV2ZW50Lm5hdGl2ZUV2ZW50LCAnaG92ZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCByZXN0TXMpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZmxvYXRpbmc6IHtcbiAgICAgICAgb25Nb3VzZUVudGVyKCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgICAgICB9LFxuICAgICAgICBvbk1vdXNlTGVhdmUoZXZlbnQpIHtcbiAgICAgICAgICBjbG9zZVdpdGhEZWxheShldmVudC5uYXRpdmVFdmVudCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2VuYWJsZWQsIHJlc3RNcywgb3Blbiwgb25PcGVuQ2hhbmdlLCBjbG9zZVdpdGhEZWxheV0pO1xufVxuXG5jb25zdCBGbG9hdGluZ0RlbGF5R3JvdXBDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQoe1xuICBkZWxheTogMCxcbiAgaW5pdGlhbERlbGF5OiAwLFxuICB0aW1lb3V0TXM6IDAsXG4gIGN1cnJlbnRJZDogbnVsbCxcbiAgc2V0Q3VycmVudElkOiAoKSA9PiB7fSxcbiAgc2V0U3RhdGU6ICgpID0+IHt9LFxuICBpc0luc3RhbnRQaGFzZTogZmFsc2Vcbn0pO1xuY29uc3QgdXNlRGVsYXlHcm91cENvbnRleHQgPSAoKSA9PiBSZWFjdC51c2VDb250ZXh0KEZsb2F0aW5nRGVsYXlHcm91cENvbnRleHQpO1xuLyoqXG4gKiBQcm92aWRlcyBjb250ZXh0IGZvciBhIGdyb3VwIG9mIGZsb2F0aW5nIGVsZW1lbnRzIHRoYXQgc2hvdWxkIHNoYXJlIGFcbiAqIGBkZWxheWAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvRmxvYXRpbmdEZWxheUdyb3VwXG4gKi9cbmNvbnN0IEZsb2F0aW5nRGVsYXlHcm91cCA9IF9yZWYgPT4ge1xuICBsZXQge1xuICAgIGNoaWxkcmVuLFxuICAgIGRlbGF5LFxuICAgIHRpbWVvdXRNcyA9IDBcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gUmVhY3QudXNlUmVkdWNlcigocHJldiwgbmV4dCkgPT4gKHtcbiAgICAuLi5wcmV2LFxuICAgIC4uLm5leHRcbiAgfSksIHtcbiAgICBkZWxheSxcbiAgICB0aW1lb3V0TXMsXG4gICAgaW5pdGlhbERlbGF5OiBkZWxheSxcbiAgICBjdXJyZW50SWQ6IG51bGwsXG4gICAgaXNJbnN0YW50UGhhc2U6IGZhbHNlXG4gIH0pO1xuICBjb25zdCBpbml0aWFsQ3VycmVudElkUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBzZXRDdXJyZW50SWQgPSBSZWFjdC51c2VDYWxsYmFjayhjdXJyZW50SWQgPT4ge1xuICAgIHNldFN0YXRlKHtcbiAgICAgIGN1cnJlbnRJZFxuICAgIH0pO1xuICB9LCBbXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoc3RhdGUuY3VycmVudElkKSB7XG4gICAgICBpZiAoaW5pdGlhbEN1cnJlbnRJZFJlZi5jdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgIGluaXRpYWxDdXJyZW50SWRSZWYuY3VycmVudCA9IHN0YXRlLmN1cnJlbnRJZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICBpc0luc3RhbnRQaGFzZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2V0U3RhdGUoe1xuICAgICAgICBpc0luc3RhbnRQaGFzZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgaW5pdGlhbEN1cnJlbnRJZFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gIH0sIFtzdGF0ZS5jdXJyZW50SWRdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZsb2F0aW5nRGVsYXlHcm91cENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgICAgLi4uc3RhdGUsXG4gICAgICBzZXRTdGF0ZSxcbiAgICAgIHNldEN1cnJlbnRJZFxuICAgIH0pLCBbc3RhdGUsIHNldEN1cnJlbnRJZF0pXG4gIH0sIGNoaWxkcmVuKTtcbn07XG4vKipcbiAqIEVuYWJsZXMgZ3JvdXBpbmcgd2hlbiBjYWxsZWQgaW5zaWRlIGEgY29tcG9uZW50IHRoYXQncyBhIGNoaWxkIG9mIGFcbiAqIGBGbG9hdGluZ0RlbGF5R3JvdXBgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL0Zsb2F0aW5nRGVsYXlHcm91cFxuICovXG5jb25zdCB1c2VEZWxheUdyb3VwID0gKF9yZWYyLCBfcmVmMykgPT4ge1xuICBsZXQge1xuICAgIG9wZW4sXG4gICAgb25PcGVuQ2hhbmdlXG4gIH0gPSBfcmVmMjtcbiAgbGV0IHtcbiAgICBpZFxuICB9ID0gX3JlZjM7XG4gIGNvbnN0IHtcbiAgICBjdXJyZW50SWQsXG4gICAgc2V0Q3VycmVudElkLFxuICAgIGluaXRpYWxEZWxheSxcbiAgICBzZXRTdGF0ZSxcbiAgICB0aW1lb3V0TXNcbiAgfSA9IHVzZURlbGF5R3JvdXBDb250ZXh0KCk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoY3VycmVudElkKSB7XG4gICAgICBzZXRTdGF0ZSh7XG4gICAgICAgIGRlbGF5OiB7XG4gICAgICAgICAgb3BlbjogMSxcbiAgICAgICAgICBjbG9zZTogZ2V0RGVsYXkoaW5pdGlhbERlbGF5LCAnY2xvc2UnKVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChjdXJyZW50SWQgIT09IGlkKSB7XG4gICAgICAgIG9uT3BlbkNoYW5nZShmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCBbaWQsIG9uT3BlbkNoYW5nZSwgc2V0U3RhdGUsIGN1cnJlbnRJZCwgaW5pdGlhbERlbGF5XSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBmdW5jdGlvbiB1bnNldCgpIHtcbiAgICAgIG9uT3BlbkNoYW5nZShmYWxzZSk7XG4gICAgICBzZXRTdGF0ZSh7XG4gICAgICAgIGRlbGF5OiBpbml0aWFsRGVsYXksXG4gICAgICAgIGN1cnJlbnRJZDogbnVsbFxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghb3BlbiAmJiBjdXJyZW50SWQgPT09IGlkKSB7XG4gICAgICBpZiAodGltZW91dE1zKSB7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCh1bnNldCwgdGltZW91dE1zKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB1bnNldCgpO1xuICAgIH1cbiAgfSwgW29wZW4sIHNldFN0YXRlLCBjdXJyZW50SWQsIGlkLCBvbk9wZW5DaGFuZ2UsIGluaXRpYWxEZWxheSwgdGltZW91dE1zXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAob3Blbikge1xuICAgICAgc2V0Q3VycmVudElkKGlkKTtcbiAgICB9XG4gIH0sIFtvcGVuLCBzZXRDdXJyZW50SWQsIGlkXSk7XG59O1xuXG5mdW5jdGlvbiBnZXRBbmNlc3RvcnMobm9kZXMsIGlkKSB7XG4gIHZhciBfbm9kZXMkZmluZDtcbiAgbGV0IGFsbEFuY2VzdG9ycyA9IFtdO1xuICBsZXQgY3VycmVudFBhcmVudElkID0gKF9ub2RlcyRmaW5kID0gbm9kZXMuZmluZChub2RlID0+IG5vZGUuaWQgPT09IGlkKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlcyRmaW5kLnBhcmVudElkO1xuICB3aGlsZSAoY3VycmVudFBhcmVudElkKSB7XG4gICAgY29uc3QgY3VycmVudE5vZGUgPSBub2Rlcy5maW5kKG5vZGUgPT4gbm9kZS5pZCA9PT0gY3VycmVudFBhcmVudElkKTtcbiAgICBjdXJyZW50UGFyZW50SWQgPSBjdXJyZW50Tm9kZSA9PSBudWxsID8gdm9pZCAwIDogY3VycmVudE5vZGUucGFyZW50SWQ7XG4gICAgaWYgKGN1cnJlbnROb2RlKSB7XG4gICAgICBhbGxBbmNlc3RvcnMgPSBhbGxBbmNlc3RvcnMuY29uY2F0KGN1cnJlbnROb2RlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFsbEFuY2VzdG9ycztcbn1cblxuZnVuY3Rpb24gZ2V0Q2hpbGRyZW4obm9kZXMsIGlkKSB7XG4gIGxldCBhbGxDaGlsZHJlbiA9IG5vZGVzLmZpbHRlcihub2RlID0+IHtcbiAgICB2YXIgX25vZGUkY29udGV4dDtcbiAgICByZXR1cm4gbm9kZS5wYXJlbnRJZCA9PT0gaWQgJiYgKChfbm9kZSRjb250ZXh0ID0gbm9kZS5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkY29udGV4dC5vcGVuKTtcbiAgfSk7XG4gIGxldCBjdXJyZW50Q2hpbGRyZW4gPSBhbGxDaGlsZHJlbjtcbiAgd2hpbGUgKGN1cnJlbnRDaGlsZHJlbi5sZW5ndGgpIHtcbiAgICBjdXJyZW50Q2hpbGRyZW4gPSBub2Rlcy5maWx0ZXIobm9kZSA9PiB7XG4gICAgICB2YXIgX2N1cnJlbnRDaGlsZHJlbjtcbiAgICAgIHJldHVybiAoX2N1cnJlbnRDaGlsZHJlbiA9IGN1cnJlbnRDaGlsZHJlbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9jdXJyZW50Q2hpbGRyZW4uc29tZShuID0+IHtcbiAgICAgICAgdmFyIF9ub2RlJGNvbnRleHQyO1xuICAgICAgICByZXR1cm4gbm9kZS5wYXJlbnRJZCA9PT0gbi5pZCAmJiAoKF9ub2RlJGNvbnRleHQyID0gbm9kZS5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkY29udGV4dDIub3Blbik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBhbGxDaGlsZHJlbiA9IGFsbENoaWxkcmVuLmNvbmNhdChjdXJyZW50Q2hpbGRyZW4pO1xuICB9XG4gIHJldHVybiBhbGxDaGlsZHJlbjtcbn1cbmZ1bmN0aW9uIGdldERlZXBlc3ROb2RlKG5vZGVzLCBpZCkge1xuICBsZXQgZGVlcGVzdE5vZGVJZDtcbiAgbGV0IG1heERlcHRoID0gLTE7XG4gIGZ1bmN0aW9uIGZpbmREZWVwZXN0KG5vZGVJZCwgZGVwdGgpIHtcbiAgICBpZiAoZGVwdGggPiBtYXhEZXB0aCkge1xuICAgICAgZGVlcGVzdE5vZGVJZCA9IG5vZGVJZDtcbiAgICAgIG1heERlcHRoID0gZGVwdGg7XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkcmVuID0gZ2V0Q2hpbGRyZW4obm9kZXMsIG5vZGVJZCk7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICBmaW5kRGVlcGVzdChjaGlsZC5pZCwgZGVwdGggKyAxKTtcbiAgICB9KTtcbiAgfVxuICBmaW5kRGVlcGVzdChpZCwgMCk7XG4gIHJldHVybiBub2Rlcy5maW5kKG5vZGUgPT4gbm9kZS5pZCA9PT0gZGVlcGVzdE5vZGVJZCk7XG59XG5cbi8vIE1vZGlmaWVkIHRvIGFkZCBjb25kaXRpb25hbCBgYXJpYS1oaWRkZW5gIHN1cHBvcnQ6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGhlS2FzaGV5L2FyaWEtaGlkZGVuL2Jsb2IvOTIyMGM4ZjRhNGZkMzVmNjNiZWU1NTEwYTlmNDFhMzcyNjQzODJkNC9zcmMvaW5kZXgudHNcbmxldCBjb3VudGVyTWFwID0gLyojX19QVVJFX18qL25ldyBXZWFrTWFwKCk7XG5sZXQgdW5jb250cm9sbGVkRWxlbWVudHNTZXQgPSAvKiNfX1BVUkVfXyovbmV3IFdlYWtTZXQoKTtcbmxldCBtYXJrZXJNYXAgPSB7fTtcbmxldCBsb2NrQ291bnQgPSAwO1xuY29uc3Qgc3VwcG9ydHNJbmVydCA9ICgpID0+IHR5cGVvZiBIVE1MRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2luZXJ0JyBpbiBIVE1MRWxlbWVudC5wcm90b3R5cGU7XG5jb25zdCB1bndyYXBIb3N0ID0gbm9kZSA9PiBub2RlICYmIChub2RlLmhvc3QgfHwgdW53cmFwSG9zdChub2RlLnBhcmVudE5vZGUpKTtcbmNvbnN0IGNvcnJlY3RFbGVtZW50cyA9IChwYXJlbnQsIHRhcmdldHMpID0+IHRhcmdldHMubWFwKHRhcmdldCA9PiB7XG4gIGlmIChwYXJlbnQuY29udGFpbnModGFyZ2V0KSkge1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgY29uc3QgY29ycmVjdGVkVGFyZ2V0ID0gdW53cmFwSG9zdCh0YXJnZXQpO1xuICBpZiAocGFyZW50LmNvbnRhaW5zKGNvcnJlY3RlZFRhcmdldCkpIHtcbiAgICByZXR1cm4gY29ycmVjdGVkVGFyZ2V0O1xuICB9XG4gIHJldHVybiBudWxsO1xufSkuZmlsdGVyKHggPT4geCAhPSBudWxsKTtcbmZ1bmN0aW9uIGFwcGx5QXR0cmlidXRlVG9PdGhlcnModW5jb3JyZWN0ZWRBdm9pZEVsZW1lbnRzLCBib2R5LCBhcmlhSGlkZGVuLCBpbmVydCkge1xuICBjb25zdCBtYXJrZXJOYW1lID0gJ2RhdGEtZmxvYXRpbmctdWktaW5lcnQnO1xuICBjb25zdCBjb250cm9sQXR0cmlidXRlID0gaW5lcnQgPyAnaW5lcnQnIDogYXJpYUhpZGRlbiA/ICdhcmlhLWhpZGRlbicgOiBudWxsO1xuICBjb25zdCBhdm9pZEVsZW1lbnRzID0gY29ycmVjdEVsZW1lbnRzKGJvZHksIHVuY29ycmVjdGVkQXZvaWRFbGVtZW50cyk7XG4gIGNvbnN0IGVsZW1lbnRzVG9LZWVwID0gbmV3IFNldCgpO1xuICBjb25zdCBlbGVtZW50c1RvU3RvcCA9IG5ldyBTZXQoYXZvaWRFbGVtZW50cyk7XG4gIGNvbnN0IGhpZGRlbkVsZW1lbnRzID0gW107XG4gIGlmICghbWFya2VyTWFwW21hcmtlck5hbWVdKSB7XG4gICAgbWFya2VyTWFwW21hcmtlck5hbWVdID0gbmV3IFdlYWtNYXAoKTtcbiAgfVxuICBjb25zdCBtYXJrZXJDb3VudGVyID0gbWFya2VyTWFwW21hcmtlck5hbWVdO1xuICBhdm9pZEVsZW1lbnRzLmZvckVhY2goa2VlcCk7XG4gIGRlZXAoYm9keSk7XG4gIGVsZW1lbnRzVG9LZWVwLmNsZWFyKCk7XG4gIGZ1bmN0aW9uIGtlZXAoZWwpIHtcbiAgICBpZiAoIWVsIHx8IGVsZW1lbnRzVG9LZWVwLmhhcyhlbCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxlbWVudHNUb0tlZXAuYWRkKGVsKTtcbiAgICBlbC5wYXJlbnROb2RlICYmIGtlZXAoZWwucGFyZW50Tm9kZSk7XG4gIH1cbiAgZnVuY3Rpb24gZGVlcChwYXJlbnQpIHtcbiAgICBpZiAoIXBhcmVudCB8fCBlbGVtZW50c1RvU3RvcC5oYXMocGFyZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKHBhcmVudC5jaGlsZHJlbiwgbm9kZSA9PiB7XG4gICAgICBpZiAoZWxlbWVudHNUb0tlZXAuaGFzKG5vZGUpKSB7XG4gICAgICAgIGRlZXAobm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBhdHRyID0gY29udHJvbEF0dHJpYnV0ZSA/IG5vZGUuZ2V0QXR0cmlidXRlKGNvbnRyb2xBdHRyaWJ1dGUpIDogbnVsbDtcbiAgICAgICAgY29uc3QgYWxyZWFkeUhpZGRlbiA9IGF0dHIgIT09IG51bGwgJiYgYXR0ciAhPT0gJ2ZhbHNlJztcbiAgICAgICAgY29uc3QgY291bnRlclZhbHVlID0gKGNvdW50ZXJNYXAuZ2V0KG5vZGUpIHx8IDApICsgMTtcbiAgICAgICAgY29uc3QgbWFya2VyVmFsdWUgPSAobWFya2VyQ291bnRlci5nZXQobm9kZSkgfHwgMCkgKyAxO1xuICAgICAgICBjb3VudGVyTWFwLnNldChub2RlLCBjb3VudGVyVmFsdWUpO1xuICAgICAgICBtYXJrZXJDb3VudGVyLnNldChub2RlLCBtYXJrZXJWYWx1ZSk7XG4gICAgICAgIGhpZGRlbkVsZW1lbnRzLnB1c2gobm9kZSk7XG4gICAgICAgIGlmIChjb3VudGVyVmFsdWUgPT09IDEgJiYgYWxyZWFkeUhpZGRlbikge1xuICAgICAgICAgIHVuY29udHJvbGxlZEVsZW1lbnRzU2V0LmFkZChub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWFya2VyVmFsdWUgPT09IDEpIHtcbiAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShtYXJrZXJOYW1lLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhbHJlYWR5SGlkZGVuICYmIGNvbnRyb2xBdHRyaWJ1dGUpIHtcbiAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShjb250cm9sQXR0cmlidXRlLCAndHJ1ZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbG9ja0NvdW50Kys7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgaGlkZGVuRWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgIGNvbnN0IGNvdW50ZXJWYWx1ZSA9IChjb3VudGVyTWFwLmdldChlbGVtZW50KSB8fCAwKSAtIDE7XG4gICAgICBjb25zdCBtYXJrZXJWYWx1ZSA9IChtYXJrZXJDb3VudGVyLmdldChlbGVtZW50KSB8fCAwKSAtIDE7XG4gICAgICBjb3VudGVyTWFwLnNldChlbGVtZW50LCBjb3VudGVyVmFsdWUpO1xuICAgICAgbWFya2VyQ291bnRlci5zZXQoZWxlbWVudCwgbWFya2VyVmFsdWUpO1xuICAgICAgaWYgKCFjb3VudGVyVmFsdWUpIHtcbiAgICAgICAgaWYgKCF1bmNvbnRyb2xsZWRFbGVtZW50c1NldC5oYXMoZWxlbWVudCkgJiYgY29udHJvbEF0dHJpYnV0ZSkge1xuICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGNvbnRyb2xBdHRyaWJ1dGUpO1xuICAgICAgICB9XG4gICAgICAgIHVuY29udHJvbGxlZEVsZW1lbnRzU2V0LmRlbGV0ZShlbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIGlmICghbWFya2VyVmFsdWUpIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUobWFya2VyTmFtZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgbG9ja0NvdW50LS07XG4gICAgaWYgKCFsb2NrQ291bnQpIHtcbiAgICAgIGNvdW50ZXJNYXAgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgY291bnRlck1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICB1bmNvbnRyb2xsZWRFbGVtZW50c1NldCA9IG5ldyBXZWFrU2V0KCk7XG4gICAgICBtYXJrZXJNYXAgPSB7fTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBtYXJrT3RoZXJzKGF2b2lkRWxlbWVudHMsIGFyaWFIaWRkZW4sIGluZXJ0KSB7XG4gIGlmIChhcmlhSGlkZGVuID09PSB2b2lkIDApIHtcbiAgICBhcmlhSGlkZGVuID0gZmFsc2U7XG4gIH1cbiAgaWYgKGluZXJ0ID09PSB2b2lkIDApIHtcbiAgICBpbmVydCA9IGZhbHNlO1xuICB9XG4gIGNvbnN0IGJvZHkgPSBnZXREb2N1bWVudChhdm9pZEVsZW1lbnRzWzBdKS5ib2R5O1xuICByZXR1cm4gYXBwbHlBdHRyaWJ1dGVUb090aGVycyhhdm9pZEVsZW1lbnRzLmNvbmNhdChBcnJheS5mcm9tKGJvZHkucXVlcnlTZWxlY3RvckFsbCgnW2FyaWEtbGl2ZV0nKSkpLCBib2R5LCBhcmlhSGlkZGVuLCBpbmVydCk7XG59XG5cbmNvbnN0IGdldFRhYmJhYmxlT3B0aW9ucyA9ICgpID0+ICh7XG4gIGdldFNoYWRvd1Jvb3Q6IHRydWUsXG4gIGRpc3BsYXlDaGVjazpcbiAgLy8gSlNET00gZG9lcyBub3Qgc3VwcG9ydCB0aGUgYHRhYmJhYmxlYCBsaWJyYXJ5LiBUbyBzb2x2ZSB0aGlzIHdlIGNhblxuICAvLyBjaGVjayBpZiBgUmVzaXplT2JzZXJ2ZXJgIGlzIGEgcmVhbCBmdW5jdGlvbiAobm90IHBvbHlmaWxsZWQpLCB3aGljaFxuICAvLyBkZXRlcm1pbmVzIGlmIHRoZSBjdXJyZW50IGVudmlyb25tZW50IGlzIEpTRE9NLWxpa2UuXG4gIHR5cGVvZiBSZXNpemVPYnNlcnZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBSZXNpemVPYnNlcnZlci50b1N0cmluZygpLmluY2x1ZGVzKCdbbmF0aXZlIGNvZGVdJykgPyAnZnVsbCcgOiAnbm9uZSdcbn0pO1xuZnVuY3Rpb24gZ2V0VGFiYmFibGVJbihjb250YWluZXIsIGRpcmVjdGlvbikge1xuICBjb25zdCBhbGxUYWJiYWJsZSA9IHRhYmJhYmxlKGNvbnRhaW5lciwgZ2V0VGFiYmFibGVPcHRpb25zKCkpO1xuICBpZiAoZGlyZWN0aW9uID09PSAncHJldicpIHtcbiAgICBhbGxUYWJiYWJsZS5yZXZlcnNlKCk7XG4gIH1cbiAgY29uc3QgYWN0aXZlSW5kZXggPSBhbGxUYWJiYWJsZS5pbmRleE9mKGFjdGl2ZUVsZW1lbnQoZ2V0RG9jdW1lbnQoY29udGFpbmVyKSkpO1xuICBjb25zdCBuZXh0VGFiYmFibGVFbGVtZW50cyA9IGFsbFRhYmJhYmxlLnNsaWNlKGFjdGl2ZUluZGV4ICsgMSk7XG4gIHJldHVybiBuZXh0VGFiYmFibGVFbGVtZW50c1swXTtcbn1cbmZ1bmN0aW9uIGdldE5leHRUYWJiYWJsZSgpIHtcbiAgcmV0dXJuIGdldFRhYmJhYmxlSW4oZG9jdW1lbnQuYm9keSwgJ25leHQnKTtcbn1cbmZ1bmN0aW9uIGdldFByZXZpb3VzVGFiYmFibGUoKSB7XG4gIHJldHVybiBnZXRUYWJiYWJsZUluKGRvY3VtZW50LmJvZHksICdwcmV2Jyk7XG59XG5mdW5jdGlvbiBpc091dHNpZGVFdmVudChldmVudCwgY29udGFpbmVyKSB7XG4gIGNvbnN0IGNvbnRhaW5lckVsZW1lbnQgPSBjb250YWluZXIgfHwgZXZlbnQuY3VycmVudFRhcmdldDtcbiAgY29uc3QgcmVsYXRlZFRhcmdldCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQ7XG4gIHJldHVybiAhcmVsYXRlZFRhcmdldCB8fCAhY29udGFpbnMoY29udGFpbmVyRWxlbWVudCwgcmVsYXRlZFRhcmdldCk7XG59XG5mdW5jdGlvbiBkaXNhYmxlRm9jdXNJbnNpZGUoY29udGFpbmVyKSB7XG4gIGNvbnN0IHRhYmJhYmxlRWxlbWVudHMgPSB0YWJiYWJsZShjb250YWluZXIsIGdldFRhYmJhYmxlT3B0aW9ucygpKTtcbiAgdGFiYmFibGVFbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgIGVsZW1lbnQuZGF0YXNldC50YWJpbmRleCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpIHx8ICcnO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICctMScpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGVuYWJsZUZvY3VzSW5zaWRlKGNvbnRhaW5lcikge1xuICBjb25zdCBlbGVtZW50cyA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS10YWJpbmRleF0nKTtcbiAgZWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICBjb25zdCB0YWJpbmRleCA9IGVsZW1lbnQuZGF0YXNldC50YWJpbmRleDtcbiAgICAvLyBiaW9tZS1pZ25vcmUgbGludC9wZXJmb3JtYW5jZS9ub0RlbGV0ZTogcHVyaXR5XG4gICAgZGVsZXRlIGVsZW1lbnQuZGF0YXNldC50YWJpbmRleDtcbiAgICBpZiAodGFiaW5kZXgpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIHRhYmluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gU2VlIERpZWdvIEhheidzIFNhbmRib3ggZm9yIG1ha2luZyB0aGlzIGxvZ2ljIHdvcmsgd2VsbCBvbiBTYWZhcmkvaU9TOlxuLy8gaHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9zL3RhYmJhYmxlLXBvcnRhbC1mNHRuZz9maWxlPS9zcmMvRm9jdXNUcmFwLnRzeFxuXG5jb25zdCBISURERU5fU1RZTEVTID0ge1xuICBib3JkZXI6IDAsXG4gIGNsaXA6ICdyZWN0KDAgMCAwIDApJyxcbiAgaGVpZ2h0OiAnMXB4JyxcbiAgbWFyZ2luOiAnLTFweCcsXG4gIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgcGFkZGluZzogMCxcbiAgcG9zaXRpb246ICdmaXhlZCcsXG4gIHdoaXRlU3BhY2U6ICdub3dyYXAnLFxuICB3aWR0aDogJzFweCcsXG4gIHRvcDogMCxcbiAgbGVmdDogMFxufTtcbmxldCB0aW1lb3V0SWQ7XG5mdW5jdGlvbiBzZXRBY3RpdmVFbGVtZW50T25UYWIoZXZlbnQpIHtcbiAgaWYgKGV2ZW50LmtleSA9PT0gJ1RhYicpIHtcbiAgICBldmVudC50YXJnZXQ7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gIH1cbn1cbmNvbnN0IEZvY3VzR3VhcmQgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBGb2N1c0d1YXJkKHByb3BzLCByZWYpIHtcbiAgY29uc3QgW3JvbGUsIHNldFJvbGVdID0gUmVhY3QudXNlU3RhdGUoKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmIChpc1NhZmFyaSgpKSB7XG4gICAgICAvLyBVbmxpa2Ugb3RoZXIgc2NyZWVuIHJlYWRlcnMgc3VjaCBhcyBOVkRBIGFuZCBKQVdTLCB0aGUgdmlydHVhbCBjdXJzb3JcbiAgICAgIC8vIG9uIFZvaWNlT3ZlciBkb2VzIHRyaWdnZXIgdGhlIG9uRm9jdXMgZXZlbnQsIHNvIHdlIGNhbiB1c2UgdGhlIGZvY3VzXG4gICAgICAvLyB0cmFwIGVsZW1lbnQuIE9uIFNhZmFyaSwgb25seSBidXR0b25zIHRyaWdnZXIgdGhlIG9uRm9jdXMgZXZlbnQuXG4gICAgICAvLyBOQjogXCJncm91cFwiIHJvbGUgaW4gdGhlIFNhbmRib3ggbm8gbG9uZ2VyIGFwcGVhcnMgdG8gd29yaywgbXVzdCBiZSBhXG4gICAgICAvLyBidXR0b24gcm9sZS5cbiAgICAgIHNldFJvbGUoJ2J1dHRvbicpO1xuICAgIH1cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgc2V0QWN0aXZlRWxlbWVudE9uVGFiKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHNldEFjdGl2ZUVsZW1lbnRPblRhYik7XG4gICAgfTtcbiAgfSwgW10pO1xuICBjb25zdCByZXN0UHJvcHMgPSB7XG4gICAgcmVmLFxuICAgIHRhYkluZGV4OiAwLFxuICAgIC8vIFJvbGUgaXMgb25seSBmb3IgVm9pY2VPdmVyXG4gICAgcm9sZSxcbiAgICAnYXJpYS1oaWRkZW4nOiByb2xlID8gdW5kZWZpbmVkIDogdHJ1ZSxcbiAgICBbY3JlYXRlQXR0cmlidXRlKCdmb2N1cy1ndWFyZCcpXTogJycsXG4gICAgc3R5bGU6IEhJRERFTl9TVFlMRVNcbiAgfTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHJlc3RQcm9wcykpO1xufSk7XG5cbmNvbnN0IFBvcnRhbENvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbmNvbnN0IGF0dHIgPSAvKiNfX1BVUkVfXyovY3JlYXRlQXR0cmlidXRlKCdwb3J0YWwnKTtcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvRmxvYXRpbmdQb3J0YWwjdXNlZmxvYXRpbmdwb3J0YWxub2RlXG4gKi9cbmZ1bmN0aW9uIHVzZUZsb2F0aW5nUG9ydGFsTm9kZShfdGVtcCkge1xuICBsZXQge1xuICAgIGlkLFxuICAgIHJvb3RcbiAgfSA9IF90ZW1wID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wO1xuICBjb25zdCBbcG9ydGFsTm9kZSwgc2V0UG9ydGFsTm9kZV0gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgdW5pcXVlSWQgPSB1c2VJZCgpO1xuICBjb25zdCBwb3J0YWxDb250ZXh0ID0gdXNlUG9ydGFsQ29udGV4dCgpO1xuICBjb25zdCBwb3J0YWxOb2RlUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBpbmRleCgoKSA9PiB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHBvcnRhbE5vZGUgPT0gbnVsbCB8fCBwb3J0YWxOb2RlLnJlbW92ZSgpO1xuICAgICAgLy8gQWxsb3cgdGhlIHN1YnNlcXVlbnQgbGF5b3V0IGVmZmVjdHMgdG8gY3JlYXRlIGEgbmV3IG5vZGUgb24gdXBkYXRlcy5cbiAgICAgIC8vIFRoZSBwb3J0YWwgbm9kZSB3aWxsIHN0aWxsIGJlIGNsZWFuZWQgdXAgb24gdW5tb3VudC5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mbG9hdGluZy11aS9mbG9hdGluZy11aS9pc3N1ZXMvMjQ1NFxuICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICBwb3J0YWxOb2RlUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfSwgW3BvcnRhbE5vZGVdKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmIChwb3J0YWxOb2RlUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICBjb25zdCBleGlzdGluZ0lkUm9vdCA9IGlkID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpIDogbnVsbDtcbiAgICBpZiAoIWV4aXN0aW5nSWRSb290KSByZXR1cm47XG4gICAgY29uc3Qgc3ViUm9vdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHN1YlJvb3QuaWQgPSB1bmlxdWVJZDtcbiAgICBzdWJSb290LnNldEF0dHJpYnV0ZShhdHRyLCAnJyk7XG4gICAgZXhpc3RpbmdJZFJvb3QuYXBwZW5kQ2hpbGQoc3ViUm9vdCk7XG4gICAgcG9ydGFsTm9kZVJlZi5jdXJyZW50ID0gc3ViUm9vdDtcbiAgICBzZXRQb3J0YWxOb2RlKHN1YlJvb3QpO1xuICB9LCBbaWQsIHVuaXF1ZUlkXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAocG9ydGFsTm9kZVJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgbGV0IGNvbnRhaW5lciA9IHJvb3QgfHwgKHBvcnRhbENvbnRleHQgPT0gbnVsbCA/IHZvaWQgMCA6IHBvcnRhbENvbnRleHQucG9ydGFsTm9kZSk7XG4gICAgaWYgKGNvbnRhaW5lciAmJiAhaXNFbGVtZW50KGNvbnRhaW5lcikpIGNvbnRhaW5lciA9IGNvbnRhaW5lci5jdXJyZW50O1xuICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lciB8fCBkb2N1bWVudC5ib2R5O1xuICAgIGxldCBpZFdyYXBwZXIgPSBudWxsO1xuICAgIGlmIChpZCkge1xuICAgICAgaWRXcmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBpZFdyYXBwZXIuaWQgPSBpZDtcbiAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChpZFdyYXBwZXIpO1xuICAgIH1cbiAgICBjb25zdCBzdWJSb290ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgc3ViUm9vdC5pZCA9IHVuaXF1ZUlkO1xuICAgIHN1YlJvb3Quc2V0QXR0cmlidXRlKGF0dHIsICcnKTtcbiAgICBjb250YWluZXIgPSBpZFdyYXBwZXIgfHwgY29udGFpbmVyO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChzdWJSb290KTtcbiAgICBwb3J0YWxOb2RlUmVmLmN1cnJlbnQgPSBzdWJSb290O1xuICAgIHNldFBvcnRhbE5vZGUoc3ViUm9vdCk7XG4gIH0sIFtpZCwgcm9vdCwgdW5pcXVlSWQsIHBvcnRhbENvbnRleHRdKTtcbiAgcmV0dXJuIHBvcnRhbE5vZGU7XG59XG4vKipcbiAqIFBvcnRhbHMgdGhlIGZsb2F0aW5nIGVsZW1lbnQgaW50byBhIGdpdmVuIGNvbnRhaW5lciBlbGVtZW50IOKAlCBieSBkZWZhdWx0LFxuICogb3V0c2lkZSBvZiB0aGUgYXBwIHJvb3QgYW5kIGludG8gdGhlIGJvZHkuXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSB0byBlbnN1cmUgdGhlIGZsb2F0aW5nIGVsZW1lbnQgY2FuIGFwcGVhciBvdXRzaWRlIGFueVxuICogcG90ZW50aWFsIHBhcmVudCBjb250YWluZXJzIHRoYXQgY2F1c2UgY2xpcHBpbmcgKHN1Y2ggYXMgYG92ZXJmbG93OiBoaWRkZW5gKSxcbiAqIHdoaWxlIHJldGFpbmluZyBpdHMgbG9jYXRpb24gaW4gdGhlIFJlYWN0IHRyZWUuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvRmxvYXRpbmdQb3J0YWxcbiAqL1xuZnVuY3Rpb24gRmxvYXRpbmdQb3J0YWwoX3JlZikge1xuICBsZXQge1xuICAgIGNoaWxkcmVuLFxuICAgIGlkLFxuICAgIHJvb3QgPSBudWxsLFxuICAgIHByZXNlcnZlVGFiT3JkZXIgPSB0cnVlXG4gIH0gPSBfcmVmO1xuICBjb25zdCBwb3J0YWxOb2RlID0gdXNlRmxvYXRpbmdQb3J0YWxOb2RlKHtcbiAgICBpZCxcbiAgICByb290XG4gIH0pO1xuICBjb25zdCBbZm9jdXNNYW5hZ2VyU3RhdGUsIHNldEZvY3VzTWFuYWdlclN0YXRlXSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBiZWZvcmVPdXRzaWRlUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBhZnRlck91dHNpZGVSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGJlZm9yZUluc2lkZVJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgYWZ0ZXJJbnNpZGVSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IHNob3VsZFJlbmRlckd1YXJkcyA9XG4gIC8vIFRoZSBGb2N1c01hbmFnZXIgYW5kIHRoZXJlZm9yZSBmbG9hdGluZyBlbGVtZW50IGFyZSBjdXJyZW50bHkgb3Blbi9cbiAgLy8gcmVuZGVyZWQuXG4gICEhZm9jdXNNYW5hZ2VyU3RhdGUgJiZcbiAgLy8gR3VhcmRzIGFyZSBvbmx5IGZvciBub24tbW9kYWwgZm9jdXMgbWFuYWdlbWVudC5cbiAgIWZvY3VzTWFuYWdlclN0YXRlLm1vZGFsICYmXG4gIC8vIERvbid0IHJlbmRlciBpZiB1bm1vdW50IGlzIHRyYW5zaXRpb25pbmcuXG4gIGZvY3VzTWFuYWdlclN0YXRlLm9wZW4gJiYgcHJlc2VydmVUYWJPcmRlciAmJiAhIShyb290IHx8IHBvcnRhbE5vZGUpO1xuXG4gIC8vIGh0dHBzOi8vY29kZXNhbmRib3guaW8vcy90YWJiYWJsZS1wb3J0YWwtZjR0bmc/ZmlsZT0vc3JjL1RhYmJhYmxlUG9ydGFsLnRzeFxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghcG9ydGFsTm9kZSB8fCAhcHJlc2VydmVUYWJPcmRlciB8fCBmb2N1c01hbmFnZXJTdGF0ZSAhPSBudWxsICYmIGZvY3VzTWFuYWdlclN0YXRlLm1vZGFsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gTWFrZSBzdXJlIGVsZW1lbnRzIGluc2lkZSB0aGUgcG9ydGFsIGVsZW1lbnQgYXJlIHRhYmJhYmxlIG9ubHkgd2hlbiB0aGVcbiAgICAvLyBwb3J0YWwgaGFzIGFscmVhZHkgYmVlbiBmb2N1c2VkLCBlaXRoZXIgYnkgdGFiYmluZyBpbnRvIGEgZm9jdXMgdHJhcFxuICAgIC8vIGVsZW1lbnQgb3V0c2lkZSBvciB1c2luZyB0aGUgbW91c2UuXG4gICAgZnVuY3Rpb24gb25Gb2N1cyhldmVudCkge1xuICAgICAgaWYgKHBvcnRhbE5vZGUgJiYgaXNPdXRzaWRlRXZlbnQoZXZlbnQpKSB7XG4gICAgICAgIGNvbnN0IGZvY3VzaW5nID0gZXZlbnQudHlwZSA9PT0gJ2ZvY3VzaW4nO1xuICAgICAgICBjb25zdCBtYW5hZ2VGb2N1cyA9IGZvY3VzaW5nID8gZW5hYmxlRm9jdXNJbnNpZGUgOiBkaXNhYmxlRm9jdXNJbnNpZGU7XG4gICAgICAgIG1hbmFnZUZvY3VzKHBvcnRhbE5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBMaXN0ZW4gdG8gdGhlIGV2ZW50IG9uIHRoZSBjYXB0dXJlIHBoYXNlIHNvIHRoZXkgcnVuIGJlZm9yZSB0aGUgZm9jdXNcbiAgICAvLyB0cmFwIGVsZW1lbnRzIG9uRm9jdXMgcHJvcCBpcyBjYWxsZWQuXG4gICAgcG9ydGFsTm9kZS5hZGRFdmVudExpc3RlbmVyKCdmb2N1c2luJywgb25Gb2N1cywgdHJ1ZSk7XG4gICAgcG9ydGFsTm9kZS5hZGRFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIG9uRm9jdXMsIHRydWUpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBwb3J0YWxOb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCBvbkZvY3VzLCB0cnVlKTtcbiAgICAgIHBvcnRhbE5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCBvbkZvY3VzLCB0cnVlKTtcbiAgICB9O1xuICB9LCBbcG9ydGFsTm9kZSwgcHJlc2VydmVUYWJPcmRlciwgZm9jdXNNYW5hZ2VyU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IGZvY3VzTWFuYWdlclN0YXRlLm1vZGFsXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChQb3J0YWxDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICAgIHByZXNlcnZlVGFiT3JkZXIsXG4gICAgICBiZWZvcmVPdXRzaWRlUmVmLFxuICAgICAgYWZ0ZXJPdXRzaWRlUmVmLFxuICAgICAgYmVmb3JlSW5zaWRlUmVmLFxuICAgICAgYWZ0ZXJJbnNpZGVSZWYsXG4gICAgICBwb3J0YWxOb2RlLFxuICAgICAgc2V0Rm9jdXNNYW5hZ2VyU3RhdGVcbiAgICB9KSwgW3ByZXNlcnZlVGFiT3JkZXIsIHBvcnRhbE5vZGVdKVxuICB9LCBzaG91bGRSZW5kZXJHdWFyZHMgJiYgcG9ydGFsTm9kZSAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGb2N1c0d1YXJkLCB7XG4gICAgXCJkYXRhLXR5cGVcIjogXCJvdXRzaWRlXCIsXG4gICAgcmVmOiBiZWZvcmVPdXRzaWRlUmVmLFxuICAgIG9uRm9jdXM6IGV2ZW50ID0+IHtcbiAgICAgIGlmIChpc091dHNpZGVFdmVudChldmVudCwgcG9ydGFsTm9kZSkpIHtcbiAgICAgICAgdmFyIF9iZWZvcmVJbnNpZGVSZWYkY3VycjtcbiAgICAgICAgKF9iZWZvcmVJbnNpZGVSZWYkY3VyciA9IGJlZm9yZUluc2lkZVJlZi5jdXJyZW50KSA9PSBudWxsIHx8IF9iZWZvcmVJbnNpZGVSZWYkY3Vyci5mb2N1cygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcHJldlRhYmJhYmxlID0gZ2V0UHJldmlvdXNUYWJiYWJsZSgpIHx8IChmb2N1c01hbmFnZXJTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogZm9jdXNNYW5hZ2VyU3RhdGUucmVmcy5kb21SZWZlcmVuY2UuY3VycmVudCk7XG4gICAgICAgIHByZXZUYWJiYWJsZSA9PSBudWxsIHx8IHByZXZUYWJiYWJsZS5mb2N1cygpO1xuICAgICAgfVxuICAgIH1cbiAgfSksIHNob3VsZFJlbmRlckd1YXJkcyAmJiBwb3J0YWxOb2RlICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgXCJhcmlhLW93bnNcIjogcG9ydGFsTm9kZS5pZCxcbiAgICBzdHlsZTogSElEREVOX1NUWUxFU1xuICB9KSwgcG9ydGFsTm9kZSAmJiAvKiNfX1BVUkVfXyovY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCBwb3J0YWxOb2RlKSwgc2hvdWxkUmVuZGVyR3VhcmRzICYmIHBvcnRhbE5vZGUgJiYgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRm9jdXNHdWFyZCwge1xuICAgIFwiZGF0YS10eXBlXCI6IFwib3V0c2lkZVwiLFxuICAgIHJlZjogYWZ0ZXJPdXRzaWRlUmVmLFxuICAgIG9uRm9jdXM6IGV2ZW50ID0+IHtcbiAgICAgIGlmIChpc091dHNpZGVFdmVudChldmVudCwgcG9ydGFsTm9kZSkpIHtcbiAgICAgICAgdmFyIF9hZnRlckluc2lkZVJlZiRjdXJyZTtcbiAgICAgICAgKF9hZnRlckluc2lkZVJlZiRjdXJyZSA9IGFmdGVySW5zaWRlUmVmLmN1cnJlbnQpID09IG51bGwgfHwgX2FmdGVySW5zaWRlUmVmJGN1cnJlLmZvY3VzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBuZXh0VGFiYmFibGUgPSBnZXROZXh0VGFiYmFibGUoKSB8fCAoZm9jdXNNYW5hZ2VyU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IGZvY3VzTWFuYWdlclN0YXRlLnJlZnMuZG9tUmVmZXJlbmNlLmN1cnJlbnQpO1xuICAgICAgICBuZXh0VGFiYmFibGUgPT0gbnVsbCB8fCBuZXh0VGFiYmFibGUuZm9jdXMoKTtcbiAgICAgICAgKGZvY3VzTWFuYWdlclN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBmb2N1c01hbmFnZXJTdGF0ZS5jbG9zZU9uRm9jdXNPdXQpICYmIChmb2N1c01hbmFnZXJTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogZm9jdXNNYW5hZ2VyU3RhdGUub25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudC5uYXRpdmVFdmVudCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSkpO1xufVxuY29uc3QgdXNlUG9ydGFsQ29udGV4dCA9ICgpID0+IFJlYWN0LnVzZUNvbnRleHQoUG9ydGFsQ29udGV4dCk7XG5cbmNvbnN0IExJU1RfTElNSVQgPSAyMDtcbmxldCBwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnRzID0gW107XG5mdW5jdGlvbiBhZGRQcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQoZWxlbWVudCkge1xuICBwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnRzID0gcHJldmlvdXNseUZvY3VzZWRFbGVtZW50cy5maWx0ZXIoZWwgPT4gZWwuaXNDb25uZWN0ZWQpO1xuICBsZXQgdGFiYmFibGVFbCA9IGVsZW1lbnQ7XG4gIGlmICghdGFiYmFibGVFbCB8fCBnZXROb2RlTmFtZSh0YWJiYWJsZUVsKSA9PT0gJ2JvZHknKSByZXR1cm47XG4gIGlmICghaXNUYWJiYWJsZSh0YWJiYWJsZUVsLCBnZXRUYWJiYWJsZU9wdGlvbnMoKSkpIHtcbiAgICBjb25zdCB0YWJiYWJsZUNoaWxkID0gdGFiYmFibGUodGFiYmFibGVFbCwgZ2V0VGFiYmFibGVPcHRpb25zKCkpWzBdO1xuICAgIGlmICghdGFiYmFibGVDaGlsZCkgcmV0dXJuO1xuICAgIHRhYmJhYmxlRWwgPSB0YWJiYWJsZUNoaWxkO1xuICB9XG4gIHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudHMucHVzaCh0YWJiYWJsZUVsKTtcbiAgaWYgKHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudHMubGVuZ3RoID4gTElTVF9MSU1JVCkge1xuICAgIHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudHMgPSBwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnRzLnNsaWNlKC1MSVNUX0xJTUlUKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0UHJldmlvdXNseUZvY3VzZWRFbGVtZW50KCkge1xuICByZXR1cm4gcHJldmlvdXNseUZvY3VzZWRFbGVtZW50cy5zbGljZSgpLnJldmVyc2UoKS5maW5kKGVsID0+IGVsLmlzQ29ubmVjdGVkKTtcbn1cbmNvbnN0IFZpc3VhbGx5SGlkZGVuRGlzbWlzcyA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIFZpc3VhbGx5SGlkZGVuRGlzbWlzcyhwcm9wcywgcmVmKSB7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgIHJlZjogcmVmLFxuICAgIHRhYkluZGV4OiAtMSxcbiAgICBzdHlsZTogSElEREVOX1NUWUxFU1xuICB9KSk7XG59KTtcbi8qKlxuICogUHJvdmlkZXMgZm9jdXMgbWFuYWdlbWVudCBmb3IgdGhlIGZsb2F0aW5nIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvRmxvYXRpbmdGb2N1c01hbmFnZXJcbiAqL1xuZnVuY3Rpb24gRmxvYXRpbmdGb2N1c01hbmFnZXIocHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIGNvbnRleHQsXG4gICAgY2hpbGRyZW4sXG4gICAgZGlzYWJsZWQgPSBmYWxzZSxcbiAgICBvcmRlciA9IFsnY29udGVudCddLFxuICAgIGd1YXJkczogX2d1YXJkcyA9IHRydWUsXG4gICAgaW5pdGlhbEZvY3VzID0gMCxcbiAgICByZXR1cm5Gb2N1cyA9IHRydWUsXG4gICAgbW9kYWwgPSB0cnVlLFxuICAgIHZpc3VhbGx5SGlkZGVuRGlzbWlzcyA9IGZhbHNlLFxuICAgIGNsb3NlT25Gb2N1c091dCA9IHRydWVcbiAgfSA9IHByb3BzO1xuICBjb25zdCB7XG4gICAgb3BlbixcbiAgICByZWZzLFxuICAgIG5vZGVJZCxcbiAgICBvbk9wZW5DaGFuZ2UsXG4gICAgZXZlbnRzLFxuICAgIGRhdGFSZWYsXG4gICAgZWxlbWVudHM6IHtcbiAgICAgIGRvbVJlZmVyZW5jZSxcbiAgICAgIGZsb2F0aW5nXG4gICAgfVxuICB9ID0gY29udGV4dDtcbiAgY29uc3QgaWdub3JlSW5pdGlhbEZvY3VzID0gdHlwZW9mIGluaXRpYWxGb2N1cyA9PT0gJ251bWJlcicgJiYgaW5pdGlhbEZvY3VzIDwgMDtcbiAgLy8gSWYgdGhlIHJlZmVyZW5jZSBpcyBhIGNvbWJvYm94IGFuZCBpcyB0eXBlYWJsZSAoZS5nLiBpbnB1dC90ZXh0YXJlYSksXG4gIC8vIHRoZXJlIGFyZSBkaWZmZXJlbnQgZm9jdXMgc2VtYW50aWNzLiBUaGUgZ3VhcmRzIHNob3VsZCBub3QgYmUgcmVuZGVyZWQsIGJ1dFxuICAvLyBhcmlhLWhpZGRlbiBzaG91bGQgYmUgYXBwbGllZCB0byBhbGwgbm9kZXMgc3RpbGwuIEZ1cnRoZXIsIHRoZSB2aXN1YWxseVxuICAvLyBoaWRkZW4gZGlzbWlzcyBidXR0b24gc2hvdWxkIG9ubHkgYXBwZWFyIGF0IHRoZSBlbmQgb2YgdGhlIGxpc3QsIG5vdCB0aGVcbiAgLy8gc3RhcnQuXG4gIGNvbnN0IGlzVW50cmFwcGVkVHlwZWFibGVDb21ib2JveCA9IGlzVHlwZWFibGVDb21ib2JveChkb21SZWZlcmVuY2UpICYmIGlnbm9yZUluaXRpYWxGb2N1cztcblxuICAvLyBGb3JjZSB0aGUgZ3VhcmRzIHRvIGJlIHJlbmRlcmVkIGlmIHRoZSBgaW5lcnRgIGF0dHJpYnV0ZSBpcyBub3Qgc3VwcG9ydGVkLlxuICBjb25zdCBndWFyZHMgPSBzdXBwb3J0c0luZXJ0KCkgPyBfZ3VhcmRzIDogdHJ1ZTtcbiAgY29uc3Qgb3JkZXJSZWYgPSB1c2VMYXRlc3RSZWYob3JkZXIpO1xuICBjb25zdCBpbml0aWFsRm9jdXNSZWYgPSB1c2VMYXRlc3RSZWYoaW5pdGlhbEZvY3VzKTtcbiAgY29uc3QgcmV0dXJuRm9jdXNSZWYgPSB1c2VMYXRlc3RSZWYocmV0dXJuRm9jdXMpO1xuICBjb25zdCB0cmVlID0gdXNlRmxvYXRpbmdUcmVlKCk7XG4gIGNvbnN0IHBvcnRhbENvbnRleHQgPSB1c2VQb3J0YWxDb250ZXh0KCk7XG4gIGNvbnN0IHN0YXJ0RGlzbWlzc0J1dHRvblJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgZW5kRGlzbWlzc0J1dHRvblJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgcHJldmVudFJldHVybkZvY3VzUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgaXNQb2ludGVyRG93blJlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IGlzSW5zaWRlUG9ydGFsID0gcG9ydGFsQ29udGV4dCAhPSBudWxsO1xuICBjb25zdCBnZXRUYWJiYWJsZUNvbnRlbnQgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gICAgaWYgKGNvbnRhaW5lciA9PT0gdm9pZCAwKSB7XG4gICAgICBjb250YWluZXIgPSBmbG9hdGluZztcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRhaW5lciA/IHRhYmJhYmxlKGNvbnRhaW5lciwgZ2V0VGFiYmFibGVPcHRpb25zKCkpIDogW107XG4gIH0sIFtmbG9hdGluZ10pO1xuICBjb25zdCBnZXRUYWJiYWJsZUVsZW1lbnRzID0gUmVhY3QudXNlQ2FsbGJhY2soY29udGFpbmVyID0+IHtcbiAgICBjb25zdCBjb250ZW50ID0gZ2V0VGFiYmFibGVDb250ZW50KGNvbnRhaW5lcik7XG4gICAgcmV0dXJuIG9yZGVyUmVmLmN1cnJlbnQubWFwKHR5cGUgPT4ge1xuICAgICAgaWYgKGRvbVJlZmVyZW5jZSAmJiB0eXBlID09PSAncmVmZXJlbmNlJykge1xuICAgICAgICByZXR1cm4gZG9tUmVmZXJlbmNlO1xuICAgICAgfVxuICAgICAgaWYgKGZsb2F0aW5nICYmIHR5cGUgPT09ICdmbG9hdGluZycpIHtcbiAgICAgICAgcmV0dXJuIGZsb2F0aW5nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfSkuZmlsdGVyKEJvb2xlYW4pLmZsYXQoKTtcbiAgfSwgW2RvbVJlZmVyZW5jZSwgZmxvYXRpbmcsIG9yZGVyUmVmLCBnZXRUYWJiYWJsZUNvbnRlbnRdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQgfHwgIW1vZGFsKSByZXR1cm47XG4gICAgZnVuY3Rpb24gb25LZXlEb3duKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQua2V5ID09PSAnVGFiJykge1xuICAgICAgICAvLyBUaGUgZm9jdXMgZ3VhcmRzIGhhdmUgbm90aGluZyB0byBmb2N1cywgc28gd2UgbmVlZCB0byBzdG9wIHRoZSBldmVudC5cbiAgICAgICAgaWYgKGNvbnRhaW5zKGZsb2F0aW5nLCBhY3RpdmVFbGVtZW50KGdldERvY3VtZW50KGZsb2F0aW5nKSkpICYmIGdldFRhYmJhYmxlQ29udGVudCgpLmxlbmd0aCA9PT0gMCAmJiAhaXNVbnRyYXBwZWRUeXBlYWJsZUNvbWJvYm94KSB7XG4gICAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbHMgPSBnZXRUYWJiYWJsZUVsZW1lbnRzKCk7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGdldFRhcmdldChldmVudCk7XG4gICAgICAgIGlmIChvcmRlclJlZi5jdXJyZW50WzBdID09PSAncmVmZXJlbmNlJyAmJiB0YXJnZXQgPT09IGRvbVJlZmVyZW5jZSkge1xuICAgICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICAgICAgaWYgKGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICBlbnF1ZXVlRm9jdXMoZWxzW2Vscy5sZW5ndGggLSAxXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVucXVldWVGb2N1cyhlbHNbMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3JkZXJSZWYuY3VycmVudFsxXSA9PT0gJ2Zsb2F0aW5nJyAmJiB0YXJnZXQgPT09IGZsb2F0aW5nICYmIGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICBlbnF1ZXVlRm9jdXMoZWxzWzBdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBkb2MgPSBnZXREb2N1bWVudChmbG9hdGluZyk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBvbktleURvd24pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIG9uS2V5RG93bik7XG4gICAgfTtcbiAgfSwgW2Rpc2FibGVkLCBkb21SZWZlcmVuY2UsIGZsb2F0aW5nLCBtb2RhbCwgb3JkZXJSZWYsIGlzVW50cmFwcGVkVHlwZWFibGVDb21ib2JveCwgZ2V0VGFiYmFibGVDb250ZW50LCBnZXRUYWJiYWJsZUVsZW1lbnRzXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGRpc2FibGVkIHx8ICFjbG9zZU9uRm9jdXNPdXQpIHJldHVybjtcblxuICAgIC8vIEluIFNhZmFyaSwgYnV0dG9ucyBsb3NlIGZvY3VzIHdoZW4gcHJlc3NpbmcgdGhlbS5cbiAgICBmdW5jdGlvbiBoYW5kbGVQb2ludGVyRG93bigpIHtcbiAgICAgIGlzUG9pbnRlckRvd25SZWYuY3VycmVudCA9IHRydWU7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaXNQb2ludGVyRG93blJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlRm9jdXNPdXRzaWRlKGV2ZW50KSB7XG4gICAgICBjb25zdCByZWxhdGVkVGFyZ2V0ID0gZXZlbnQucmVsYXRlZFRhcmdldDtcbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgY29uc3QgbW92ZWRUb1VucmVsYXRlZE5vZGUgPSAhKGNvbnRhaW5zKGRvbVJlZmVyZW5jZSwgcmVsYXRlZFRhcmdldCkgfHwgY29udGFpbnMoZmxvYXRpbmcsIHJlbGF0ZWRUYXJnZXQpIHx8IGNvbnRhaW5zKHJlbGF0ZWRUYXJnZXQsIGZsb2F0aW5nKSB8fCBjb250YWlucyhwb3J0YWxDb250ZXh0ID09IG51bGwgPyB2b2lkIDAgOiBwb3J0YWxDb250ZXh0LnBvcnRhbE5vZGUsIHJlbGF0ZWRUYXJnZXQpIHx8IHJlbGF0ZWRUYXJnZXQgIT0gbnVsbCAmJiByZWxhdGVkVGFyZ2V0Lmhhc0F0dHJpYnV0ZShjcmVhdGVBdHRyaWJ1dGUoJ2ZvY3VzLWd1YXJkJykpIHx8IHRyZWUgJiYgKGdldENoaWxkcmVuKHRyZWUubm9kZXNSZWYuY3VycmVudCwgbm9kZUlkKS5maW5kKG5vZGUgPT4ge1xuICAgICAgICAgIHZhciBfbm9kZSRjb250ZXh0LCBfbm9kZSRjb250ZXh0MjtcbiAgICAgICAgICByZXR1cm4gY29udGFpbnMoKF9ub2RlJGNvbnRleHQgPSBub2RlLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRjb250ZXh0LmVsZW1lbnRzLmZsb2F0aW5nLCByZWxhdGVkVGFyZ2V0KSB8fCBjb250YWlucygoX25vZGUkY29udGV4dDIgPSBub2RlLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRjb250ZXh0Mi5lbGVtZW50cy5kb21SZWZlcmVuY2UsIHJlbGF0ZWRUYXJnZXQpO1xuICAgICAgICB9KSB8fCBnZXRBbmNlc3RvcnModHJlZS5ub2Rlc1JlZi5jdXJyZW50LCBub2RlSWQpLmZpbmQobm9kZSA9PiB7XG4gICAgICAgICAgdmFyIF9ub2RlJGNvbnRleHQzLCBfbm9kZSRjb250ZXh0NDtcbiAgICAgICAgICByZXR1cm4gKChfbm9kZSRjb250ZXh0MyA9IG5vZGUuY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJGNvbnRleHQzLmVsZW1lbnRzLmZsb2F0aW5nKSA9PT0gcmVsYXRlZFRhcmdldCB8fCAoKF9ub2RlJGNvbnRleHQ0ID0gbm9kZS5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkY29udGV4dDQuZWxlbWVudHMuZG9tUmVmZXJlbmNlKSA9PT0gcmVsYXRlZFRhcmdldDtcbiAgICAgICAgfSkpKTtcblxuICAgICAgICAvLyBGb2N1cyBkaWQgbm90IG1vdmUgaW5zaWRlIHRoZSBmbG9hdGluZyB0cmVlLCBhbmQgdGhlcmUgYXJlIG5vIHRhYmJhYmxlXG4gICAgICAgIC8vIHBvcnRhbCBndWFyZHMgdG8gaGFuZGxlIGNsb3NpbmcuXG4gICAgICAgIGlmIChyZWxhdGVkVGFyZ2V0ICYmIG1vdmVkVG9VbnJlbGF0ZWROb2RlICYmICFpc1BvaW50ZXJEb3duUmVmLmN1cnJlbnQgJiZcbiAgICAgICAgLy8gRml4IFJlYWN0IDE4IFN0cmljdCBNb2RlIHJldHVybkZvY3VzIGR1ZSB0byBkb3VibGUgcmVuZGVyaW5nLlxuICAgICAgICByZWxhdGVkVGFyZ2V0ICE9PSBnZXRQcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQoKSkge1xuICAgICAgICAgIHByZXZlbnRSZXR1cm5Gb2N1c1JlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChmbG9hdGluZyAmJiBpc0hUTUxFbGVtZW50KGRvbVJlZmVyZW5jZSkpIHtcbiAgICAgIGRvbVJlZmVyZW5jZS5hZGRFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIGhhbmRsZUZvY3VzT3V0c2lkZSk7XG4gICAgICBkb21SZWZlcmVuY2UuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCBoYW5kbGVQb2ludGVyRG93bik7XG4gICAgICAhbW9kYWwgJiYgZmxvYXRpbmcuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCBoYW5kbGVGb2N1c091dHNpZGUpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgZG9tUmVmZXJlbmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgaGFuZGxlRm9jdXNPdXRzaWRlKTtcbiAgICAgICAgZG9tUmVmZXJlbmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgaGFuZGxlUG9pbnRlckRvd24pO1xuICAgICAgICAhbW9kYWwgJiYgZmxvYXRpbmcucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCBoYW5kbGVGb2N1c091dHNpZGUpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFtkaXNhYmxlZCwgZG9tUmVmZXJlbmNlLCBmbG9hdGluZywgbW9kYWwsIG5vZGVJZCwgdHJlZSwgcG9ydGFsQ29udGV4dCwgb25PcGVuQ2hhbmdlLCBjbG9zZU9uRm9jdXNPdXRdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICB2YXIgX3BvcnRhbENvbnRleHQkcG9ydGFsO1xuICAgIGlmIChkaXNhYmxlZCkgcmV0dXJuO1xuXG4gICAgLy8gRG9uJ3QgaGlkZSBwb3J0YWxzIG5lc3RlZCB3aXRoaW4gdGhlIHBhcmVudCBwb3J0YWwuXG4gICAgY29uc3QgcG9ydGFsTm9kZXMgPSBBcnJheS5mcm9tKChwb3J0YWxDb250ZXh0ID09IG51bGwgfHwgKF9wb3J0YWxDb250ZXh0JHBvcnRhbCA9IHBvcnRhbENvbnRleHQucG9ydGFsTm9kZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9wb3J0YWxDb250ZXh0JHBvcnRhbC5xdWVyeVNlbGVjdG9yQWxsKFwiW1wiICsgY3JlYXRlQXR0cmlidXRlKCdwb3J0YWwnKSArIFwiXVwiKSkgfHwgW10pO1xuICAgIGlmIChmbG9hdGluZykge1xuICAgICAgY29uc3QgaW5zaWRlRWxlbWVudHMgPSBbZmxvYXRpbmcsIC4uLnBvcnRhbE5vZGVzLCBzdGFydERpc21pc3NCdXR0b25SZWYuY3VycmVudCwgZW5kRGlzbWlzc0J1dHRvblJlZi5jdXJyZW50LCBvcmRlclJlZi5jdXJyZW50LmluY2x1ZGVzKCdyZWZlcmVuY2UnKSB8fCBpc1VudHJhcHBlZFR5cGVhYmxlQ29tYm9ib3ggPyBkb21SZWZlcmVuY2UgOiBudWxsXS5maWx0ZXIoeCA9PiB4ICE9IG51bGwpO1xuICAgICAgY29uc3QgY2xlYW51cCA9IG1vZGFsIHx8IGlzVW50cmFwcGVkVHlwZWFibGVDb21ib2JveCA/IG1hcmtPdGhlcnMoaW5zaWRlRWxlbWVudHMsIGd1YXJkcywgIWd1YXJkcykgOiBtYXJrT3RoZXJzKGluc2lkZUVsZW1lbnRzKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCBbZGlzYWJsZWQsIGRvbVJlZmVyZW5jZSwgZmxvYXRpbmcsIG1vZGFsLCBvcmRlclJlZiwgcG9ydGFsQ29udGV4dCwgaXNVbnRyYXBwZWRUeXBlYWJsZUNvbWJvYm94LCBndWFyZHNdKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmIChkaXNhYmxlZCB8fCAhZmxvYXRpbmcpIHJldHVybjtcbiAgICBjb25zdCBkb2MgPSBnZXREb2N1bWVudChmbG9hdGluZyk7XG4gICAgY29uc3QgcHJldmlvdXNseUZvY3VzZWRFbGVtZW50ID0gYWN0aXZlRWxlbWVudChkb2MpO1xuXG4gICAgLy8gV2FpdCBmb3IgYW55IGxheW91dCBlZmZlY3Qgc3RhdGUgc2V0dGVycyB0byBleGVjdXRlIHRvIHNldCBgdGFiSW5kZXhgLlxuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgIGNvbnN0IGZvY3VzYWJsZUVsZW1lbnRzID0gZ2V0VGFiYmFibGVFbGVtZW50cyhmbG9hdGluZyk7XG4gICAgICBjb25zdCBpbml0aWFsRm9jdXNWYWx1ZSA9IGluaXRpYWxGb2N1c1JlZi5jdXJyZW50O1xuICAgICAgY29uc3QgZWxUb0ZvY3VzID0gKHR5cGVvZiBpbml0aWFsRm9jdXNWYWx1ZSA9PT0gJ251bWJlcicgPyBmb2N1c2FibGVFbGVtZW50c1tpbml0aWFsRm9jdXNWYWx1ZV0gOiBpbml0aWFsRm9jdXNWYWx1ZS5jdXJyZW50KSB8fCBmbG9hdGluZztcbiAgICAgIGNvbnN0IGZvY3VzQWxyZWFkeUluc2lkZUZsb2F0aW5nRWwgPSBjb250YWlucyhmbG9hdGluZywgcHJldmlvdXNseUZvY3VzZWRFbGVtZW50KTtcbiAgICAgIGlmICghaWdub3JlSW5pdGlhbEZvY3VzICYmICFmb2N1c0FscmVhZHlJbnNpZGVGbG9hdGluZ0VsICYmIG9wZW4pIHtcbiAgICAgICAgZW5xdWV1ZUZvY3VzKGVsVG9Gb2N1cywge1xuICAgICAgICAgIHByZXZlbnRTY3JvbGw6IGVsVG9Gb2N1cyA9PT0gZmxvYXRpbmdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIFtkaXNhYmxlZCwgb3BlbiwgZmxvYXRpbmcsIGlnbm9yZUluaXRpYWxGb2N1cywgZ2V0VGFiYmFibGVFbGVtZW50cywgaW5pdGlhbEZvY3VzUmVmXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQgfHwgIWZsb2F0aW5nKSByZXR1cm47XG4gICAgbGV0IHByZXZlbnRSZXR1cm5Gb2N1c1Njcm9sbCA9IGZhbHNlO1xuICAgIGNvbnN0IGRvYyA9IGdldERvY3VtZW50KGZsb2F0aW5nKTtcbiAgICBjb25zdCBwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQgPSBhY3RpdmVFbGVtZW50KGRvYyk7XG4gICAgY29uc3QgY29udGV4dERhdGEgPSBkYXRhUmVmLmN1cnJlbnQ7XG4gICAgYWRkUHJldmlvdXNseUZvY3VzZWRFbGVtZW50KHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCk7XG5cbiAgICAvLyBEaXNtaXNzaW5nIHZpYSBvdXRzaWRlIHByZXNzIHNob3VsZCBhbHdheXMgaWdub3JlIGByZXR1cm5Gb2N1c2AgdG9cbiAgICAvLyBwcmV2ZW50IHVud2FudGVkIHNjcm9sbGluZy5cbiAgICBmdW5jdGlvbiBvbk9wZW5DaGFuZ2UoX3JlZikge1xuICAgICAgbGV0IHtcbiAgICAgICAgcmVhc29uLFxuICAgICAgICBldmVudCxcbiAgICAgICAgbmVzdGVkXG4gICAgICB9ID0gX3JlZjtcbiAgICAgIGlmIChyZWFzb24gPT09ICdlc2NhcGUta2V5JyAmJiByZWZzLmRvbVJlZmVyZW5jZS5jdXJyZW50KSB7XG4gICAgICAgIGFkZFByZXZpb3VzbHlGb2N1c2VkRWxlbWVudChyZWZzLmRvbVJlZmVyZW5jZS5jdXJyZW50KTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWFzb24gPT09ICdob3ZlcicgJiYgZXZlbnQudHlwZSA9PT0gJ21vdXNlbGVhdmUnKSB7XG4gICAgICAgIHByZXZlbnRSZXR1cm5Gb2N1c1JlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWFzb24gIT09ICdvdXRzaWRlLXByZXNzJykgcmV0dXJuO1xuICAgICAgaWYgKG5lc3RlZCkge1xuICAgICAgICBwcmV2ZW50UmV0dXJuRm9jdXNSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICBwcmV2ZW50UmV0dXJuRm9jdXNTY3JvbGwgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJldmVudFJldHVybkZvY3VzUmVmLmN1cnJlbnQgPSAhKGlzVmlydHVhbENsaWNrKGV2ZW50KSB8fCBpc1ZpcnR1YWxQb2ludGVyRXZlbnQoZXZlbnQpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZXZlbnRzLm9uKCdvcGVuY2hhbmdlJywgb25PcGVuQ2hhbmdlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZXZlbnRzLm9mZignb3BlbmNoYW5nZScsIG9uT3BlbkNoYW5nZSk7XG4gICAgICBjb25zdCBhY3RpdmVFbCA9IGFjdGl2ZUVsZW1lbnQoZG9jKTtcbiAgICAgIGNvbnN0IGlzRm9jdXNJbnNpZGVGbG9hdGluZ1RyZWUgPSBjb250YWlucyhmbG9hdGluZywgYWN0aXZlRWwpIHx8IHRyZWUgJiYgZ2V0Q2hpbGRyZW4odHJlZS5ub2Rlc1JlZi5jdXJyZW50LCBub2RlSWQpLnNvbWUobm9kZSA9PiB7XG4gICAgICAgIHZhciBfbm9kZSRjb250ZXh0NTtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5zKChfbm9kZSRjb250ZXh0NSA9IG5vZGUuY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJGNvbnRleHQ1LmVsZW1lbnRzLmZsb2F0aW5nLCBhY3RpdmVFbCk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHNob3VsZEZvY3VzUmVmZXJlbmNlID0gaXNGb2N1c0luc2lkZUZsb2F0aW5nVHJlZSB8fCBjb250ZXh0RGF0YS5vcGVuRXZlbnQgJiYgWydjbGljaycsICdtb3VzZWRvd24nXS5pbmNsdWRlcyhjb250ZXh0RGF0YS5vcGVuRXZlbnQudHlwZSk7XG4gICAgICBpZiAoc2hvdWxkRm9jdXNSZWZlcmVuY2UgJiYgcmVmcy5kb21SZWZlcmVuY2UuY3VycmVudCkge1xuICAgICAgICBhZGRQcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQocmVmcy5kb21SZWZlcmVuY2UuY3VycmVudCk7XG4gICAgICB9XG4gICAgICBjb25zdCByZXR1cm5FbGVtZW50ID0gZ2V0UHJldmlvdXNseUZvY3VzZWRFbGVtZW50KCk7XG4gICAgICBpZiAocmV0dXJuRm9jdXNSZWYuY3VycmVudCAmJiAhcHJldmVudFJldHVybkZvY3VzUmVmLmN1cnJlbnQgJiYgaXNIVE1MRWxlbWVudChyZXR1cm5FbGVtZW50KSAmJiAoXG4gICAgICAvLyBJZiB0aGUgZm9jdXMgbW92ZWQgc29tZXdoZXJlIGVsc2UgYWZ0ZXIgbW91bnQsIGF2b2lkIHJldHVybmluZyBmb2N1c1xuICAgICAgLy8gc2luY2UgaXQgbGlrZWx5IGVudGVyZWQgYSBkaWZmZXJlbnQgZWxlbWVudCB3aGljaCBzaG91bGQgYmVcbiAgICAgIC8vIHJlc3BlY3RlZDogaHR0cHM6Ly9naXRodWIuY29tL2Zsb2F0aW5nLXVpL2Zsb2F0aW5nLXVpL2lzc3Vlcy8yNjA3XG4gICAgICByZXR1cm5FbGVtZW50ICE9PSBhY3RpdmVFbCAmJiBhY3RpdmVFbCAhPT0gZG9jLmJvZHkgPyBpc0ZvY3VzSW5zaWRlRmxvYXRpbmdUcmVlIDogdHJ1ZSkpIHtcbiAgICAgICAgZW5xdWV1ZUZvY3VzKHJldHVybkVsZW1lbnQsIHtcbiAgICAgICAgICAvLyBXaGVuIGRpc21pc3NpbmcgbmVzdGVkIGZsb2F0aW5nIGVsZW1lbnRzLCBieSB0aGUgdGltZSB0aGUgckFGIGhhc1xuICAgICAgICAgIC8vIGV4ZWN1dGVkLCB0aGUgbWVudXMgd2lsbCBhbGwgaGF2ZSBiZWVuIHVubW91bnRlZC4gV2hlbiB0aGV5IHRyeVxuICAgICAgICAgIC8vIHRvIGdldCBmb2N1c2VkLCB0aGUgY2FsbHMgZ2V0IGlnbm9yZWQg4oCUIGxlYXZpbmcgdGhlIHJvb3RcbiAgICAgICAgICAvLyByZWZlcmVuY2UgZm9jdXNlZCBhcyBkZXNpcmVkLlxuICAgICAgICAgIGNhbmNlbFByZXZpb3VzOiBmYWxzZSxcbiAgICAgICAgICBwcmV2ZW50U2Nyb2xsOiBwcmV2ZW50UmV0dXJuRm9jdXNTY3JvbGxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2Rpc2FibGVkLCBmbG9hdGluZywgcmV0dXJuRm9jdXNSZWYsIGRhdGFSZWYsIHJlZnMsIGV2ZW50cywgdHJlZSwgbm9kZUlkXSk7XG5cbiAgLy8gU3luY2hyb25pemUgdGhlIGBjb250ZXh0YCAmIGBtb2RhbGAgdmFsdWUgdG8gdGhlIEZsb2F0aW5nUG9ydGFsIGNvbnRleHQuXG4gIC8vIEl0IHdpbGwgZGVjaWRlIHdoZXRoZXIgb3Igbm90IGl0IG5lZWRzIHRvIHJlbmRlciBpdHMgb3duIGd1YXJkcy5cbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmIChkaXNhYmxlZCB8fCAhcG9ydGFsQ29udGV4dCkgcmV0dXJuO1xuICAgIHBvcnRhbENvbnRleHQuc2V0Rm9jdXNNYW5hZ2VyU3RhdGUoe1xuICAgICAgbW9kYWwsXG4gICAgICBjbG9zZU9uRm9jdXNPdXQsXG4gICAgICBvcGVuLFxuICAgICAgb25PcGVuQ2hhbmdlLFxuICAgICAgcmVmc1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBwb3J0YWxDb250ZXh0LnNldEZvY3VzTWFuYWdlclN0YXRlKG51bGwpO1xuICAgIH07XG4gIH0sIFtkaXNhYmxlZCwgcG9ydGFsQ29udGV4dCwgbW9kYWwsIG9wZW4sIG9uT3BlbkNoYW5nZSwgcmVmcywgY2xvc2VPbkZvY3VzT3V0XSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQgfHwgIWZsb2F0aW5nIHx8IHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAnZnVuY3Rpb24nIHx8IGlnbm9yZUluaXRpYWxGb2N1cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBoYW5kbGVNdXRhdGlvbiA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHRhYkluZGV4ID0gZmxvYXRpbmcuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpO1xuICAgICAgaWYgKG9yZGVyUmVmLmN1cnJlbnQuaW5jbHVkZXMoJ2Zsb2F0aW5nJykgfHwgYWN0aXZlRWxlbWVudChnZXREb2N1bWVudChmbG9hdGluZykpICE9PSByZWZzLmRvbVJlZmVyZW5jZS5jdXJyZW50ICYmIGdldFRhYmJhYmxlQ29udGVudCgpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpZiAodGFiSW5kZXggIT09ICcwJykge1xuICAgICAgICAgIGZsb2F0aW5nLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnMCcpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRhYkluZGV4ICE9PSAnLTEnKSB7XG4gICAgICAgIGZsb2F0aW5nLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGhhbmRsZU11dGF0aW9uKCk7XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihoYW5kbGVNdXRhdGlvbik7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShmbG9hdGluZywge1xuICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgc3VidHJlZTogdHJ1ZSxcbiAgICAgIGF0dHJpYnV0ZXM6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIH07XG4gIH0sIFtkaXNhYmxlZCwgZmxvYXRpbmcsIHJlZnMsIG9yZGVyUmVmLCBnZXRUYWJiYWJsZUNvbnRlbnQsIGlnbm9yZUluaXRpYWxGb2N1c10pO1xuICBmdW5jdGlvbiByZW5kZXJEaXNtaXNzQnV0dG9uKGxvY2F0aW9uKSB7XG4gICAgaWYgKGRpc2FibGVkIHx8ICF2aXN1YWxseUhpZGRlbkRpc21pc3MgfHwgIW1vZGFsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFZpc3VhbGx5SGlkZGVuRGlzbWlzcywge1xuICAgICAgcmVmOiBsb2NhdGlvbiA9PT0gJ3N0YXJ0JyA/IHN0YXJ0RGlzbWlzc0J1dHRvblJlZiA6IGVuZERpc21pc3NCdXR0b25SZWYsXG4gICAgICBvbkNsaWNrOiBldmVudCA9PiBvbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50Lm5hdGl2ZUV2ZW50KVxuICAgIH0sIHR5cGVvZiB2aXN1YWxseUhpZGRlbkRpc21pc3MgPT09ICdzdHJpbmcnID8gdmlzdWFsbHlIaWRkZW5EaXNtaXNzIDogJ0Rpc21pc3MnKTtcbiAgfVxuICBjb25zdCBzaG91bGRSZW5kZXJHdWFyZHMgPSAhZGlzYWJsZWQgJiYgZ3VhcmRzICYmIChpc0luc2lkZVBvcnRhbCB8fCBtb2RhbCk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgc2hvdWxkUmVuZGVyR3VhcmRzICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZvY3VzR3VhcmQsIHtcbiAgICBcImRhdGEtdHlwZVwiOiBcImluc2lkZVwiLFxuICAgIHJlZjogcG9ydGFsQ29udGV4dCA9PSBudWxsID8gdm9pZCAwIDogcG9ydGFsQ29udGV4dC5iZWZvcmVJbnNpZGVSZWYsXG4gICAgb25Gb2N1czogZXZlbnQgPT4ge1xuICAgICAgaWYgKG1vZGFsKSB7XG4gICAgICAgIGNvbnN0IGVscyA9IGdldFRhYmJhYmxlRWxlbWVudHMoKTtcbiAgICAgICAgZW5xdWV1ZUZvY3VzKG9yZGVyWzBdID09PSAncmVmZXJlbmNlJyA/IGVsc1swXSA6IGVsc1tlbHMubGVuZ3RoIC0gMV0pO1xuICAgICAgfSBlbHNlIGlmIChwb3J0YWxDb250ZXh0ICE9IG51bGwgJiYgcG9ydGFsQ29udGV4dC5wcmVzZXJ2ZVRhYk9yZGVyICYmIHBvcnRhbENvbnRleHQucG9ydGFsTm9kZSkge1xuICAgICAgICBwcmV2ZW50UmV0dXJuRm9jdXNSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICBpZiAoaXNPdXRzaWRlRXZlbnQoZXZlbnQsIHBvcnRhbENvbnRleHQucG9ydGFsTm9kZSkpIHtcbiAgICAgICAgICBjb25zdCBuZXh0VGFiYmFibGUgPSBnZXROZXh0VGFiYmFibGUoKSB8fCBkb21SZWZlcmVuY2U7XG4gICAgICAgICAgbmV4dFRhYmJhYmxlID09IG51bGwgfHwgbmV4dFRhYmJhYmxlLmZvY3VzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9wb3J0YWxDb250ZXh0JGJlZm9yZTtcbiAgICAgICAgICAoX3BvcnRhbENvbnRleHQkYmVmb3JlID0gcG9ydGFsQ29udGV4dC5iZWZvcmVPdXRzaWRlUmVmLmN1cnJlbnQpID09IG51bGwgfHwgX3BvcnRhbENvbnRleHQkYmVmb3JlLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pLCAhaXNVbnRyYXBwZWRUeXBlYWJsZUNvbWJvYm94ICYmIHJlbmRlckRpc21pc3NCdXR0b24oJ3N0YXJ0JyksIGNoaWxkcmVuLCByZW5kZXJEaXNtaXNzQnV0dG9uKCdlbmQnKSwgc2hvdWxkUmVuZGVyR3VhcmRzICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZvY3VzR3VhcmQsIHtcbiAgICBcImRhdGEtdHlwZVwiOiBcImluc2lkZVwiLFxuICAgIHJlZjogcG9ydGFsQ29udGV4dCA9PSBudWxsID8gdm9pZCAwIDogcG9ydGFsQ29udGV4dC5hZnRlckluc2lkZVJlZixcbiAgICBvbkZvY3VzOiBldmVudCA9PiB7XG4gICAgICBpZiAobW9kYWwpIHtcbiAgICAgICAgZW5xdWV1ZUZvY3VzKGdldFRhYmJhYmxlRWxlbWVudHMoKVswXSk7XG4gICAgICB9IGVsc2UgaWYgKHBvcnRhbENvbnRleHQgIT0gbnVsbCAmJiBwb3J0YWxDb250ZXh0LnByZXNlcnZlVGFiT3JkZXIgJiYgcG9ydGFsQ29udGV4dC5wb3J0YWxOb2RlKSB7XG4gICAgICAgIGlmIChjbG9zZU9uRm9jdXNPdXQpIHtcbiAgICAgICAgICBwcmV2ZW50UmV0dXJuRm9jdXNSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzT3V0c2lkZUV2ZW50KGV2ZW50LCBwb3J0YWxDb250ZXh0LnBvcnRhbE5vZGUpKSB7XG4gICAgICAgICAgY29uc3QgcHJldlRhYmJhYmxlID0gZ2V0UHJldmlvdXNUYWJiYWJsZSgpIHx8IGRvbVJlZmVyZW5jZTtcbiAgICAgICAgICBwcmV2VGFiYmFibGUgPT0gbnVsbCB8fCBwcmV2VGFiYmFibGUuZm9jdXMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX3BvcnRhbENvbnRleHQkYWZ0ZXJPO1xuICAgICAgICAgIChfcG9ydGFsQ29udGV4dCRhZnRlck8gPSBwb3J0YWxDb250ZXh0LmFmdGVyT3V0c2lkZVJlZi5jdXJyZW50KSA9PSBudWxsIHx8IF9wb3J0YWxDb250ZXh0JGFmdGVyTy5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KSk7XG59XG5cbmNvbnN0IGFjdGl2ZUxvY2tzID0gLyojX19QVVJFX18qL25ldyBTZXQoKTtcbi8qKlxuICogUHJvdmlkZXMgYmFzZSBzdHlsaW5nIGZvciBhIGZpeGVkIG92ZXJsYXkgZWxlbWVudCB0byBkaW0gY29udGVudCBvciBibG9ja1xuICogcG9pbnRlciBldmVudHMgYmVoaW5kIGEgZmxvYXRpbmcgZWxlbWVudC5cbiAqIEl0J3MgYSByZWd1bGFyIGA8ZGl2PmAsIHNvIGl0IGNhbiBiZSBzdHlsZWQgdmlhIGFueSBDU1Mgc29sdXRpb24geW91IHByZWZlci5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9GbG9hdGluZ092ZXJsYXlcbiAqL1xuY29uc3QgRmxvYXRpbmdPdmVybGF5ID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gRmxvYXRpbmdPdmVybGF5KF9yZWYsIHJlZikge1xuICBsZXQge1xuICAgIGxvY2tTY3JvbGwgPSBmYWxzZSxcbiAgICAuLi5yZXN0XG4gIH0gPSBfcmVmO1xuICBjb25zdCBsb2NrSWQgPSB1c2VJZCgpO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKCFsb2NrU2Nyb2xsKSByZXR1cm47XG4gICAgYWN0aXZlTG9ja3MuYWRkKGxvY2tJZCk7XG4gICAgY29uc3QgaXNJT1MgPSAvaVAoaG9uZXxhZHxvZCl8aU9TLy50ZXN0KGdldFBsYXRmb3JtKCkpO1xuICAgIGNvbnN0IGJvZHlTdHlsZSA9IGRvY3VtZW50LmJvZHkuc3R5bGU7XG4gICAgLy8gUlRMIDxib2R5PiBzY3JvbGxiYXJcbiAgICBjb25zdCBzY3JvbGxiYXJYID0gTWF0aC5yb3VuZChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCkgKyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdDtcbiAgICBjb25zdCBwYWRkaW5nUHJvcCA9IHNjcm9sbGJhclggPyAncGFkZGluZ0xlZnQnIDogJ3BhZGRpbmdSaWdodCc7XG4gICAgY29uc3Qgc2Nyb2xsYmFyV2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aCAtIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICBjb25zdCBzY3JvbGxYID0gYm9keVN0eWxlLmxlZnQgPyBwYXJzZUZsb2F0KGJvZHlTdHlsZS5sZWZ0KSA6IHdpbmRvdy5wYWdlWE9mZnNldDtcbiAgICBjb25zdCBzY3JvbGxZID0gYm9keVN0eWxlLnRvcCA/IHBhcnNlRmxvYXQoYm9keVN0eWxlLnRvcCkgOiB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gICAgYm9keVN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgaWYgKHNjcm9sbGJhcldpZHRoKSB7XG4gICAgICBib2R5U3R5bGVbcGFkZGluZ1Byb3BdID0gc2Nyb2xsYmFyV2lkdGggKyBcInB4XCI7XG4gICAgfVxuXG4gICAgLy8gT25seSBpT1MgZG9lc24ndCByZXNwZWN0IGBvdmVyZmxvdzogaGlkZGVuYCBvbiBkb2N1bWVudC5ib2R5LCBhbmQgdGhpc1xuICAgIC8vIHRlY2huaXF1ZSBoYXMgZmV3ZXIgc2lkZSBlZmZlY3RzLlxuICAgIGlmIChpc0lPUykge1xuICAgICAgdmFyIF93aW5kb3ckdmlzdWFsVmlld3BvciwgX3dpbmRvdyR2aXN1YWxWaWV3cG9yMjtcbiAgICAgIC8vIGlPUyAxMiBkb2VzIG5vdCBzdXBwb3J0IGB2aXN1YWxWaWV3cG9ydGAuXG4gICAgICBjb25zdCBvZmZzZXRMZWZ0ID0gKChfd2luZG93JHZpc3VhbFZpZXdwb3IgPSB3aW5kb3cudmlzdWFsVmlld3BvcnQpID09IG51bGwgPyB2b2lkIDAgOiBfd2luZG93JHZpc3VhbFZpZXdwb3Iub2Zmc2V0TGVmdCkgfHwgMDtcbiAgICAgIGNvbnN0IG9mZnNldFRvcCA9ICgoX3dpbmRvdyR2aXN1YWxWaWV3cG9yMiA9IHdpbmRvdy52aXN1YWxWaWV3cG9ydCkgPT0gbnVsbCA/IHZvaWQgMCA6IF93aW5kb3ckdmlzdWFsVmlld3BvcjIub2Zmc2V0VG9wKSB8fCAwO1xuICAgICAgT2JqZWN0LmFzc2lnbihib2R5U3R5bGUsIHtcbiAgICAgICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgICAgIHRvcDogLShzY3JvbGxZIC0gTWF0aC5mbG9vcihvZmZzZXRUb3ApKSArIFwicHhcIixcbiAgICAgICAgbGVmdDogLShzY3JvbGxYIC0gTWF0aC5mbG9vcihvZmZzZXRMZWZ0KSkgKyBcInB4XCIsXG4gICAgICAgIHJpZ2h0OiAnMCdcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgYWN0aXZlTG9ja3MuZGVsZXRlKGxvY2tJZCk7XG4gICAgICBpZiAoYWN0aXZlTG9ja3Muc2l6ZSA9PT0gMCkge1xuICAgICAgICBPYmplY3QuYXNzaWduKGJvZHlTdHlsZSwge1xuICAgICAgICAgIG92ZXJmbG93OiAnJyxcbiAgICAgICAgICBbcGFkZGluZ1Byb3BdOiAnJ1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGlzSU9TKSB7XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihib2R5U3R5bGUsIHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnJyxcbiAgICAgICAgICAgIHRvcDogJycsXG4gICAgICAgICAgICBsZWZ0OiAnJyxcbiAgICAgICAgICAgIHJpZ2h0OiAnJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHdpbmRvdy5zY3JvbGxUbyhzY3JvbGxYLCBzY3JvbGxZKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0sIFtsb2NrSWQsIGxvY2tTY3JvbGxdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9leHRlbmRzKHtcbiAgICByZWY6IHJlZlxuICB9LCByZXN0LCB7XG4gICAgc3R5bGU6IHtcbiAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgb3ZlcmZsb3c6ICdhdXRvJyxcbiAgICAgIHRvcDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgYm90dG9tOiAwLFxuICAgICAgbGVmdDogMCxcbiAgICAgIC4uLnJlc3Quc3R5bGVcbiAgICB9XG4gIH0pKTtcbn0pO1xuXG5mdW5jdGlvbiBpc0J1dHRvblRhcmdldChldmVudCkge1xuICByZXR1cm4gaXNIVE1MRWxlbWVudChldmVudC50YXJnZXQpICYmIGV2ZW50LnRhcmdldC50YWdOYW1lID09PSAnQlVUVE9OJztcbn1cbmZ1bmN0aW9uIGlzU3BhY2VJZ25vcmVkKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGlzVHlwZWFibGVFbGVtZW50KGVsZW1lbnQpO1xufVxuLyoqXG4gKiBPcGVucyBvciBjbG9zZXMgdGhlIGZsb2F0aW5nIGVsZW1lbnQgd2hlbiBjbGlja2luZyB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlQ2xpY2tcbiAqL1xuZnVuY3Rpb24gdXNlQ2xpY2soY29udGV4dCwgcHJvcHMpIHtcbiAgaWYgKHByb3BzID09PSB2b2lkIDApIHtcbiAgICBwcm9wcyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBvcGVuLFxuICAgIG9uT3BlbkNoYW5nZSxcbiAgICBkYXRhUmVmLFxuICAgIGVsZW1lbnRzOiB7XG4gICAgICBkb21SZWZlcmVuY2VcbiAgICB9XG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCB7XG4gICAgZW5hYmxlZCA9IHRydWUsXG4gICAgZXZlbnQ6IGV2ZW50T3B0aW9uID0gJ2NsaWNrJyxcbiAgICB0b2dnbGUgPSB0cnVlLFxuICAgIGlnbm9yZU1vdXNlID0gZmFsc2UsXG4gICAga2V5Ym9hcmRIYW5kbGVycyA9IHRydWVcbiAgfSA9IHByb3BzO1xuICBjb25zdCBwb2ludGVyVHlwZVJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICBjb25zdCBkaWRLZXlEb3duUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCkgcmV0dXJuIHt9O1xuICAgIHJldHVybiB7XG4gICAgICByZWZlcmVuY2U6IHtcbiAgICAgICAgb25Qb2ludGVyRG93bihldmVudCkge1xuICAgICAgICAgIHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQgPSBldmVudC5wb2ludGVyVHlwZTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Nb3VzZURvd24oZXZlbnQpIHtcbiAgICAgICAgICAvLyBJZ25vcmUgYWxsIGJ1dHRvbnMgZXhjZXB0IGZvciB0aGUgXCJtYWluXCIgYnV0dG9uLlxuICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Nb3VzZUV2ZW50L2J1dHRvblxuICAgICAgICAgIGlmIChldmVudC5idXR0b24gIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzTW91c2VMaWtlUG9pbnRlclR5cGUocG9pbnRlclR5cGVSZWYuY3VycmVudCwgdHJ1ZSkgJiYgaWdub3JlTW91c2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGV2ZW50T3B0aW9uID09PSAnY2xpY2snKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcGVuICYmIHRvZ2dsZSAmJiAoZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudCA/IGRhdGFSZWYuY3VycmVudC5vcGVuRXZlbnQudHlwZSA9PT0gJ21vdXNlZG93bicgOiB0cnVlKSkge1xuICAgICAgICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudC5uYXRpdmVFdmVudCwgJ2NsaWNrJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFByZXZlbnQgc3RlYWxpbmcgZm9jdXMgZnJvbSB0aGUgZmxvYXRpbmcgZWxlbWVudFxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIG9uT3BlbkNoYW5nZSh0cnVlLCBldmVudC5uYXRpdmVFdmVudCwgJ2NsaWNrJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbkNsaWNrKGV2ZW50KSB7XG4gICAgICAgICAgaWYgKGV2ZW50T3B0aW9uID09PSAnbW91c2Vkb3duJyAmJiBwb2ludGVyVHlwZVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBwb2ludGVyVHlwZVJlZi5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNNb3VzZUxpa2VQb2ludGVyVHlwZShwb2ludGVyVHlwZVJlZi5jdXJyZW50LCB0cnVlKSAmJiBpZ25vcmVNb3VzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3BlbiAmJiB0b2dnbGUgJiYgKGRhdGFSZWYuY3VycmVudC5vcGVuRXZlbnQgPyBkYXRhUmVmLmN1cnJlbnQub3BlbkV2ZW50LnR5cGUgPT09ICdjbGljaycgOiB0cnVlKSkge1xuICAgICAgICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudC5uYXRpdmVFdmVudCwgJ2NsaWNrJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9uT3BlbkNoYW5nZSh0cnVlLCBldmVudC5uYXRpdmVFdmVudCwgJ2NsaWNrJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbktleURvd24oZXZlbnQpIHtcbiAgICAgICAgICBwb2ludGVyVHlwZVJlZi5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkIHx8ICFrZXlib2FyZEhhbmRsZXJzIHx8IGlzQnV0dG9uVGFyZ2V0KGV2ZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnICcgJiYgIWlzU3BhY2VJZ25vcmVkKGRvbVJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgIC8vIFByZXZlbnQgc2Nyb2xsaW5nXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZGlkS2V5RG93blJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ0VudGVyJykge1xuICAgICAgICAgICAgaWYgKG9wZW4gJiYgdG9nZ2xlKSB7XG4gICAgICAgICAgICAgIG9uT3BlbkNoYW5nZShmYWxzZSwgZXZlbnQubmF0aXZlRXZlbnQsICdjbGljaycpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb25PcGVuQ2hhbmdlKHRydWUsIGV2ZW50Lm5hdGl2ZUV2ZW50LCAnY2xpY2snKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uS2V5VXAoZXZlbnQpIHtcbiAgICAgICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCB8fCAha2V5Ym9hcmRIYW5kbGVycyB8fCBpc0J1dHRvblRhcmdldChldmVudCkgfHwgaXNTcGFjZUlnbm9yZWQoZG9tUmVmZXJlbmNlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnICcgJiYgZGlkS2V5RG93blJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBkaWRLZXlEb3duUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChvcGVuICYmIHRvZ2dsZSkge1xuICAgICAgICAgICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50Lm5hdGl2ZUV2ZW50LCAnY2xpY2snKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG9uT3BlbkNoYW5nZSh0cnVlLCBldmVudC5uYXRpdmVFdmVudCwgJ2NsaWNrJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2VuYWJsZWQsIGRhdGFSZWYsIGV2ZW50T3B0aW9uLCBpZ25vcmVNb3VzZSwga2V5Ym9hcmRIYW5kbGVycywgZG9tUmVmZXJlbmNlLCB0b2dnbGUsIG9wZW4sIG9uT3BlbkNoYW5nZV0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVWaXJ0dWFsRWxlbWVudChkb21SZWYsIGRhdGEpIHtcbiAgbGV0IG9mZnNldFggPSBudWxsO1xuICBsZXQgb2Zmc2V0WSA9IG51bGw7XG4gIGxldCBpc0F1dG9VcGRhdGVFdmVudCA9IGZhbHNlO1xuICByZXR1cm4ge1xuICAgIGNvbnRleHRFbGVtZW50OiBkb21SZWYuY3VycmVudCB8fCB1bmRlZmluZWQsXG4gICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkge1xuICAgICAgdmFyIF9kb21SZWYkY3VycmVudCwgX2RhdGEkZGF0YVJlZiRjdXJyZW50O1xuICAgICAgY29uc3QgZG9tUmVjdCA9ICgoX2RvbVJlZiRjdXJyZW50ID0gZG9tUmVmLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZG9tUmVmJGN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpIHx8IHtcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfTtcbiAgICAgIGNvbnN0IGlzWEF4aXMgPSBkYXRhLmF4aXMgPT09ICd4JyB8fCBkYXRhLmF4aXMgPT09ICdib3RoJztcbiAgICAgIGNvbnN0IGlzWUF4aXMgPSBkYXRhLmF4aXMgPT09ICd5JyB8fCBkYXRhLmF4aXMgPT09ICdib3RoJztcbiAgICAgIGNvbnN0IGNhblRyYWNrQ3Vyc29yT25BdXRvVXBkYXRlID0gWydtb3VzZWVudGVyJywgJ21vdXNlbW92ZSddLmluY2x1ZGVzKCgoX2RhdGEkZGF0YVJlZiRjdXJyZW50ID0gZGF0YS5kYXRhUmVmLmN1cnJlbnQub3BlbkV2ZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2RhdGEkZGF0YVJlZiRjdXJyZW50LnR5cGUpIHx8ICcnKSAmJiBkYXRhLnBvaW50ZXJUeXBlICE9PSAndG91Y2gnO1xuICAgICAgbGV0IHdpZHRoID0gZG9tUmVjdC53aWR0aDtcbiAgICAgIGxldCBoZWlnaHQgPSBkb21SZWN0LmhlaWdodDtcbiAgICAgIGxldCB4ID0gZG9tUmVjdC54O1xuICAgICAgbGV0IHkgPSBkb21SZWN0Lnk7XG4gICAgICBpZiAob2Zmc2V0WCA9PSBudWxsICYmIGRhdGEueCAmJiBpc1hBeGlzKSB7XG4gICAgICAgIG9mZnNldFggPSBkb21SZWN0LnggLSBkYXRhLng7XG4gICAgICB9XG4gICAgICBpZiAob2Zmc2V0WSA9PSBudWxsICYmIGRhdGEueSAmJiBpc1lBeGlzKSB7XG4gICAgICAgIG9mZnNldFkgPSBkb21SZWN0LnkgLSBkYXRhLnk7XG4gICAgICB9XG4gICAgICB4IC09IG9mZnNldFggfHwgMDtcbiAgICAgIHkgLT0gb2Zmc2V0WSB8fCAwO1xuICAgICAgd2lkdGggPSAwO1xuICAgICAgaGVpZ2h0ID0gMDtcbiAgICAgIGlmICghaXNBdXRvVXBkYXRlRXZlbnQgfHwgY2FuVHJhY2tDdXJzb3JPbkF1dG9VcGRhdGUpIHtcbiAgICAgICAgd2lkdGggPSBkYXRhLmF4aXMgPT09ICd5JyA/IGRvbVJlY3Qud2lkdGggOiAwO1xuICAgICAgICBoZWlnaHQgPSBkYXRhLmF4aXMgPT09ICd4JyA/IGRvbVJlY3QuaGVpZ2h0IDogMDtcbiAgICAgICAgeCA9IGlzWEF4aXMgJiYgZGF0YS54ICE9IG51bGwgPyBkYXRhLnggOiB4O1xuICAgICAgICB5ID0gaXNZQXhpcyAmJiBkYXRhLnkgIT0gbnVsbCA/IGRhdGEueSA6IHk7XG4gICAgICB9IGVsc2UgaWYgKGlzQXV0b1VwZGF0ZUV2ZW50ICYmICFjYW5UcmFja0N1cnNvck9uQXV0b1VwZGF0ZSkge1xuICAgICAgICBoZWlnaHQgPSBkYXRhLmF4aXMgPT09ICd4JyA/IGRvbVJlY3QuaGVpZ2h0IDogaGVpZ2h0O1xuICAgICAgICB3aWR0aCA9IGRhdGEuYXhpcyA9PT0gJ3knID8gZG9tUmVjdC53aWR0aCA6IHdpZHRoO1xuICAgICAgfVxuICAgICAgaXNBdXRvVXBkYXRlRXZlbnQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgdG9wOiB5LFxuICAgICAgICByaWdodDogeCArIHdpZHRoLFxuICAgICAgICBib3R0b206IHkgKyBoZWlnaHQsXG4gICAgICAgIGxlZnQ6IHhcbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gaXNNb3VzZUJhc2VkRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50ICE9IG51bGwgJiYgZXZlbnQuY2xpZW50WCAhPSBudWxsO1xufVxuLyoqXG4gKiBQb3NpdGlvbnMgdGhlIGZsb2F0aW5nIGVsZW1lbnQgcmVsYXRpdmUgdG8gYSBjbGllbnQgcG9pbnQgKGluIHRoZSB2aWV3cG9ydCksXG4gKiBzdWNoIGFzIHRoZSBtb3VzZSBwb3NpdGlvbi4gQnkgZGVmYXVsdCwgaXQgZm9sbG93cyB0aGUgbW91c2UgY3Vyc29yLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3VzZUNsaWVudFBvaW50XG4gKi9cbmZ1bmN0aW9uIHVzZUNsaWVudFBvaW50KGNvbnRleHQsIHByb3BzKSB7XG4gIGlmIChwcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgcHJvcHMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgb3BlbixcbiAgICByZWZzLFxuICAgIGRhdGFSZWYsXG4gICAgZWxlbWVudHM6IHtcbiAgICAgIGZsb2F0aW5nXG4gICAgfVxuICB9ID0gY29udGV4dDtcbiAgY29uc3Qge1xuICAgIGVuYWJsZWQgPSB0cnVlLFxuICAgIGF4aXMgPSAnYm90aCcsXG4gICAgeCA9IG51bGwsXG4gICAgeSA9IG51bGxcbiAgfSA9IHByb3BzO1xuICBjb25zdCBpbml0aWFsUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgY2xlYW51cExpc3RlbmVyUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBbcG9pbnRlclR5cGUsIHNldFBvaW50ZXJUeXBlXSA9IFJlYWN0LnVzZVN0YXRlKCk7XG4gIGNvbnN0IFtyZWFjdGl2ZSwgc2V0UmVhY3RpdmVdID0gUmVhY3QudXNlU3RhdGUoW10pO1xuICBjb25zdCBzZXRSZWZlcmVuY2UgPSB1c2VFZmZlY3RFdmVudCgoeCwgeSkgPT4ge1xuICAgIGlmIChpbml0aWFsUmVmLmN1cnJlbnQpIHJldHVybjtcblxuICAgIC8vIFByZXZlbnQgc2V0dGluZyBpZiB0aGUgb3BlbiBldmVudCB3YXMgbm90IGEgbW91c2UtbGlrZSBvbmVcbiAgICAvLyAoZS5nLiBmb2N1cyB0byBvcGVuLCB0aGVuIGhvdmVyIG92ZXIgdGhlIHJlZmVyZW5jZSBlbGVtZW50KS5cbiAgICAvLyBPbmx5IGFwcGx5IGlmIHRoZSBldmVudCBleGlzdHMuXG4gICAgaWYgKGRhdGFSZWYuY3VycmVudC5vcGVuRXZlbnQgJiYgIWlzTW91c2VCYXNlZEV2ZW50KGRhdGFSZWYuY3VycmVudC5vcGVuRXZlbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlZnMuc2V0UG9zaXRpb25SZWZlcmVuY2UoY3JlYXRlVmlydHVhbEVsZW1lbnQocmVmcy5kb21SZWZlcmVuY2UsIHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgYXhpcyxcbiAgICAgIGRhdGFSZWYsXG4gICAgICBwb2ludGVyVHlwZVxuICAgIH0pKTtcbiAgfSk7XG4gIGNvbnN0IGhhbmRsZVJlZmVyZW5jZUVudGVyT3JNb3ZlID0gdXNlRWZmZWN0RXZlbnQoZXZlbnQgPT4ge1xuICAgIGlmICh4ICE9IG51bGwgfHwgeSAhPSBudWxsKSByZXR1cm47XG4gICAgaWYgKCFvcGVuKSB7XG4gICAgICBzZXRSZWZlcmVuY2UoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgfSBlbHNlIGlmICghY2xlYW51cExpc3RlbmVyUmVmLmN1cnJlbnQpIHtcbiAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gY2xlYW51cCwgdGhlcmUncyBubyBsaXN0ZW5lciwgYnV0IHdlIHdhbnQgdG8gZW5zdXJlXG4gICAgICAvLyB3ZSBhZGQgdGhlIGxpc3RlbmVyIGlmIHRoZSBjdXJzb3IgbGFuZGVkIG9uIHRoZSBmbG9hdGluZyBlbGVtZW50IGFuZFxuICAgICAgLy8gdGhlbiBiYWNrIG9uIHRoZSByZWZlcmVuY2UgKGkuZS4gaXQncyBpbnRlcmFjdGl2ZSkuXG4gICAgICBzZXRSZWFjdGl2ZShbXSk7XG4gICAgfVxuICB9KTtcblxuICAvLyBJZiB0aGUgcG9pbnRlciBpcyBhIG1vdXNlLWxpa2UgcG9pbnRlciwgd2Ugd2FudCB0byBjb250aW51ZSBmb2xsb3dpbmcgdGhlXG4gIC8vIG1vdXNlIGV2ZW4gaWYgdGhlIGZsb2F0aW5nIGVsZW1lbnQgaXMgdHJhbnNpdGlvbmluZyBvdXQuIE9uIHRvdWNoXG4gIC8vIGRldmljZXMsIHRoaXMgaXMgdW5kZXNpcmFibGUgYmVjYXVzZSB0aGUgZmxvYXRpbmcgZWxlbWVudCB3aWxsIG1vdmUgdG9cbiAgLy8gdGhlIGRpc21pc3NhbCB0b3VjaCBwb2ludC5cbiAgY29uc3Qgb3BlbkNoZWNrID0gaXNNb3VzZUxpa2VQb2ludGVyVHlwZShwb2ludGVyVHlwZSkgPyBmbG9hdGluZyA6IG9wZW47XG4gIGNvbnN0IGFkZExpc3RlbmVyID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIC8vIEV4cGxpY2l0bHkgc3BlY2lmaWVkIGB4YC9geWAgY29vcmRpbmF0ZXMgc2hvdWxkbid0IGFkZCBhIGxpc3RlbmVyLlxuICAgIGlmICghb3BlbkNoZWNrIHx8ICFlbmFibGVkIHx8IHggIT0gbnVsbCB8fCB5ICE9IG51bGwpIHJldHVybjtcbiAgICBjb25zdCB3aW4gPSBnZXRXaW5kb3cocmVmcy5mbG9hdGluZy5jdXJyZW50KTtcbiAgICBmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmUoZXZlbnQpIHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGdldFRhcmdldChldmVudCk7XG4gICAgICBpZiAoIWNvbnRhaW5zKHJlZnMuZmxvYXRpbmcuY3VycmVudCwgdGFyZ2V0KSkge1xuICAgICAgICBzZXRSZWZlcmVuY2UoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgaGFuZGxlTW91c2VNb3ZlKTtcbiAgICAgICAgY2xlYW51cExpc3RlbmVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWRhdGFSZWYuY3VycmVudC5vcGVuRXZlbnQgfHwgaXNNb3VzZUJhc2VkRXZlbnQoZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudCkpIHtcbiAgICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBoYW5kbGVNb3VzZU1vdmUpO1xuICAgICAgY29uc3QgY2xlYW51cCA9ICgpID0+IHtcbiAgICAgICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGhhbmRsZU1vdXNlTW92ZSk7XG4gICAgICAgIGNsZWFudXBMaXN0ZW5lclJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH07XG4gICAgICBjbGVhbnVwTGlzdGVuZXJSZWYuY3VycmVudCA9IGNsZWFudXA7XG4gICAgICByZXR1cm4gY2xlYW51cDtcbiAgICB9XG4gICAgcmVmcy5zZXRQb3NpdGlvblJlZmVyZW5jZShyZWZzLmRvbVJlZmVyZW5jZS5jdXJyZW50KTtcbiAgfSwgW2RhdGFSZWYsIGVuYWJsZWQsIG9wZW5DaGVjaywgcmVmcywgc2V0UmVmZXJlbmNlLCB4LCB5XSk7XG5cbiAgLy8gYmlvbWUtaWdub3JlIGxpbnQvY29ycmVjdG5lc3MvdXNlRXhoYXVzdGl2ZURlcGVuZGVuY2llczogaW50ZW50aW9uYWxseSBzcGVjaWZ5aW5nIGByZWFjdGl2ZWBcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gYWRkTGlzdGVuZXIoKTtcbiAgfSwgW2FkZExpc3RlbmVyLCByZWFjdGl2ZV0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChlbmFibGVkICYmICFmbG9hdGluZykge1xuICAgICAgaW5pdGlhbFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgfVxuICB9LCBbZW5hYmxlZCwgZmxvYXRpbmddKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQgJiYgb3Blbikge1xuICAgICAgaW5pdGlhbFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICB9XG4gIH0sIFtlbmFibGVkLCBvcGVuXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoZW5hYmxlZCAmJiAoeCAhPSBudWxsIHx8IHkgIT0gbnVsbCkpIHtcbiAgICAgIGluaXRpYWxSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgc2V0UmVmZXJlbmNlKHgsIHkpO1xuICAgIH1cbiAgfSwgW2VuYWJsZWQsIHgsIHksIHNldFJlZmVyZW5jZV0pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSByZXR1cm4ge307XG4gICAgZnVuY3Rpb24gc2V0UG9pbnRlclR5cGVSZWYoX3JlZikge1xuICAgICAgbGV0IHtcbiAgICAgICAgcG9pbnRlclR5cGVcbiAgICAgIH0gPSBfcmVmO1xuICAgICAgc2V0UG9pbnRlclR5cGUocG9pbnRlclR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcmVmZXJlbmNlOiB7XG4gICAgICAgIG9uUG9pbnRlckRvd246IHNldFBvaW50ZXJUeXBlUmVmLFxuICAgICAgICBvblBvaW50ZXJFbnRlcjogc2V0UG9pbnRlclR5cGVSZWYsXG4gICAgICAgIG9uTW91c2VNb3ZlOiBoYW5kbGVSZWZlcmVuY2VFbnRlck9yTW92ZSxcbiAgICAgICAgb25Nb3VzZUVudGVyOiBoYW5kbGVSZWZlcmVuY2VFbnRlck9yTW92ZVxuICAgICAgfVxuICAgIH07XG4gIH0sIFtlbmFibGVkLCBoYW5kbGVSZWZlcmVuY2VFbnRlck9yTW92ZV0pO1xufVxuXG5jb25zdCBidWJibGVIYW5kbGVyS2V5cyA9IHtcbiAgcG9pbnRlcmRvd246ICdvblBvaW50ZXJEb3duJyxcbiAgbW91c2Vkb3duOiAnb25Nb3VzZURvd24nLFxuICBjbGljazogJ29uQ2xpY2snXG59O1xuY29uc3QgY2FwdHVyZUhhbmRsZXJLZXlzID0ge1xuICBwb2ludGVyZG93bjogJ29uUG9pbnRlckRvd25DYXB0dXJlJyxcbiAgbW91c2Vkb3duOiAnb25Nb3VzZURvd25DYXB0dXJlJyxcbiAgY2xpY2s6ICdvbkNsaWNrQ2FwdHVyZSdcbn07XG5jb25zdCBub3JtYWxpemVQcm9wID0gbm9ybWFsaXphYmxlID0+IHtcbiAgdmFyIF9ub3JtYWxpemFibGUkZXNjYXBlSywgX25vcm1hbGl6YWJsZSRvdXRzaWRlO1xuICByZXR1cm4ge1xuICAgIGVzY2FwZUtleTogdHlwZW9mIG5vcm1hbGl6YWJsZSA9PT0gJ2Jvb2xlYW4nID8gbm9ybWFsaXphYmxlIDogKF9ub3JtYWxpemFibGUkZXNjYXBlSyA9IG5vcm1hbGl6YWJsZSA9PSBudWxsID8gdm9pZCAwIDogbm9ybWFsaXphYmxlLmVzY2FwZUtleSkgIT0gbnVsbCA/IF9ub3JtYWxpemFibGUkZXNjYXBlSyA6IGZhbHNlLFxuICAgIG91dHNpZGVQcmVzczogdHlwZW9mIG5vcm1hbGl6YWJsZSA9PT0gJ2Jvb2xlYW4nID8gbm9ybWFsaXphYmxlIDogKF9ub3JtYWxpemFibGUkb3V0c2lkZSA9IG5vcm1hbGl6YWJsZSA9PSBudWxsID8gdm9pZCAwIDogbm9ybWFsaXphYmxlLm91dHNpZGVQcmVzcykgIT0gbnVsbCA/IF9ub3JtYWxpemFibGUkb3V0c2lkZSA6IHRydWVcbiAgfTtcbn07XG4vKipcbiAqIENsb3NlcyB0aGUgZmxvYXRpbmcgZWxlbWVudCB3aGVuIGEgZGlzbWlzc2FsIGlzIHJlcXVlc3RlZCDigJQgYnkgZGVmYXVsdCwgd2hlblxuICogdGhlIHVzZXIgcHJlc3NlcyB0aGUgYGVzY2FwZWAga2V5IG9yIG91dHNpZGUgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlRGlzbWlzc1xuICovXG5mdW5jdGlvbiB1c2VEaXNtaXNzKGNvbnRleHQsIHByb3BzKSB7XG4gIGlmIChwcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgcHJvcHMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgb3BlbixcbiAgICBvbk9wZW5DaGFuZ2UsXG4gICAgbm9kZUlkLFxuICAgIGVsZW1lbnRzOiB7XG4gICAgICByZWZlcmVuY2UsXG4gICAgICBkb21SZWZlcmVuY2UsXG4gICAgICBmbG9hdGluZ1xuICAgIH0sXG4gICAgZGF0YVJlZlxuICB9ID0gY29udGV4dDtcbiAgY29uc3Qge1xuICAgIGVuYWJsZWQgPSB0cnVlLFxuICAgIGVzY2FwZUtleSA9IHRydWUsXG4gICAgb3V0c2lkZVByZXNzOiB1bnN0YWJsZV9vdXRzaWRlUHJlc3MgPSB0cnVlLFxuICAgIG91dHNpZGVQcmVzc0V2ZW50ID0gJ3BvaW50ZXJkb3duJyxcbiAgICByZWZlcmVuY2VQcmVzcyA9IGZhbHNlLFxuICAgIHJlZmVyZW5jZVByZXNzRXZlbnQgPSAncG9pbnRlcmRvd24nLFxuICAgIGFuY2VzdG9yU2Nyb2xsID0gZmFsc2UsXG4gICAgYnViYmxlcyxcbiAgICBjYXB0dXJlXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgdHJlZSA9IHVzZUZsb2F0aW5nVHJlZSgpO1xuICBjb25zdCBvdXRzaWRlUHJlc3NGbiA9IHVzZUVmZmVjdEV2ZW50KHR5cGVvZiB1bnN0YWJsZV9vdXRzaWRlUHJlc3MgPT09ICdmdW5jdGlvbicgPyB1bnN0YWJsZV9vdXRzaWRlUHJlc3MgOiAoKSA9PiBmYWxzZSk7XG4gIGNvbnN0IG91dHNpZGVQcmVzcyA9IHR5cGVvZiB1bnN0YWJsZV9vdXRzaWRlUHJlc3MgPT09ICdmdW5jdGlvbicgPyBvdXRzaWRlUHJlc3NGbiA6IHVuc3RhYmxlX291dHNpZGVQcmVzcztcbiAgY29uc3QgaW5zaWRlUmVhY3RUcmVlUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgZW5kZWRPclN0YXJ0ZWRJbnNpZGVSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBjb25zdCB7XG4gICAgZXNjYXBlS2V5OiBlc2NhcGVLZXlCdWJibGVzLFxuICAgIG91dHNpZGVQcmVzczogb3V0c2lkZVByZXNzQnViYmxlc1xuICB9ID0gbm9ybWFsaXplUHJvcChidWJibGVzKTtcbiAgY29uc3Qge1xuICAgIGVzY2FwZUtleTogZXNjYXBlS2V5Q2FwdHVyZSxcbiAgICBvdXRzaWRlUHJlc3M6IG91dHNpZGVQcmVzc0NhcHR1cmVcbiAgfSA9IG5vcm1hbGl6ZVByb3AoY2FwdHVyZSk7XG4gIGNvbnN0IGNsb3NlT25Fc2NhcGVLZXlEb3duID0gdXNlRWZmZWN0RXZlbnQoZXZlbnQgPT4ge1xuICAgIGlmICghb3BlbiB8fCAhZW5hYmxlZCB8fCAhZXNjYXBlS2V5IHx8IGV2ZW50LmtleSAhPT0gJ0VzY2FwZScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0cmVlID8gZ2V0Q2hpbGRyZW4odHJlZS5ub2Rlc1JlZi5jdXJyZW50LCBub2RlSWQpIDogW107XG4gICAgaWYgKCFlc2NhcGVLZXlCdWJibGVzKSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIGxldCBzaG91bGREaXNtaXNzID0gdHJ1ZTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgdmFyIF9jaGlsZCRjb250ZXh0O1xuICAgICAgICAgIGlmICgoX2NoaWxkJGNvbnRleHQgPSBjaGlsZC5jb250ZXh0KSAhPSBudWxsICYmIF9jaGlsZCRjb250ZXh0Lm9wZW4gJiYgIWNoaWxkLmNvbnRleHQuZGF0YVJlZi5jdXJyZW50Ll9fZXNjYXBlS2V5QnViYmxlcykge1xuICAgICAgICAgICAgc2hvdWxkRGlzbWlzcyA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghc2hvdWxkRGlzbWlzcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBvbk9wZW5DaGFuZ2UoZmFsc2UsIGlzUmVhY3RFdmVudChldmVudCkgPyBldmVudC5uYXRpdmVFdmVudCA6IGV2ZW50LCAnZXNjYXBlLWtleScpO1xuICB9KTtcbiAgY29uc3QgY2xvc2VPbkVzY2FwZUtleURvd25DYXB0dXJlID0gdXNlRWZmZWN0RXZlbnQoZXZlbnQgPT4ge1xuICAgIHZhciBfZ2V0VGFyZ2V0MjtcbiAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIHZhciBfZ2V0VGFyZ2V0O1xuICAgICAgY2xvc2VPbkVzY2FwZUtleURvd24oZXZlbnQpO1xuICAgICAgKF9nZXRUYXJnZXQgPSBnZXRUYXJnZXQoZXZlbnQpKSA9PSBudWxsIHx8IF9nZXRUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIChfZ2V0VGFyZ2V0MiA9IGdldFRhcmdldChldmVudCkpID09IG51bGwgfHwgX2dldFRhcmdldDIuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGNhbGxiYWNrKTtcbiAgfSk7XG4gIGNvbnN0IGNsb3NlT25QcmVzc091dHNpZGUgPSB1c2VFZmZlY3RFdmVudChldmVudCA9PiB7XG4gICAgLy8gR2l2ZW4gZGV2ZWxvcGVycyBjYW4gc3RvcCB0aGUgcHJvcGFnYXRpb24gb2YgdGhlIHN5bnRoZXRpYyBldmVudCxcbiAgICAvLyB3ZSBjYW4gb25seSBiZSBjb25maWRlbnQgd2l0aCBhIHBvc2l0aXZlIHZhbHVlLlxuICAgIGNvbnN0IGluc2lkZVJlYWN0VHJlZSA9IGluc2lkZVJlYWN0VHJlZVJlZi5jdXJyZW50O1xuICAgIGluc2lkZVJlYWN0VHJlZVJlZi5jdXJyZW50ID0gZmFsc2U7XG5cbiAgICAvLyBXaGVuIGNsaWNrIG91dHNpZGUgaXMgbGF6eSAoYGNsaWNrYCBldmVudCksIGhhbmRsZSBkcmFnZ2luZy5cbiAgICAvLyBEb24ndCBjbG9zZSBpZjpcbiAgICAvLyAtIFRoZSBjbGljayBzdGFydGVkIGluc2lkZSB0aGUgZmxvYXRpbmcgZWxlbWVudC5cbiAgICAvLyAtIFRoZSBjbGljayBlbmRlZCBpbnNpZGUgdGhlIGZsb2F0aW5nIGVsZW1lbnQuXG4gICAgY29uc3QgZW5kZWRPclN0YXJ0ZWRJbnNpZGUgPSBlbmRlZE9yU3RhcnRlZEluc2lkZVJlZi5jdXJyZW50O1xuICAgIGVuZGVkT3JTdGFydGVkSW5zaWRlUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICBpZiAob3V0c2lkZVByZXNzRXZlbnQgPT09ICdjbGljaycgJiYgZW5kZWRPclN0YXJ0ZWRJbnNpZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGluc2lkZVJlYWN0VHJlZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG91dHNpZGVQcmVzcyA9PT0gJ2Z1bmN0aW9uJyAmJiAhb3V0c2lkZVByZXNzKGV2ZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXQgPSBnZXRUYXJnZXQoZXZlbnQpO1xuICAgIGNvbnN0IGluZXJ0U2VsZWN0b3IgPSBcIltcIiArIGNyZWF0ZUF0dHJpYnV0ZSgnaW5lcnQnKSArIFwiXVwiO1xuICAgIGNvbnN0IG1hcmtlcnMgPSBnZXREb2N1bWVudChmbG9hdGluZykucXVlcnlTZWxlY3RvckFsbChpbmVydFNlbGVjdG9yKTtcbiAgICBsZXQgdGFyZ2V0Um9vdEFuY2VzdG9yID0gaXNFbGVtZW50KHRhcmdldCkgPyB0YXJnZXQgOiBudWxsO1xuICAgIHdoaWxlICh0YXJnZXRSb290QW5jZXN0b3IgJiYgIWlzTGFzdFRyYXZlcnNhYmxlTm9kZSh0YXJnZXRSb290QW5jZXN0b3IpKSB7XG4gICAgICBjb25zdCBuZXh0UGFyZW50ID0gZ2V0UGFyZW50Tm9kZSh0YXJnZXRSb290QW5jZXN0b3IpO1xuICAgICAgaWYgKGlzTGFzdFRyYXZlcnNhYmxlTm9kZShuZXh0UGFyZW50KSB8fCAhaXNFbGVtZW50KG5leHRQYXJlbnQpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdGFyZ2V0Um9vdEFuY2VzdG9yID0gbmV4dFBhcmVudDtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiB0aGUgY2xpY2sgb2NjdXJyZWQgb24gYSB0aGlyZC1wYXJ0eSBlbGVtZW50IGluamVjdGVkIGFmdGVyIHRoZVxuICAgIC8vIGZsb2F0aW5nIGVsZW1lbnQgcmVuZGVyZWQuXG4gICAgaWYgKG1hcmtlcnMubGVuZ3RoICYmIGlzRWxlbWVudCh0YXJnZXQpICYmICFpc1Jvb3RFbGVtZW50KHRhcmdldCkgJiZcbiAgICAvLyBDbGlja2VkIG9uIGEgZGlyZWN0IGFuY2VzdG9yIChlLmcuIEZsb2F0aW5nT3ZlcmxheSkuXG4gICAgIWNvbnRhaW5zKHRhcmdldCwgZmxvYXRpbmcpICYmXG4gICAgLy8gSWYgdGhlIHRhcmdldCByb290IGVsZW1lbnQgY29udGFpbnMgbm9uZSBvZiB0aGUgbWFya2VycywgdGhlbiB0aGVcbiAgICAvLyBlbGVtZW50IHdhcyBpbmplY3RlZCBhZnRlciB0aGUgZmxvYXRpbmcgZWxlbWVudCByZW5kZXJlZC5cbiAgICBBcnJheS5mcm9tKG1hcmtlcnMpLmV2ZXJ5KG1hcmtlciA9PiAhY29udGFpbnModGFyZ2V0Um9vdEFuY2VzdG9yLCBtYXJrZXIpKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHRoZSBjbGljayBvY2N1cnJlZCBvbiB0aGUgc2Nyb2xsYmFyXG4gICAgaWYgKGlzSFRNTEVsZW1lbnQodGFyZ2V0KSAmJiBmbG9hdGluZykge1xuICAgICAgLy8gSW4gRmlyZWZveCwgYHRhcmdldC5zY3JvbGxXaWR0aCA+IHRhcmdldC5jbGllbnRXaWR0aGAgZm9yIGlubGluZVxuICAgICAgLy8gZWxlbWVudHMuXG4gICAgICBjb25zdCBjYW5TY3JvbGxYID0gdGFyZ2V0LmNsaWVudFdpZHRoID4gMCAmJiB0YXJnZXQuc2Nyb2xsV2lkdGggPiB0YXJnZXQuY2xpZW50V2lkdGg7XG4gICAgICBjb25zdCBjYW5TY3JvbGxZID0gdGFyZ2V0LmNsaWVudEhlaWdodCA+IDAgJiYgdGFyZ2V0LnNjcm9sbEhlaWdodCA+IHRhcmdldC5jbGllbnRIZWlnaHQ7XG4gICAgICBsZXQgeENvbmQgPSBjYW5TY3JvbGxZICYmIGV2ZW50Lm9mZnNldFggPiB0YXJnZXQuY2xpZW50V2lkdGg7XG5cbiAgICAgIC8vIEluIHNvbWUgYnJvd3NlcnMgaXQgaXMgcG9zc2libGUgdG8gY2hhbmdlIHRoZSA8Ym9keT4gKG9yIHdpbmRvdylcbiAgICAgIC8vIHNjcm9sbGJhciB0byB0aGUgbGVmdCBzaWRlLCBidXQgaXMgdmVyeSByYXJlIGFuZCBpcyBkaWZmaWN1bHQgdG9cbiAgICAgIC8vIGNoZWNrIGZvci4gUGx1cywgZm9yIG1vZGFsIGRpYWxvZ3Mgd2l0aCBiYWNrZHJvcHMsIGl0IGlzIG1vcmVcbiAgICAgIC8vIGltcG9ydGFudCB0aGF0IHRoZSBiYWNrZHJvcCBpcyBjaGVja2VkIGJ1dCBub3Qgc28gbXVjaCB0aGUgd2luZG93LlxuICAgICAgaWYgKGNhblNjcm9sbFkpIHtcbiAgICAgICAgY29uc3QgaXNSVEwgPSBnZXRDb21wdXRlZFN0eWxlKHRhcmdldCkuZGlyZWN0aW9uID09PSAncnRsJztcbiAgICAgICAgaWYgKGlzUlRMKSB7XG4gICAgICAgICAgeENvbmQgPSBldmVudC5vZmZzZXRYIDw9IHRhcmdldC5vZmZzZXRXaWR0aCAtIHRhcmdldC5jbGllbnRXaWR0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHhDb25kIHx8IGNhblNjcm9sbFggJiYgZXZlbnQub2Zmc2V0WSA+IHRhcmdldC5jbGllbnRIZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0YXJnZXRJc0luc2lkZUNoaWxkcmVuID0gdHJlZSAmJiBnZXRDaGlsZHJlbih0cmVlLm5vZGVzUmVmLmN1cnJlbnQsIG5vZGVJZCkuc29tZShub2RlID0+IHtcbiAgICAgIHZhciBfbm9kZSRjb250ZXh0O1xuICAgICAgcmV0dXJuIGlzRXZlbnRUYXJnZXRXaXRoaW4oZXZlbnQsIChfbm9kZSRjb250ZXh0ID0gbm9kZS5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkY29udGV4dC5lbGVtZW50cy5mbG9hdGluZyk7XG4gICAgfSk7XG4gICAgaWYgKGlzRXZlbnRUYXJnZXRXaXRoaW4oZXZlbnQsIGZsb2F0aW5nKSB8fCBpc0V2ZW50VGFyZ2V0V2l0aGluKGV2ZW50LCBkb21SZWZlcmVuY2UpIHx8IHRhcmdldElzSW5zaWRlQ2hpbGRyZW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0cmVlID8gZ2V0Q2hpbGRyZW4odHJlZS5ub2Rlc1JlZi5jdXJyZW50LCBub2RlSWQpIDogW107XG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIGxldCBzaG91bGREaXNtaXNzID0gdHJ1ZTtcbiAgICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICB2YXIgX2NoaWxkJGNvbnRleHQyO1xuICAgICAgICBpZiAoKF9jaGlsZCRjb250ZXh0MiA9IGNoaWxkLmNvbnRleHQpICE9IG51bGwgJiYgX2NoaWxkJGNvbnRleHQyLm9wZW4gJiYgIWNoaWxkLmNvbnRleHQuZGF0YVJlZi5jdXJyZW50Ll9fb3V0c2lkZVByZXNzQnViYmxlcykge1xuICAgICAgICAgIHNob3VsZERpc21pc3MgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKCFzaG91bGREaXNtaXNzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudCwgJ291dHNpZGUtcHJlc3MnKTtcbiAgfSk7XG4gIGNvbnN0IGNsb3NlT25QcmVzc091dHNpZGVDYXB0dXJlID0gdXNlRWZmZWN0RXZlbnQoZXZlbnQgPT4ge1xuICAgIHZhciBfZ2V0VGFyZ2V0NDtcbiAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIHZhciBfZ2V0VGFyZ2V0MztcbiAgICAgIGNsb3NlT25QcmVzc091dHNpZGUoZXZlbnQpO1xuICAgICAgKF9nZXRUYXJnZXQzID0gZ2V0VGFyZ2V0KGV2ZW50KSkgPT0gbnVsbCB8fCBfZ2V0VGFyZ2V0My5yZW1vdmVFdmVudExpc3RlbmVyKG91dHNpZGVQcmVzc0V2ZW50LCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICAoX2dldFRhcmdldDQgPSBnZXRUYXJnZXQoZXZlbnQpKSA9PSBudWxsIHx8IF9nZXRUYXJnZXQ0LmFkZEV2ZW50TGlzdGVuZXIob3V0c2lkZVByZXNzRXZlbnQsIGNhbGxiYWNrKTtcbiAgfSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFvcGVuIHx8ICFlbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRhdGFSZWYuY3VycmVudC5fX2VzY2FwZUtleUJ1YmJsZXMgPSBlc2NhcGVLZXlCdWJibGVzO1xuICAgIGRhdGFSZWYuY3VycmVudC5fX291dHNpZGVQcmVzc0J1YmJsZXMgPSBvdXRzaWRlUHJlc3NCdWJibGVzO1xuICAgIGZ1bmN0aW9uIG9uU2Nyb2xsKGV2ZW50KSB7XG4gICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50LCAnYW5jZXN0b3Itc2Nyb2xsJyk7XG4gICAgfVxuICAgIGNvbnN0IGRvYyA9IGdldERvY3VtZW50KGZsb2F0aW5nKTtcbiAgICBlc2NhcGVLZXkgJiYgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBlc2NhcGVLZXlDYXB0dXJlID8gY2xvc2VPbkVzY2FwZUtleURvd25DYXB0dXJlIDogY2xvc2VPbkVzY2FwZUtleURvd24sIGVzY2FwZUtleUNhcHR1cmUpO1xuICAgIG91dHNpZGVQcmVzcyAmJiBkb2MuYWRkRXZlbnRMaXN0ZW5lcihvdXRzaWRlUHJlc3NFdmVudCwgb3V0c2lkZVByZXNzQ2FwdHVyZSA/IGNsb3NlT25QcmVzc091dHNpZGVDYXB0dXJlIDogY2xvc2VPblByZXNzT3V0c2lkZSwgb3V0c2lkZVByZXNzQ2FwdHVyZSk7XG4gICAgbGV0IGFuY2VzdG9ycyA9IFtdO1xuICAgIGlmIChhbmNlc3RvclNjcm9sbCkge1xuICAgICAgaWYgKGlzRWxlbWVudChkb21SZWZlcmVuY2UpKSB7XG4gICAgICAgIGFuY2VzdG9ycyA9IGdldE92ZXJmbG93QW5jZXN0b3JzKGRvbVJlZmVyZW5jZSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNFbGVtZW50KGZsb2F0aW5nKSkge1xuICAgICAgICBhbmNlc3RvcnMgPSBhbmNlc3RvcnMuY29uY2F0KGdldE92ZXJmbG93QW5jZXN0b3JzKGZsb2F0aW5nKSk7XG4gICAgICB9XG4gICAgICBpZiAoIWlzRWxlbWVudChyZWZlcmVuY2UpICYmIHJlZmVyZW5jZSAmJiByZWZlcmVuY2UuY29udGV4dEVsZW1lbnQpIHtcbiAgICAgICAgYW5jZXN0b3JzID0gYW5jZXN0b3JzLmNvbmNhdChnZXRPdmVyZmxvd0FuY2VzdG9ycyhyZWZlcmVuY2UuY29udGV4dEVsZW1lbnQpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZ25vcmUgdGhlIHZpc3VhbCB2aWV3cG9ydCBmb3Igc2Nyb2xsaW5nIGRpc21pc3NhbCAoYWxsb3cgcGluY2gtem9vbSlcbiAgICBhbmNlc3RvcnMgPSBhbmNlc3RvcnMuZmlsdGVyKGFuY2VzdG9yID0+IHtcbiAgICAgIHZhciBfZG9jJGRlZmF1bHRWaWV3O1xuICAgICAgcmV0dXJuIGFuY2VzdG9yICE9PSAoKF9kb2MkZGVmYXVsdFZpZXcgPSBkb2MuZGVmYXVsdFZpZXcpID09IG51bGwgPyB2b2lkIDAgOiBfZG9jJGRlZmF1bHRWaWV3LnZpc3VhbFZpZXdwb3J0KTtcbiAgICB9KTtcbiAgICBhbmNlc3RvcnMuZm9yRWFjaChhbmNlc3RvciA9PiB7XG4gICAgICBhbmNlc3Rvci5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBvblNjcm9sbCwge1xuICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZXNjYXBlS2V5ICYmIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZXNjYXBlS2V5Q2FwdHVyZSA/IGNsb3NlT25Fc2NhcGVLZXlEb3duQ2FwdHVyZSA6IGNsb3NlT25Fc2NhcGVLZXlEb3duLCBlc2NhcGVLZXlDYXB0dXJlKTtcbiAgICAgIG91dHNpZGVQcmVzcyAmJiBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcihvdXRzaWRlUHJlc3NFdmVudCwgb3V0c2lkZVByZXNzQ2FwdHVyZSA/IGNsb3NlT25QcmVzc091dHNpZGVDYXB0dXJlIDogY2xvc2VPblByZXNzT3V0c2lkZSwgb3V0c2lkZVByZXNzQ2FwdHVyZSk7XG4gICAgICBhbmNlc3RvcnMuZm9yRWFjaChhbmNlc3RvciA9PiB7XG4gICAgICAgIGFuY2VzdG9yLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIG9uU2Nyb2xsKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH0sIFtkYXRhUmVmLCBmbG9hdGluZywgZG9tUmVmZXJlbmNlLCByZWZlcmVuY2UsIGVzY2FwZUtleSwgb3V0c2lkZVByZXNzLCBvdXRzaWRlUHJlc3NFdmVudCwgb3Blbiwgb25PcGVuQ2hhbmdlLCBhbmNlc3RvclNjcm9sbCwgZW5hYmxlZCwgZXNjYXBlS2V5QnViYmxlcywgb3V0c2lkZVByZXNzQnViYmxlcywgY2xvc2VPbkVzY2FwZUtleURvd24sIGVzY2FwZUtleUNhcHR1cmUsIGNsb3NlT25Fc2NhcGVLZXlEb3duQ2FwdHVyZSwgY2xvc2VPblByZXNzT3V0c2lkZSwgb3V0c2lkZVByZXNzQ2FwdHVyZSwgY2xvc2VPblByZXNzT3V0c2lkZUNhcHR1cmVdKTtcblxuICAvLyBiaW9tZS1pZ25vcmUgbGludC9jb3JyZWN0bmVzcy91c2VFeGhhdXN0aXZlRGVwZW5kZW5jaWVzOiBpbnRlbnRpb25hbFxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGluc2lkZVJlYWN0VHJlZVJlZi5jdXJyZW50ID0gZmFsc2U7XG4gIH0sIFtvdXRzaWRlUHJlc3MsIG91dHNpZGVQcmVzc0V2ZW50XSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZmVyZW5jZToge1xuICAgICAgICBvbktleURvd246IGNsb3NlT25Fc2NhcGVLZXlEb3duLFxuICAgICAgICBbYnViYmxlSGFuZGxlcktleXNbcmVmZXJlbmNlUHJlc3NFdmVudF1dOiBldmVudCA9PiB7XG4gICAgICAgICAgaWYgKHJlZmVyZW5jZVByZXNzKSB7XG4gICAgICAgICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50Lm5hdGl2ZUV2ZW50LCAncmVmZXJlbmNlLXByZXNzJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZmxvYXRpbmc6IHtcbiAgICAgICAgb25LZXlEb3duOiBjbG9zZU9uRXNjYXBlS2V5RG93bixcbiAgICAgICAgb25Nb3VzZURvd24oKSB7XG4gICAgICAgICAgZW5kZWRPclN0YXJ0ZWRJbnNpZGVSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIG9uTW91c2VVcCgpIHtcbiAgICAgICAgICBlbmRlZE9yU3RhcnRlZEluc2lkZVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgW2NhcHR1cmVIYW5kbGVyS2V5c1tvdXRzaWRlUHJlc3NFdmVudF1dOiAoKSA9PiB7XG4gICAgICAgICAgaW5zaWRlUmVhY3RUcmVlUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2VuYWJsZWQsIHJlZmVyZW5jZVByZXNzLCBvdXRzaWRlUHJlc3NFdmVudCwgcmVmZXJlbmNlUHJlc3NFdmVudCwgb25PcGVuQ2hhbmdlLCBjbG9zZU9uRXNjYXBlS2V5RG93bl0pO1xufVxuXG5sZXQgZGV2TWVzc2FnZVNldDtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgZGV2TWVzc2FnZVNldCA9IC8qI19fUFVSRV9fKi9uZXcgU2V0KCk7XG59XG5cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0byBwb3NpdGlvbiBhIGZsb2F0aW5nIGVsZW1lbnQgYW5kIGNvbnRleHQgdG8gYWRkIGludGVyYWN0aW9ucy5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VGbG9hdGluZ1xuICovXG5mdW5jdGlvbiB1c2VGbG9hdGluZyhvcHRpb25zKSB7XG4gIHZhciBfb3B0aW9ucyRlbGVtZW50czI7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIG9wZW4gPSBmYWxzZSxcbiAgICBvbk9wZW5DaGFuZ2U6IHVuc3RhYmxlX29uT3BlbkNoYW5nZSxcbiAgICBub2RlSWRcbiAgfSA9IG9wdGlvbnM7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB2YXIgX29wdGlvbnMkZWxlbWVudHM7XG4gICAgY29uc3QgZXJyID0gJ0Zsb2F0aW5nIFVJOiBDYW5ub3QgcGFzcyBhIHZpcnR1YWwgZWxlbWVudCB0byB0aGUgJyArICdgZWxlbWVudHMucmVmZXJlbmNlYCBvcHRpb24sIGFzIGl0IG11c3QgYmUgYSByZWFsIERPTSBlbGVtZW50LiAnICsgJ1VzZSBgcmVmcy5zZXRQb3NpdGlvblJlZmVyZW5jZWAgaW5zdGVhZC4nO1xuICAgIGlmICgoX29wdGlvbnMkZWxlbWVudHMgPSBvcHRpb25zLmVsZW1lbnRzKSAhPSBudWxsICYmIF9vcHRpb25zJGVsZW1lbnRzLnJlZmVyZW5jZSAmJiAhaXNFbGVtZW50KG9wdGlvbnMuZWxlbWVudHMucmVmZXJlbmNlKSkge1xuICAgICAgdmFyIF9kZXZNZXNzYWdlU2V0O1xuICAgICAgaWYgKCEoKF9kZXZNZXNzYWdlU2V0ID0gZGV2TWVzc2FnZVNldCkgIT0gbnVsbCAmJiBfZGV2TWVzc2FnZVNldC5oYXMoZXJyKSkpIHtcbiAgICAgICAgdmFyIF9kZXZNZXNzYWdlU2V0MjtcbiAgICAgICAgKF9kZXZNZXNzYWdlU2V0MiA9IGRldk1lc3NhZ2VTZXQpID09IG51bGwgfHwgX2Rldk1lc3NhZ2VTZXQyLmFkZChlcnIpO1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IFtfZG9tUmVmZXJlbmNlLCBzZXREb21SZWZlcmVuY2VdID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IGRvbVJlZmVyZW5jZSA9ICgoX29wdGlvbnMkZWxlbWVudHMyID0gb3B0aW9ucy5lbGVtZW50cykgPT0gbnVsbCA/IHZvaWQgMCA6IF9vcHRpb25zJGVsZW1lbnRzMi5yZWZlcmVuY2UpIHx8IF9kb21SZWZlcmVuY2U7XG4gIGNvbnN0IHBvc2l0aW9uID0gdXNlRmxvYXRpbmckMShvcHRpb25zKTtcbiAgY29uc3QgdHJlZSA9IHVzZUZsb2F0aW5nVHJlZSgpO1xuICBjb25zdCBuZXN0ZWQgPSB1c2VGbG9hdGluZ1BhcmVudE5vZGVJZCgpICE9IG51bGw7XG4gIGNvbnN0IG9uT3BlbkNoYW5nZSA9IHVzZUVmZmVjdEV2ZW50KChvcGVuLCBldmVudCwgcmVhc29uKSA9PiB7XG4gICAgaWYgKG9wZW4pIHtcbiAgICAgIGRhdGFSZWYuY3VycmVudC5vcGVuRXZlbnQgPSBldmVudDtcbiAgICB9XG4gICAgZXZlbnRzLmVtaXQoJ29wZW5jaGFuZ2UnLCB7XG4gICAgICBvcGVuLFxuICAgICAgZXZlbnQsXG4gICAgICByZWFzb24sXG4gICAgICBuZXN0ZWRcbiAgICB9KTtcbiAgICB1bnN0YWJsZV9vbk9wZW5DaGFuZ2UgPT0gbnVsbCB8fCB1bnN0YWJsZV9vbk9wZW5DaGFuZ2Uob3BlbiwgZXZlbnQsIHJlYXNvbik7XG4gIH0pO1xuICBjb25zdCBkb21SZWZlcmVuY2VSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGRhdGFSZWYgPSBSZWFjdC51c2VSZWYoe30pO1xuICBjb25zdCBldmVudHMgPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBjcmVhdGVQdWJTdWIoKSlbMF07XG4gIGNvbnN0IGZsb2F0aW5nSWQgPSB1c2VJZCgpO1xuICBjb25zdCBzZXRQb3NpdGlvblJlZmVyZW5jZSA9IFJlYWN0LnVzZUNhbGxiYWNrKG5vZGUgPT4ge1xuICAgIGNvbnN0IHBvc2l0aW9uUmVmZXJlbmNlID0gaXNFbGVtZW50KG5vZGUpID8ge1xuICAgICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0OiAoKSA9PiBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgY29udGV4dEVsZW1lbnQ6IG5vZGVcbiAgICB9IDogbm9kZTtcbiAgICBwb3NpdGlvbi5yZWZzLnNldFJlZmVyZW5jZShwb3NpdGlvblJlZmVyZW5jZSk7XG4gIH0sIFtwb3NpdGlvbi5yZWZzXSk7XG4gIGNvbnN0IHNldFJlZmVyZW5jZSA9IFJlYWN0LnVzZUNhbGxiYWNrKG5vZGUgPT4ge1xuICAgIGlmIChpc0VsZW1lbnQobm9kZSkgfHwgbm9kZSA9PT0gbnVsbCkge1xuICAgICAgZG9tUmVmZXJlbmNlUmVmLmN1cnJlbnQgPSBub2RlO1xuICAgICAgc2V0RG9tUmVmZXJlbmNlKG5vZGUpO1xuICAgIH1cblxuICAgIC8vIEJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IGZvciBwYXNzaW5nIGEgdmlydHVhbCBlbGVtZW50IHRvIGByZWZlcmVuY2VgXG4gICAgLy8gYWZ0ZXIgaXQgaGFzIHNldCB0aGUgRE9NIHJlZmVyZW5jZS5cbiAgICBpZiAoaXNFbGVtZW50KHBvc2l0aW9uLnJlZnMucmVmZXJlbmNlLmN1cnJlbnQpIHx8IHBvc2l0aW9uLnJlZnMucmVmZXJlbmNlLmN1cnJlbnQgPT09IG51bGwgfHxcbiAgICAvLyBEb24ndCBhbGxvdyBzZXR0aW5nIHZpcnR1YWwgZWxlbWVudHMgdXNpbmcgdGhlIG9sZCB0ZWNobmlxdWUgYmFjayB0b1xuICAgIC8vIGBudWxsYCB0byBzdXBwb3J0IGBwb3NpdGlvblJlZmVyZW5jZWAgKyBhbiB1bnN0YWJsZSBgcmVmZXJlbmNlYFxuICAgIC8vIGNhbGxiYWNrIHJlZi5cbiAgICBub2RlICE9PSBudWxsICYmICFpc0VsZW1lbnQobm9kZSkpIHtcbiAgICAgIHBvc2l0aW9uLnJlZnMuc2V0UmVmZXJlbmNlKG5vZGUpO1xuICAgIH1cbiAgfSwgW3Bvc2l0aW9uLnJlZnNdKTtcbiAgY29uc3QgcmVmcyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICAuLi5wb3NpdGlvbi5yZWZzLFxuICAgIHNldFJlZmVyZW5jZSxcbiAgICBzZXRQb3NpdGlvblJlZmVyZW5jZSxcbiAgICBkb21SZWZlcmVuY2U6IGRvbVJlZmVyZW5jZVJlZlxuICB9KSwgW3Bvc2l0aW9uLnJlZnMsIHNldFJlZmVyZW5jZSwgc2V0UG9zaXRpb25SZWZlcmVuY2VdKTtcbiAgY29uc3QgZWxlbWVudHMgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgLi4ucG9zaXRpb24uZWxlbWVudHMsXG4gICAgZG9tUmVmZXJlbmNlOiBkb21SZWZlcmVuY2VcbiAgfSksIFtwb3NpdGlvbi5lbGVtZW50cywgZG9tUmVmZXJlbmNlXSk7XG4gIGNvbnN0IGNvbnRleHQgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgLi4ucG9zaXRpb24sXG4gICAgcmVmcyxcbiAgICBlbGVtZW50cyxcbiAgICBkYXRhUmVmLFxuICAgIG5vZGVJZCxcbiAgICBmbG9hdGluZ0lkLFxuICAgIGV2ZW50cyxcbiAgICBvcGVuLFxuICAgIG9uT3BlbkNoYW5nZVxuICB9KSwgW3Bvc2l0aW9uLCBub2RlSWQsIGZsb2F0aW5nSWQsIGV2ZW50cywgb3Blbiwgb25PcGVuQ2hhbmdlLCByZWZzLCBlbGVtZW50c10pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgY29uc3Qgbm9kZSA9IHRyZWUgPT0gbnVsbCA/IHZvaWQgMCA6IHRyZWUubm9kZXNSZWYuY3VycmVudC5maW5kKG5vZGUgPT4gbm9kZS5pZCA9PT0gbm9kZUlkKTtcbiAgICBpZiAobm9kZSkge1xuICAgICAgbm9kZS5jb250ZXh0ID0gY29udGV4dDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIC4uLnBvc2l0aW9uLFxuICAgIGNvbnRleHQsXG4gICAgcmVmcyxcbiAgICBlbGVtZW50c1xuICB9KSwgW3Bvc2l0aW9uLCByZWZzLCBlbGVtZW50cywgY29udGV4dF0pO1xufVxuXG4vKipcbiAqIE9wZW5zIHRoZSBmbG9hdGluZyBlbGVtZW50IHdoaWxlIHRoZSByZWZlcmVuY2UgZWxlbWVudCBoYXMgZm9jdXMsIGxpa2UgQ1NTXG4gKiBgOmZvY3VzYC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VGb2N1c1xuICovXG5mdW5jdGlvbiB1c2VGb2N1cyhjb250ZXh0LCBwcm9wcykge1xuICBpZiAocHJvcHMgPT09IHZvaWQgMCkge1xuICAgIHByb3BzID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIG9wZW4sXG4gICAgb25PcGVuQ2hhbmdlLFxuICAgIGV2ZW50cyxcbiAgICByZWZzLFxuICAgIGVsZW1lbnRzOiB7XG4gICAgICBkb21SZWZlcmVuY2VcbiAgICB9XG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCB7XG4gICAgZW5hYmxlZCA9IHRydWUsXG4gICAgdmlzaWJsZU9ubHkgPSB0cnVlXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgYmxvY2tGb2N1c1JlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IHRpbWVvdXRSZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgY29uc3Qga2V5Ym9hcmRNb2RhbGl0eVJlZiA9IFJlYWN0LnVzZVJlZih0cnVlKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgd2luID0gZ2V0V2luZG93KGRvbVJlZmVyZW5jZSk7XG5cbiAgICAvLyBJZiB0aGUgcmVmZXJlbmNlIHdhcyBmb2N1c2VkIGFuZCB0aGUgdXNlciBsZWZ0IHRoZSB0YWIvd2luZG93LCBhbmQgdGhlXG4gICAgLy8gZmxvYXRpbmcgZWxlbWVudCB3YXMgbm90IG9wZW4sIHRoZSBmb2N1cyBzaG91bGQgYmUgYmxvY2tlZCB3aGVuIHRoZXlcbiAgICAvLyByZXR1cm4gdG8gdGhlIHRhYi93aW5kb3cuXG4gICAgZnVuY3Rpb24gb25CbHVyKCkge1xuICAgICAgaWYgKCFvcGVuICYmIGlzSFRNTEVsZW1lbnQoZG9tUmVmZXJlbmNlKSAmJiBkb21SZWZlcmVuY2UgPT09IGFjdGl2ZUVsZW1lbnQoZ2V0RG9jdW1lbnQoZG9tUmVmZXJlbmNlKSkpIHtcbiAgICAgICAgYmxvY2tGb2N1c1JlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25LZXlEb3duKCkge1xuICAgICAga2V5Ym9hcmRNb2RhbGl0eVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICB9XG4gICAgd2luLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBvbkJsdXIpO1xuICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgb25LZXlEb3duLCB0cnVlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCBvbkJsdXIpO1xuICAgICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBvbktleURvd24sIHRydWUpO1xuICAgIH07XG4gIH0sIFtkb21SZWZlcmVuY2UsIG9wZW4sIGVuYWJsZWRdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25PcGVuQ2hhbmdlKF9yZWYpIHtcbiAgICAgIGxldCB7XG4gICAgICAgIHJlYXNvblxuICAgICAgfSA9IF9yZWY7XG4gICAgICBpZiAocmVhc29uID09PSAncmVmZXJlbmNlLXByZXNzJyB8fCByZWFzb24gPT09ICdlc2NhcGUta2V5Jykge1xuICAgICAgICBibG9ja0ZvY3VzUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBldmVudHMub24oJ29wZW5jaGFuZ2UnLCBvbk9wZW5DaGFuZ2UpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBldmVudHMub2ZmKCdvcGVuY2hhbmdlJywgb25PcGVuQ2hhbmdlKTtcbiAgICB9O1xuICB9LCBbZXZlbnRzLCBlbmFibGVkXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcmVmZXJlbmNlOiB7XG4gICAgICAgIG9uUG9pbnRlckRvd24oZXZlbnQpIHtcbiAgICAgICAgICBpZiAoaXNWaXJ0dWFsUG9pbnRlckV2ZW50KGV2ZW50Lm5hdGl2ZUV2ZW50KSkgcmV0dXJuO1xuICAgICAgICAgIGtleWJvYXJkTW9kYWxpdHlSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBvbk1vdXNlTGVhdmUoKSB7XG4gICAgICAgICAgYmxvY2tGb2N1c1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIG9uRm9jdXMoZXZlbnQpIHtcbiAgICAgICAgICBpZiAoYmxvY2tGb2N1c1JlZi5jdXJyZW50KSByZXR1cm47XG4gICAgICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0VGFyZ2V0KGV2ZW50Lm5hdGl2ZUV2ZW50KTtcbiAgICAgICAgICBpZiAodmlzaWJsZU9ubHkgJiYgaXNFbGVtZW50KHRhcmdldCkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIC8vIE1hYyBTYWZhcmkgdW5yZWxpYWJseSBtYXRjaGVzIGA6Zm9jdXMtdmlzaWJsZWAgb24gdGhlIHJlZmVyZW5jZVxuICAgICAgICAgICAgICAvLyBpZiBmb2N1cyB3YXMgb3V0c2lkZSB0aGUgcGFnZSBpbml0aWFsbHkgLSB1c2UgdGhlIGZhbGxiYWNrXG4gICAgICAgICAgICAgIC8vIGluc3RlYWQuXG4gICAgICAgICAgICAgIGlmIChpc1NhZmFyaSgpICYmIGlzTWFjKCkpIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICAgIGlmICghdGFyZ2V0Lm1hdGNoZXMoJzpmb2N1cy12aXNpYmxlJykpIHJldHVybjtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgLy8gT2xkIGJyb3dzZXJzIHdpbGwgdGhyb3cgYW4gZXJyb3Igd2hlbiB1c2luZyBgOmZvY3VzLXZpc2libGVgLlxuICAgICAgICAgICAgICBpZiAoIWtleWJvYXJkTW9kYWxpdHlSZWYuY3VycmVudCAmJiAhaXNUeXBlYWJsZUVsZW1lbnQodGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBvbk9wZW5DaGFuZ2UodHJ1ZSwgZXZlbnQubmF0aXZlRXZlbnQsICdmb2N1cycpO1xuICAgICAgICB9LFxuICAgICAgICBvbkJsdXIoZXZlbnQpIHtcbiAgICAgICAgICBibG9ja0ZvY3VzUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICBjb25zdCByZWxhdGVkVGFyZ2V0ID0gZXZlbnQucmVsYXRlZFRhcmdldDtcblxuICAgICAgICAgIC8vIEhpdCB0aGUgbm9uLW1vZGFsIGZvY3VzIG1hbmFnZW1lbnQgcG9ydGFsIGd1YXJkLiBGb2N1cyB3aWxsIGJlXG4gICAgICAgICAgLy8gbW92ZWQgaW50byB0aGUgZmxvYXRpbmcgZWxlbWVudCBpbW1lZGlhdGVseSBhZnRlci5cbiAgICAgICAgICBjb25zdCBtb3ZlZFRvRm9jdXNHdWFyZCA9IGlzRWxlbWVudChyZWxhdGVkVGFyZ2V0KSAmJiByZWxhdGVkVGFyZ2V0Lmhhc0F0dHJpYnV0ZShjcmVhdGVBdHRyaWJ1dGUoJ2ZvY3VzLWd1YXJkJykpICYmIHJlbGF0ZWRUYXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLXR5cGUnKSA9PT0gJ291dHNpZGUnO1xuXG4gICAgICAgICAgLy8gV2FpdCBmb3IgdGhlIHdpbmRvdyBibHVyIGxpc3RlbmVyIHRvIGZpcmUuXG4gICAgICAgICAgdGltZW91dFJlZi5jdXJyZW50ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYWN0aXZlRWwgPSBhY3RpdmVFbGVtZW50KGRvbVJlZmVyZW5jZSA/IGRvbVJlZmVyZW5jZS5vd25lckRvY3VtZW50IDogZG9jdW1lbnQpO1xuXG4gICAgICAgICAgICAvLyBGb2N1cyBsZWZ0IHRoZSBwYWdlLCBrZWVwIGl0IG9wZW4uXG4gICAgICAgICAgICBpZiAoIXJlbGF0ZWRUYXJnZXQgJiYgYWN0aXZlRWwgPT09IGRvbVJlZmVyZW5jZSkgcmV0dXJuO1xuXG4gICAgICAgICAgICAvLyBXaGVuIGZvY3VzaW5nIHRoZSByZWZlcmVuY2UgZWxlbWVudCAoZS5nLiByZWd1bGFyIGNsaWNrKSwgdGhlblxuICAgICAgICAgICAgLy8gY2xpY2tpbmcgaW50byB0aGUgZmxvYXRpbmcgZWxlbWVudCwgcHJldmVudCBpdCBmcm9tIGhpZGluZy5cbiAgICAgICAgICAgIC8vIE5vdGU6IGl0IG11c3QgYmUgZm9jdXNhYmxlLCBlLmcuIGB0YWJpbmRleD1cIi0xXCJgLlxuICAgICAgICAgICAgLy8gV2UgY2FuIG5vdCByZWx5IG9uIHJlbGF0ZWRUYXJnZXQgdG8gcG9pbnQgdG8gdGhlIGNvcnJlY3QgZWxlbWVudFxuICAgICAgICAgICAgLy8gYXMgaXQgd2lsbCBvbmx5IHBvaW50IHRvIHRoZSBzaGFkb3cgaG9zdCBvZiB0aGUgbmV3bHkgZm9jdXNlZCBlbGVtZW50XG4gICAgICAgICAgICAvLyBhbmQgbm90IHRoZSBlbGVtZW50IHRoYXQgYWN0dWFsbHkgaGFzIHJlY2VpdmVkIGZvY3VzIGlmIGl0IGlzIGxvY2F0ZWRcbiAgICAgICAgICAgIC8vIGluc2lkZSBhIHNoYWRvdyByb290LlxuICAgICAgICAgICAgaWYgKGNvbnRhaW5zKHJlZnMuZmxvYXRpbmcuY3VycmVudCwgYWN0aXZlRWwpIHx8IGNvbnRhaW5zKGRvbVJlZmVyZW5jZSwgYWN0aXZlRWwpIHx8IG1vdmVkVG9Gb2N1c0d1YXJkKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uT3BlbkNoYW5nZShmYWxzZSwgZXZlbnQubmF0aXZlRXZlbnQsICdmb2N1cycpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2VuYWJsZWQsIHZpc2libGVPbmx5LCBkb21SZWZlcmVuY2UsIHJlZnMsIG9uT3BlbkNoYW5nZV0pO1xufVxuXG5jb25zdCBBQ1RJVkVfS0VZID0gJ2FjdGl2ZSc7XG5jb25zdCBTRUxFQ1RFRF9LRVkgPSAnc2VsZWN0ZWQnO1xuZnVuY3Rpb24gbWVyZ2VQcm9wcyh1c2VyUHJvcHMsIHByb3BzTGlzdCwgZWxlbWVudEtleSkge1xuICBjb25zdCBtYXAgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IGlzSXRlbSA9IGVsZW1lbnRLZXkgPT09ICdpdGVtJztcbiAgbGV0IGRvbVVzZXJQcm9wcyA9IHVzZXJQcm9wcztcbiAgaWYgKGlzSXRlbSAmJiB1c2VyUHJvcHMpIHtcbiAgICBjb25zdCB7XG4gICAgICBbQUNUSVZFX0tFWV06IF8sXG4gICAgICBbU0VMRUNURURfS0VZXTogX18sXG4gICAgICAuLi52YWxpZFByb3BzXG4gICAgfSA9IHVzZXJQcm9wcztcbiAgICBkb21Vc2VyUHJvcHMgPSB2YWxpZFByb3BzO1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4uKGVsZW1lbnRLZXkgPT09ICdmbG9hdGluZycgJiYge1xuICAgICAgdGFiSW5kZXg6IC0xXG4gICAgfSksXG4gICAgLi4uZG9tVXNlclByb3BzLFxuICAgIC4uLnByb3BzTGlzdC5tYXAodmFsdWUgPT4ge1xuICAgICAgY29uc3QgcHJvcHNPckdldFByb3BzID0gdmFsdWUgPyB2YWx1ZVtlbGVtZW50S2V5XSA6IG51bGw7XG4gICAgICBpZiAodHlwZW9mIHByb3BzT3JHZXRQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdXNlclByb3BzID8gcHJvcHNPckdldFByb3BzKHVzZXJQcm9wcykgOiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb3BzT3JHZXRQcm9wcztcbiAgICB9KS5jb25jYXQodXNlclByb3BzKS5yZWR1Y2UoKGFjYywgcHJvcHMpID0+IHtcbiAgICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH1cbiAgICAgIE9iamVjdC5lbnRyaWVzKHByb3BzKS5mb3JFYWNoKF9yZWYgPT4ge1xuICAgICAgICBsZXQgW2tleSwgdmFsdWVdID0gX3JlZjtcbiAgICAgICAgaWYgKGlzSXRlbSAmJiBbQUNUSVZFX0tFWSwgU0VMRUNURURfS0VZXS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkuaW5kZXhPZignb24nKSA9PT0gMCkge1xuICAgICAgICAgIGlmICghbWFwLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICBtYXAuc2V0KGtleSwgW10pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgX21hcCRnZXQ7XG4gICAgICAgICAgICAoX21hcCRnZXQgPSBtYXAuZ2V0KGtleSkpID09IG51bGwgfHwgX21hcCRnZXQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICBhY2Nba2V5XSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIF9tYXAkZ2V0MjtcbiAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gKF9tYXAkZ2V0MiA9IG1hcC5nZXQoa2V5KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9tYXAkZ2V0Mi5tYXAoZm4gPT4gZm4oLi4uYXJncykpLmZpbmQodmFsID0+IHZhbCAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFjY1trZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSlcbiAgfTtcbn1cblxuLyoqXG4gKiBNZXJnZXMgYW4gYXJyYXkgb2YgaW50ZXJhY3Rpb24gaG9va3MnIHByb3BzIGludG8gcHJvcCBnZXR0ZXJzLCBhbGxvd2luZ1xuICogZXZlbnQgaGFuZGxlciBmdW5jdGlvbnMgdG8gYmUgY29tcG9zZWQgdG9nZXRoZXIgd2l0aG91dCBvdmVyd3JpdGluZyBvbmVcbiAqIGFub3RoZXIuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlSW50ZXJhY3Rpb25zXG4gKi9cbmZ1bmN0aW9uIHVzZUludGVyYWN0aW9ucyhwcm9wc0xpc3QpIHtcbiAgaWYgKHByb3BzTGlzdCA9PT0gdm9pZCAwKSB7XG4gICAgcHJvcHNMaXN0ID0gW107XG4gIH1cbiAgLy8gVGhlIGRlcGVuZGVuY2llcyBhcmUgYSBkeW5hbWljIGFycmF5LCBzbyB3ZSBjYW4ndCB1c2UgdGhlIGxpbnRlcidzXG4gIC8vIHN1Z2dlc3Rpb24gdG8gYWRkIGl0IHRvIHRoZSBkZXBzIGFycmF5LlxuICBjb25zdCBkZXBzID0gcHJvcHNMaXN0O1xuXG4gIC8vIGJpb21lLWlnbm9yZSBsaW50L2NvcnJlY3RuZXNzL3VzZUV4aGF1c3RpdmVEZXBlbmRlbmNpZXM6IGludGVudGlvbmFsXG4gIGNvbnN0IGdldFJlZmVyZW5jZVByb3BzID0gUmVhY3QudXNlQ2FsbGJhY2sodXNlclByb3BzID0+IG1lcmdlUHJvcHModXNlclByb3BzLCBwcm9wc0xpc3QsICdyZWZlcmVuY2UnKSwgZGVwcyk7XG5cbiAgLy8gYmlvbWUtaWdub3JlIGxpbnQvY29ycmVjdG5lc3MvdXNlRXhoYXVzdGl2ZURlcGVuZGVuY2llczogaW50ZW50aW9uYWxcbiAgY29uc3QgZ2V0RmxvYXRpbmdQcm9wcyA9IFJlYWN0LnVzZUNhbGxiYWNrKHVzZXJQcm9wcyA9PiBtZXJnZVByb3BzKHVzZXJQcm9wcywgcHJvcHNMaXN0LCAnZmxvYXRpbmcnKSwgZGVwcyk7XG5cbiAgLy8gYmlvbWUtaWdub3JlIGxpbnQvY29ycmVjdG5lc3MvdXNlRXhoYXVzdGl2ZURlcGVuZGVuY2llczogaW50ZW50aW9uYWxcbiAgY29uc3QgZ2V0SXRlbVByb3BzID0gUmVhY3QudXNlQ2FsbGJhY2sodXNlclByb3BzID0+IG1lcmdlUHJvcHModXNlclByb3BzLCBwcm9wc0xpc3QsICdpdGVtJyksXG4gIC8vIEdyYW51bGFybHkgY2hlY2sgZm9yIGBpdGVtYCBjaGFuZ2VzLCBiZWNhdXNlIHRoZSBgZ2V0SXRlbVByb3BzYCBnZXR0ZXJcbiAgLy8gc2hvdWxkIGJlIGFzIHJlZmVyZW50aWFsbHkgc3RhYmxlIGFzIHBvc3NpYmxlIHNpbmNlIGl0IG1heSBiZSBwYXNzZWQgYXNcbiAgLy8gYSBwcm9wIHRvIG1hbnkgY29tcG9uZW50cy4gQWxsIGBpdGVtYCBrZXkgdmFsdWVzIG11c3QgdGhlcmVmb3JlIGJlXG4gIC8vIG1lbW9pemVkLlxuICBwcm9wc0xpc3QubWFwKGtleSA9PiBrZXkgPT0gbnVsbCA/IHZvaWQgMCA6IGtleS5pdGVtKSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgZ2V0UmVmZXJlbmNlUHJvcHMsXG4gICAgZ2V0RmxvYXRpbmdQcm9wcyxcbiAgICBnZXRJdGVtUHJvcHNcbiAgfSksIFtnZXRSZWZlcmVuY2VQcm9wcywgZ2V0RmxvYXRpbmdQcm9wcywgZ2V0SXRlbVByb3BzXSk7XG59XG5cbmxldCBpc1ByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIGRvU3dpdGNoKG9yaWVudGF0aW9uLCB2ZXJ0aWNhbCwgaG9yaXpvbnRhbCkge1xuICBzd2l0Y2ggKG9yaWVudGF0aW9uKSB7XG4gICAgY2FzZSAndmVydGljYWwnOlxuICAgICAgcmV0dXJuIHZlcnRpY2FsO1xuICAgIGNhc2UgJ2hvcml6b250YWwnOlxuICAgICAgcmV0dXJuIGhvcml6b250YWw7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB2ZXJ0aWNhbCB8fCBob3Jpem9udGFsO1xuICB9XG59XG5mdW5jdGlvbiBpc01haW5PcmllbnRhdGlvbktleShrZXksIG9yaWVudGF0aW9uKSB7XG4gIGNvbnN0IHZlcnRpY2FsID0ga2V5ID09PSBBUlJPV19VUCB8fCBrZXkgPT09IEFSUk9XX0RPV047XG4gIGNvbnN0IGhvcml6b250YWwgPSBrZXkgPT09IEFSUk9XX0xFRlQgfHwga2V5ID09PSBBUlJPV19SSUdIVDtcbiAgcmV0dXJuIGRvU3dpdGNoKG9yaWVudGF0aW9uLCB2ZXJ0aWNhbCwgaG9yaXpvbnRhbCk7XG59XG5mdW5jdGlvbiBpc01haW5PcmllbnRhdGlvblRvRW5kS2V5KGtleSwgb3JpZW50YXRpb24sIHJ0bCkge1xuICBjb25zdCB2ZXJ0aWNhbCA9IGtleSA9PT0gQVJST1dfRE9XTjtcbiAgY29uc3QgaG9yaXpvbnRhbCA9IHJ0bCA/IGtleSA9PT0gQVJST1dfTEVGVCA6IGtleSA9PT0gQVJST1dfUklHSFQ7XG4gIHJldHVybiBkb1N3aXRjaChvcmllbnRhdGlvbiwgdmVydGljYWwsIGhvcml6b250YWwpIHx8IGtleSA9PT0gJ0VudGVyJyB8fCBrZXkgPT09ICcgJyB8fCBrZXkgPT09ICcnO1xufVxuZnVuY3Rpb24gaXNDcm9zc09yaWVudGF0aW9uT3BlbktleShrZXksIG9yaWVudGF0aW9uLCBydGwpIHtcbiAgY29uc3QgdmVydGljYWwgPSBydGwgPyBrZXkgPT09IEFSUk9XX0xFRlQgOiBrZXkgPT09IEFSUk9XX1JJR0hUO1xuICBjb25zdCBob3Jpem9udGFsID0ga2V5ID09PSBBUlJPV19ET1dOO1xuICByZXR1cm4gZG9Td2l0Y2gob3JpZW50YXRpb24sIHZlcnRpY2FsLCBob3Jpem9udGFsKTtcbn1cbmZ1bmN0aW9uIGlzQ3Jvc3NPcmllbnRhdGlvbkNsb3NlS2V5KGtleSwgb3JpZW50YXRpb24sIHJ0bCkge1xuICBjb25zdCB2ZXJ0aWNhbCA9IHJ0bCA/IGtleSA9PT0gQVJST1dfUklHSFQgOiBrZXkgPT09IEFSUk9XX0xFRlQ7XG4gIGNvbnN0IGhvcml6b250YWwgPSBrZXkgPT09IEFSUk9XX1VQO1xuICByZXR1cm4gZG9Td2l0Y2gob3JpZW50YXRpb24sIHZlcnRpY2FsLCBob3Jpem9udGFsKTtcbn1cbi8qKlxuICogQWRkcyBhcnJvdyBrZXktYmFzZWQgbmF2aWdhdGlvbiBvZiBhIGxpc3Qgb2YgaXRlbXMsIGVpdGhlciB1c2luZyByZWFsIERPTVxuICogZm9jdXMgb3IgdmlydHVhbCBmb2N1cy5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VMaXN0TmF2aWdhdGlvblxuICovXG5mdW5jdGlvbiB1c2VMaXN0TmF2aWdhdGlvbihjb250ZXh0LCBwcm9wcykge1xuICBjb25zdCB7XG4gICAgb3BlbixcbiAgICBvbk9wZW5DaGFuZ2UsXG4gICAgcmVmcyxcbiAgICBlbGVtZW50czoge1xuICAgICAgZG9tUmVmZXJlbmNlLFxuICAgICAgZmxvYXRpbmdcbiAgICB9XG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCB7XG4gICAgbGlzdFJlZixcbiAgICBhY3RpdmVJbmRleCxcbiAgICBvbk5hdmlnYXRlOiB1bnN0YWJsZV9vbk5hdmlnYXRlID0gKCkgPT4ge30sXG4gICAgZW5hYmxlZCA9IHRydWUsXG4gICAgc2VsZWN0ZWRJbmRleCA9IG51bGwsXG4gICAgYWxsb3dFc2NhcGUgPSBmYWxzZSxcbiAgICBsb29wID0gZmFsc2UsXG4gICAgbmVzdGVkID0gZmFsc2UsXG4gICAgcnRsID0gZmFsc2UsXG4gICAgdmlydHVhbCA9IGZhbHNlLFxuICAgIGZvY3VzSXRlbU9uT3BlbiA9ICdhdXRvJyxcbiAgICBmb2N1c0l0ZW1PbkhvdmVyID0gdHJ1ZSxcbiAgICBvcGVuT25BcnJvd0tleURvd24gPSB0cnVlLFxuICAgIGRpc2FibGVkSW5kaWNlcyA9IHVuZGVmaW5lZCxcbiAgICBvcmllbnRhdGlvbiA9ICd2ZXJ0aWNhbCcsXG4gICAgY29scyA9IDEsXG4gICAgc2Nyb2xsSXRlbUludG9WaWV3ID0gdHJ1ZSxcbiAgICB2aXJ0dWFsSXRlbVJlZixcbiAgICBpdGVtU2l6ZXMsXG4gICAgZGVuc2UgPSBmYWxzZVxuICB9ID0gcHJvcHM7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoYWxsb3dFc2NhcGUpIHtcbiAgICAgIGlmICghbG9vcCkge1xuICAgICAgICBjb25zb2xlLndhcm4oWydGbG9hdGluZyBVSTogYHVzZUxpc3ROYXZpZ2F0aW9uYCBsb29waW5nIG11c3QgYmUgZW5hYmxlZCB0byBhbGxvdycsICdlc2NhcGluZy4nXS5qb2luKCcgJykpO1xuICAgICAgfVxuICAgICAgaWYgKCF2aXJ0dWFsKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihbJ0Zsb2F0aW5nIFVJOiBgdXNlTGlzdE5hdmlnYXRpb25gIG11c3QgYmUgdmlydHVhbCB0byBhbGxvdycsICdlc2NhcGluZy4nXS5qb2luKCcgJykpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcgJiYgY29scyA+IDEpIHtcbiAgICAgIGNvbnNvbGUud2FybihbJ0Zsb2F0aW5nIFVJOiBJbiBncmlkIGxpc3QgbmF2aWdhdGlvbiBtb2RlIChgY29sc2AgPiAxKSwgdGhlJywgJ2BvcmllbnRhdGlvbmAgc2hvdWxkIGJlIGVpdGhlciBcImhvcml6b250YWxcIiBvciBcImJvdGhcIi4nXS5qb2luKCcgJykpO1xuICAgIH1cbiAgfVxuICBjb25zdCBwYXJlbnRJZCA9IHVzZUZsb2F0aW5nUGFyZW50Tm9kZUlkKCk7XG4gIGNvbnN0IHRyZWUgPSB1c2VGbG9hdGluZ1RyZWUoKTtcbiAgY29uc3Qgb25OYXZpZ2F0ZSA9IHVzZUVmZmVjdEV2ZW50KHVuc3RhYmxlX29uTmF2aWdhdGUpO1xuICBjb25zdCBmb2N1c0l0ZW1Pbk9wZW5SZWYgPSBSZWFjdC51c2VSZWYoZm9jdXNJdGVtT25PcGVuKTtcbiAgY29uc3QgaW5kZXhSZWYgPSBSZWFjdC51c2VSZWYoc2VsZWN0ZWRJbmRleCAhPSBudWxsID8gc2VsZWN0ZWRJbmRleCA6IC0xKTtcbiAgY29uc3Qga2V5UmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBpc1BvaW50ZXJNb2RhbGl0eVJlZiA9IFJlYWN0LnVzZVJlZih0cnVlKTtcbiAgY29uc3QgcHJldmlvdXNPbk5hdmlnYXRlUmVmID0gUmVhY3QudXNlUmVmKG9uTmF2aWdhdGUpO1xuICBjb25zdCBwcmV2aW91c01vdW50ZWRSZWYgPSBSZWFjdC51c2VSZWYoISFmbG9hdGluZyk7XG4gIGNvbnN0IGZvcmNlU3luY0ZvY3VzID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgZm9yY2VTY3JvbGxJbnRvVmlld1JlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IGRpc2FibGVkSW5kaWNlc1JlZiA9IHVzZUxhdGVzdFJlZihkaXNhYmxlZEluZGljZXMpO1xuICBjb25zdCBsYXRlc3RPcGVuUmVmID0gdXNlTGF0ZXN0UmVmKG9wZW4pO1xuICBjb25zdCBzY3JvbGxJdGVtSW50b1ZpZXdSZWYgPSB1c2VMYXRlc3RSZWYoc2Nyb2xsSXRlbUludG9WaWV3KTtcbiAgY29uc3QgW2FjdGl2ZUlkLCBzZXRBY3RpdmVJZF0gPSBSZWFjdC51c2VTdGF0ZSgpO1xuICBjb25zdCBbdmlydHVhbElkLCBzZXRWaXJ0dWFsSWRdID0gUmVhY3QudXNlU3RhdGUoKTtcbiAgY29uc3QgZm9jdXNJdGVtID0gdXNlRWZmZWN0RXZlbnQoZnVuY3Rpb24gKGxpc3RSZWYsIGluZGV4UmVmLCBmb3JjZVNjcm9sbEludG9WaWV3KSB7XG4gICAgaWYgKGZvcmNlU2Nyb2xsSW50b1ZpZXcgPT09IHZvaWQgMCkge1xuICAgICAgZm9yY2VTY3JvbGxJbnRvVmlldyA9IGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBpdGVtID0gbGlzdFJlZi5jdXJyZW50W2luZGV4UmVmLmN1cnJlbnRdO1xuICAgIGlmICghaXRlbSkgcmV0dXJuO1xuICAgIGlmICh2aXJ0dWFsKSB7XG4gICAgICBzZXRBY3RpdmVJZChpdGVtLmlkKTtcbiAgICAgIHRyZWUgPT0gbnVsbCB8fCB0cmVlLmV2ZW50cy5lbWl0KCd2aXJ0dWFsZm9jdXMnLCBpdGVtKTtcbiAgICAgIGlmICh2aXJ0dWFsSXRlbVJlZikge1xuICAgICAgICB2aXJ0dWFsSXRlbVJlZi5jdXJyZW50ID0gaXRlbTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZW5xdWV1ZUZvY3VzKGl0ZW0sIHtcbiAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZSxcbiAgICAgICAgLy8gTWFjIFNhZmFyaSBkb2VzIG5vdCBtb3ZlIHRoZSB2aXJ0dWFsIGN1cnNvciB1bmxlc3MgdGhlIGZvY3VzIGNhbGxcbiAgICAgICAgLy8gaXMgc3luYy4gSG93ZXZlciwgZm9yIHRoZSB2ZXJ5IGZpcnN0IGZvY3VzIGNhbGwsIHdlIG5lZWQgdG8gd2FpdFxuICAgICAgICAvLyBmb3IgdGhlIHBvc2l0aW9uIHRvIGJlIHJlYWR5IGluIG9yZGVyIHRvIHByZXZlbnQgdW53YW50ZWRcbiAgICAgICAgLy8gc2Nyb2xsaW5nLiBUaGlzIG1lYW5zIHRoZSB2aXJ0dWFsIGN1cnNvciB3aWxsIG5vdCBtb3ZlIHRvIHRoZSBmaXJzdFxuICAgICAgICAvLyBpdGVtIHdoZW4gZmlyc3Qgb3BlbmluZyB0aGUgZmxvYXRpbmcgZWxlbWVudCwgYnV0IHdpbGwgb25cbiAgICAgICAgLy8gc3Vic2VxdWVudCBjYWxscy4gYHByZXZlbnRTY3JvbGxgIGlzIHN1cHBvcnRlZCBpbiBtb2Rlcm4gU2FmYXJpLFxuICAgICAgICAvLyBzbyB3ZSBjYW4gdXNlIHRoYXQgaW5zdGVhZC5cbiAgICAgICAgLy8gaU9TIFNhZmFyaSBtdXN0IGJlIGFzeW5jIG9yIHRoZSBmaXJzdCBpdGVtIHdpbGwgbm90IGJlIGZvY3VzZWQuXG4gICAgICAgIHN5bmM6IGlzTWFjKCkgJiYgaXNTYWZhcmkoKSA/IGlzUHJldmVudFNjcm9sbFN1cHBvcnRlZCB8fCBmb3JjZVN5bmNGb2N1cy5jdXJyZW50IDogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgY29uc3Qgc2Nyb2xsSW50b1ZpZXdPcHRpb25zID0gc2Nyb2xsSXRlbUludG9WaWV3UmVmLmN1cnJlbnQ7XG4gICAgICBjb25zdCBzaG91bGRTY3JvbGxJbnRvVmlldyA9IHNjcm9sbEludG9WaWV3T3B0aW9ucyAmJiBpdGVtICYmIChmb3JjZVNjcm9sbEludG9WaWV3IHx8ICFpc1BvaW50ZXJNb2RhbGl0eVJlZi5jdXJyZW50KTtcbiAgICAgIGlmIChzaG91bGRTY3JvbGxJbnRvVmlldykge1xuICAgICAgICAvLyBKU0RPTSBkb2Vzbid0IHN1cHBvcnQgYC5zY3JvbGxJbnRvVmlldygpYCBidXQgaXQncyB3aWRlbHkgc3VwcG9ydGVkXG4gICAgICAgIC8vIGJ5IGFsbCBicm93c2Vycy5cbiAgICAgICAgaXRlbS5zY3JvbGxJbnRvVmlldyA9PSBudWxsIHx8IGl0ZW0uc2Nyb2xsSW50b1ZpZXcodHlwZW9mIHNjcm9sbEludG9WaWV3T3B0aW9ucyA9PT0gJ2Jvb2xlYW4nID8ge1xuICAgICAgICAgIGJsb2NrOiAnbmVhcmVzdCcsXG4gICAgICAgICAgaW5saW5lOiAnbmVhcmVzdCdcbiAgICAgICAgfSA6IHNjcm9sbEludG9WaWV3T3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykuZm9jdXMoe1xuICAgICAgZ2V0IHByZXZlbnRTY3JvbGwoKSB7XG4gICAgICAgIGlzUHJldmVudFNjcm9sbFN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgW10pO1xuXG4gIC8vIFN5bmMgYHNlbGVjdGVkSW5kZXhgIHRvIGJlIHRoZSBgYWN0aXZlSW5kZXhgIHVwb24gb3BlbmluZyB0aGUgZmxvYXRpbmdcbiAgLy8gZWxlbWVudC4gQWxzbywgcmVzZXQgYGFjdGl2ZUluZGV4YCB1cG9uIGNsb3NpbmcgdGhlIGZsb2F0aW5nIGVsZW1lbnQuXG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG9wZW4gJiYgZmxvYXRpbmcpIHtcbiAgICAgIGlmIChmb2N1c0l0ZW1Pbk9wZW5SZWYuY3VycmVudCAmJiBzZWxlY3RlZEluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgLy8gUmVnYXJkbGVzcyBvZiB0aGUgcG9pbnRlciBtb2RhbGl0eSwgd2Ugd2FudCB0byBlbnN1cmUgdGhlIHNlbGVjdGVkXG4gICAgICAgIC8vIGl0ZW0gY29tZXMgaW50byB2aWV3IHdoZW4gdGhlIGZsb2F0aW5nIGVsZW1lbnQgaXMgb3BlbmVkLlxuICAgICAgICBmb3JjZVNjcm9sbEludG9WaWV3UmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgb25OYXZpZ2F0ZShzZWxlY3RlZEluZGV4KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByZXZpb3VzTW91bnRlZFJlZi5jdXJyZW50KSB7XG4gICAgICAvLyBTaW5jZSB0aGUgdXNlciBjYW4gc3BlY2lmeSBgb25OYXZpZ2F0ZWAgY29uZGl0aW9uYWxseVxuICAgICAgLy8gKG9uTmF2aWdhdGU6IG9wZW4gPyBzZXRBY3RpdmVJbmRleCA6IHNldFNlbGVjdGVkSW5kZXgpLFxuICAgICAgLy8gd2Ugc3RvcmUgYW5kIGNhbGwgdGhlIHByZXZpb3VzIGZ1bmN0aW9uLlxuICAgICAgaW5kZXhSZWYuY3VycmVudCA9IC0xO1xuICAgICAgcHJldmlvdXNPbk5hdmlnYXRlUmVmLmN1cnJlbnQobnVsbCk7XG4gICAgfVxuICB9LCBbZW5hYmxlZCwgb3BlbiwgZmxvYXRpbmcsIHNlbGVjdGVkSW5kZXgsIG9uTmF2aWdhdGVdKTtcblxuICAvLyBTeW5jIGBhY3RpdmVJbmRleGAgdG8gYmUgdGhlIGZvY3VzZWQgaXRlbSB3aGlsZSB0aGUgZmxvYXRpbmcgZWxlbWVudCBpc1xuICAvLyBvcGVuLlxuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChvcGVuICYmIGZsb2F0aW5nKSB7XG4gICAgICBpZiAoYWN0aXZlSW5kZXggPT0gbnVsbCkge1xuICAgICAgICBmb3JjZVN5bmNGb2N1cy5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIGlmIChzZWxlY3RlZEluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXNldCB3aGlsZSB0aGUgZmxvYXRpbmcgZWxlbWVudCB3YXMgb3BlbiAoZS5nLiB0aGUgbGlzdCBjaGFuZ2VkKS5cbiAgICAgICAgaWYgKHByZXZpb3VzTW91bnRlZFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IC0xO1xuICAgICAgICAgIGZvY3VzSXRlbShsaXN0UmVmLCBpbmRleFJlZik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbml0aWFsIHN5bmMuXG4gICAgICAgIGlmICghcHJldmlvdXNNb3VudGVkUmVmLmN1cnJlbnQgJiYgZm9jdXNJdGVtT25PcGVuUmVmLmN1cnJlbnQgJiYgKGtleVJlZi5jdXJyZW50ICE9IG51bGwgfHwgZm9jdXNJdGVtT25PcGVuUmVmLmN1cnJlbnQgPT09IHRydWUgJiYga2V5UmVmLmN1cnJlbnQgPT0gbnVsbCkpIHtcbiAgICAgICAgICBsZXQgcnVucyA9IDA7XG4gICAgICAgICAgY29uc3Qgd2FpdEZvckxpc3RQb3B1bGF0ZWQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAobGlzdFJlZi5jdXJyZW50WzBdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gQXZvaWQgbGV0dGluZyB0aGUgYnJvd3NlciBwYWludCBpZiBwb3NzaWJsZSBvbiB0aGUgZmlyc3QgdHJ5LFxuICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgdXNlIHJBRi4gRG9uJ3QgdHJ5IG1vcmUgdGhhbiB0d2ljZSwgc2luY2Ugc29tZXRoaW5nXG4gICAgICAgICAgICAgIC8vIGlzIHdyb25nIG90aGVyd2lzZS5cbiAgICAgICAgICAgICAgaWYgKHJ1bnMgPCAyKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoZWR1bGVyID0gcnVucyA/IHJlcXVlc3RBbmltYXRpb25GcmFtZSA6IHF1ZXVlTWljcm90YXNrO1xuICAgICAgICAgICAgICAgIHNjaGVkdWxlcih3YWl0Rm9yTGlzdFBvcHVsYXRlZCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcnVucysrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IGtleVJlZi5jdXJyZW50ID09IG51bGwgfHwgaXNNYWluT3JpZW50YXRpb25Ub0VuZEtleShrZXlSZWYuY3VycmVudCwgb3JpZW50YXRpb24sIHJ0bCkgfHwgbmVzdGVkID8gZ2V0TWluSW5kZXgobGlzdFJlZiwgZGlzYWJsZWRJbmRpY2VzUmVmLmN1cnJlbnQpIDogZ2V0TWF4SW5kZXgobGlzdFJlZiwgZGlzYWJsZWRJbmRpY2VzUmVmLmN1cnJlbnQpO1xuICAgICAgICAgICAgICBrZXlSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICAgIG9uTmF2aWdhdGUoaW5kZXhSZWYuY3VycmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICB3YWl0Rm9yTGlzdFBvcHVsYXRlZCgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFpc0luZGV4T3V0T2ZCb3VuZHMobGlzdFJlZiwgYWN0aXZlSW5kZXgpKSB7XG4gICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBhY3RpdmVJbmRleDtcbiAgICAgICAgZm9jdXNJdGVtKGxpc3RSZWYsIGluZGV4UmVmLCBmb3JjZVNjcm9sbEludG9WaWV3UmVmLmN1cnJlbnQpO1xuICAgICAgICBmb3JjZVNjcm9sbEludG9WaWV3UmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtlbmFibGVkLCBvcGVuLCBmbG9hdGluZywgYWN0aXZlSW5kZXgsIHNlbGVjdGVkSW5kZXgsIG5lc3RlZCwgbGlzdFJlZiwgb3JpZW50YXRpb24sIHJ0bCwgb25OYXZpZ2F0ZSwgZm9jdXNJdGVtLCBkaXNhYmxlZEluZGljZXNSZWZdKTtcblxuICAvLyBFbnN1cmUgdGhlIHBhcmVudCBmbG9hdGluZyBlbGVtZW50IGhhcyBmb2N1cyB3aGVuIGEgbmVzdGVkIGNoaWxkIGNsb3Nlc1xuICAvLyB0byBhbGxvdyBhcnJvdyBrZXkgbmF2aWdhdGlvbiB0byB3b3JrIGFmdGVyIHRoZSBwb2ludGVyIGxlYXZlcyB0aGUgY2hpbGQuXG4gIGluZGV4KCgpID0+IHtcbiAgICB2YXIgX25vZGVzJGZpbmQ7XG4gICAgaWYgKCFlbmFibGVkIHx8IGZsb2F0aW5nIHx8ICF0cmVlIHx8IHZpcnR1YWwgfHwgIXByZXZpb3VzTW91bnRlZFJlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5vZGVzID0gdHJlZS5ub2Rlc1JlZi5jdXJyZW50O1xuICAgIGNvbnN0IHBhcmVudCA9IChfbm9kZXMkZmluZCA9IG5vZGVzLmZpbmQobm9kZSA9PiBub2RlLmlkID09PSBwYXJlbnRJZCkpID09IG51bGwgfHwgKF9ub2RlcyRmaW5kID0gX25vZGVzJGZpbmQuY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlcyRmaW5kLmVsZW1lbnRzLmZsb2F0aW5nO1xuICAgIGNvbnN0IGFjdGl2ZUVsID0gYWN0aXZlRWxlbWVudChnZXREb2N1bWVudChmbG9hdGluZykpO1xuICAgIGNvbnN0IHRyZWVDb250YWluc0FjdGl2ZUVsID0gbm9kZXMuc29tZShub2RlID0+IG5vZGUuY29udGV4dCAmJiBjb250YWlucyhub2RlLmNvbnRleHQuZWxlbWVudHMuZmxvYXRpbmcsIGFjdGl2ZUVsKSk7XG4gICAgaWYgKHBhcmVudCAmJiAhdHJlZUNvbnRhaW5zQWN0aXZlRWwgJiYgaXNQb2ludGVyTW9kYWxpdHlSZWYuY3VycmVudCkge1xuICAgICAgcGFyZW50LmZvY3VzKHtcbiAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9LCBbZW5hYmxlZCwgZmxvYXRpbmcsIHRyZWUsIHBhcmVudElkLCB2aXJ0dWFsXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQgfHwgIXRyZWUgfHwgIXZpcnR1YWwgfHwgcGFyZW50SWQpIHJldHVybjtcbiAgICBmdW5jdGlvbiBoYW5kbGVWaXJ0dWFsRm9jdXMoaXRlbSkge1xuICAgICAgc2V0VmlydHVhbElkKGl0ZW0uaWQpO1xuICAgICAgaWYgKHZpcnR1YWxJdGVtUmVmKSB7XG4gICAgICAgIHZpcnR1YWxJdGVtUmVmLmN1cnJlbnQgPSBpdGVtO1xuICAgICAgfVxuICAgIH1cbiAgICB0cmVlLmV2ZW50cy5vbigndmlydHVhbGZvY3VzJywgaGFuZGxlVmlydHVhbEZvY3VzKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdHJlZS5ldmVudHMub2ZmKCd2aXJ0dWFsZm9jdXMnLCBoYW5kbGVWaXJ0dWFsRm9jdXMpO1xuICAgIH07XG4gIH0sIFtlbmFibGVkLCB0cmVlLCB2aXJ0dWFsLCBwYXJlbnRJZCwgdmlydHVhbEl0ZW1SZWZdKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIHByZXZpb3VzT25OYXZpZ2F0ZVJlZi5jdXJyZW50ID0gb25OYXZpZ2F0ZTtcbiAgICBwcmV2aW91c01vdW50ZWRSZWYuY3VycmVudCA9ICEhZmxvYXRpbmc7XG4gIH0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKCFvcGVuKSB7XG4gICAgICBrZXlSZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICB9LCBbb3Blbl0pO1xuICBjb25zdCBoYXNBY3RpdmVJbmRleCA9IGFjdGl2ZUluZGV4ICE9IG51bGw7XG4gIGNvbnN0IGl0ZW0gPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBmdW5jdGlvbiBzeW5jQ3VycmVudFRhcmdldChjdXJyZW50VGFyZ2V0KSB7XG4gICAgICBpZiAoIW9wZW4pIHJldHVybjtcbiAgICAgIGNvbnN0IGluZGV4ID0gbGlzdFJlZi5jdXJyZW50LmluZGV4T2YoY3VycmVudFRhcmdldCk7XG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIG9uTmF2aWdhdGUoaW5kZXgpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBwcm9wcyA9IHtcbiAgICAgIG9uRm9jdXMoX3JlZikge1xuICAgICAgICBsZXQge1xuICAgICAgICAgIGN1cnJlbnRUYXJnZXRcbiAgICAgICAgfSA9IF9yZWY7XG4gICAgICAgIHN5bmNDdXJyZW50VGFyZ2V0KGN1cnJlbnRUYXJnZXQpO1xuICAgICAgfSxcbiAgICAgIG9uQ2xpY2s6IF9yZWYyID0+IHtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBjdXJyZW50VGFyZ2V0XG4gICAgICAgIH0gPSBfcmVmMjtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRUYXJnZXQuZm9jdXMoe1xuICAgICAgICAgIHByZXZlbnRTY3JvbGw6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgLy8gU2FmYXJpXG4gICAgICAuLi4oZm9jdXNJdGVtT25Ib3ZlciAmJiB7XG4gICAgICAgIG9uTW91c2VNb3ZlKF9yZWYzKSB7XG4gICAgICAgICAgbGV0IHtcbiAgICAgICAgICAgIGN1cnJlbnRUYXJnZXRcbiAgICAgICAgICB9ID0gX3JlZjM7XG4gICAgICAgICAgc3luY0N1cnJlbnRUYXJnZXQoY3VycmVudFRhcmdldCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uUG9pbnRlckxlYXZlKF9yZWY0KSB7XG4gICAgICAgICAgbGV0IHtcbiAgICAgICAgICAgIHBvaW50ZXJUeXBlXG4gICAgICAgICAgfSA9IF9yZWY0O1xuICAgICAgICAgIGlmICghaXNQb2ludGVyTW9kYWxpdHlSZWYuY3VycmVudCB8fCBwb2ludGVyVHlwZSA9PT0gJ3RvdWNoJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gLTE7XG4gICAgICAgICAgZm9jdXNJdGVtKGxpc3RSZWYsIGluZGV4UmVmKTtcbiAgICAgICAgICBvbk5hdmlnYXRlKG51bGwpO1xuICAgICAgICAgIGlmICghdmlydHVhbCkge1xuICAgICAgICAgICAgZW5xdWV1ZUZvY3VzKHJlZnMuZmxvYXRpbmcuY3VycmVudCwge1xuICAgICAgICAgICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfTtcbiAgICByZXR1cm4gcHJvcHM7XG4gIH0sIFtvcGVuLCByZWZzLCBmb2N1c0l0ZW0sIGZvY3VzSXRlbU9uSG92ZXIsIGxpc3RSZWYsIG9uTmF2aWdhdGUsIHZpcnR1YWxdKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBjb25zdCBkaXNhYmxlZEluZGljZXMgPSBkaXNhYmxlZEluZGljZXNSZWYuY3VycmVudDtcbiAgICBmdW5jdGlvbiBvbktleURvd24oZXZlbnQpIHtcbiAgICAgIGlzUG9pbnRlck1vZGFsaXR5UmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIGZvcmNlU3luY0ZvY3VzLmN1cnJlbnQgPSB0cnVlO1xuXG4gICAgICAvLyBJZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBpcyBhbmltYXRpbmcgb3V0LCBpZ25vcmUgbmF2aWdhdGlvbi4gT3RoZXJ3aXNlLFxuICAgICAgLy8gdGhlIGBhY3RpdmVJbmRleGAgZ2V0cyBzZXQgdG8gMCBkZXNwaXRlIG5vdCBiZWluZyBvcGVuIHNvIHRoZSBuZXh0IHRpbWVcbiAgICAgIC8vIHRoZSB1c2VyIEFycm93RG93bnMsIHRoZSBmaXJzdCBpdGVtIHdvbid0IGJlIGZvY3VzZWQuXG4gICAgICBpZiAoIWxhdGVzdE9wZW5SZWYuY3VycmVudCAmJiBldmVudC5jdXJyZW50VGFyZ2V0ID09PSByZWZzLmZsb2F0aW5nLmN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG5lc3RlZCAmJiBpc0Nyb3NzT3JpZW50YXRpb25DbG9zZUtleShldmVudC5rZXksIG9yaWVudGF0aW9uLCBydGwpKSB7XG4gICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICAgIG9uT3BlbkNoYW5nZShmYWxzZSwgZXZlbnQubmF0aXZlRXZlbnQsICdsaXN0LW5hdmlnYXRpb24nKTtcbiAgICAgICAgaWYgKGlzSFRNTEVsZW1lbnQoZG9tUmVmZXJlbmNlKSAmJiAhdmlydHVhbCkge1xuICAgICAgICAgIGRvbVJlZmVyZW5jZS5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IGluZGV4UmVmLmN1cnJlbnQ7XG4gICAgICBjb25zdCBtaW5JbmRleCA9IGdldE1pbkluZGV4KGxpc3RSZWYsIGRpc2FibGVkSW5kaWNlcyk7XG4gICAgICBjb25zdCBtYXhJbmRleCA9IGdldE1heEluZGV4KGxpc3RSZWYsIGRpc2FibGVkSW5kaWNlcyk7XG4gICAgICBpZiAoZXZlbnQua2V5ID09PSAnSG9tZScpIHtcbiAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IG1pbkluZGV4O1xuICAgICAgICBvbk5hdmlnYXRlKGluZGV4UmVmLmN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ0VuZCcpIHtcbiAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IG1heEluZGV4O1xuICAgICAgICBvbk5hdmlnYXRlKGluZGV4UmVmLmN1cnJlbnQpO1xuICAgICAgfVxuXG4gICAgICAvLyBHcmlkIG5hdmlnYXRpb24uXG4gICAgICBpZiAoY29scyA+IDEpIHtcbiAgICAgICAgY29uc3Qgc2l6ZXMgPSBpdGVtU2l6ZXMgfHwgQXJyYXkuZnJvbSh7XG4gICAgICAgICAgbGVuZ3RoOiBsaXN0UmVmLmN1cnJlbnQubGVuZ3RoXG4gICAgICAgIH0sICgpID0+ICh7XG4gICAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgICAgaGVpZ2h0OiAxXG4gICAgICAgIH0pKTtcbiAgICAgICAgLy8gVG8gY2FsY3VsYXRlIG1vdmVtZW50cyBvbiB0aGUgZ3JpZCwgd2UgdXNlIGh5cG90aGV0aWNhbCBjZWxsIGluZGljZXNcbiAgICAgICAgLy8gYXMgaWYgZXZlcnkgaXRlbSB3YXMgMXgxLCB0aGVuIGNvbnZlcnQgYmFjayB0byByZWFsIGluZGljZXMuXG4gICAgICAgIGNvbnN0IGNlbGxNYXAgPSBidWlsZENlbGxNYXAoc2l6ZXMsIGNvbHMsIGRlbnNlKTtcbiAgICAgICAgY29uc3QgbWluR3JpZEluZGV4ID0gY2VsbE1hcC5maW5kSW5kZXgoaW5kZXggPT4gaW5kZXggIT0gbnVsbCAmJiAhKGRpc2FibGVkSW5kaWNlcyAhPSBudWxsICYmIGRpc2FibGVkSW5kaWNlcy5pbmNsdWRlcyhpbmRleCkpKTtcbiAgICAgICAgLy8gbGFzdCBlbmFibGVkIGluZGV4XG4gICAgICAgIGNvbnN0IG1heEdyaWRJbmRleCA9IGNlbGxNYXAucmVkdWNlKChmb3VuZEluZGV4LCBpbmRleCwgY2VsbEluZGV4KSA9PiBpbmRleCAhPSBudWxsICYmICEoZGlzYWJsZWRJbmRpY2VzICE9IG51bGwgJiYgZGlzYWJsZWRJbmRpY2VzLmluY2x1ZGVzKGluZGV4KSkgPyBjZWxsSW5kZXggOiBmb3VuZEluZGV4LCAtMSk7XG4gICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBjZWxsTWFwW2dldEdyaWROYXZpZ2F0ZWRJbmRleCh7XG4gICAgICAgICAgY3VycmVudDogY2VsbE1hcC5tYXAoaXRlbUluZGV4ID0+IGl0ZW1JbmRleCAhPSBudWxsID8gbGlzdFJlZi5jdXJyZW50W2l0ZW1JbmRleF0gOiBudWxsKVxuICAgICAgICB9LCB7XG4gICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgb3JpZW50YXRpb24sXG4gICAgICAgICAgbG9vcCxcbiAgICAgICAgICBjb2xzLFxuICAgICAgICAgIC8vIHRyZWF0IHVuZGVmaW5lZCAoZW1wdHkgZ3JpZCBzcGFjZXMpIGFzIGRpc2FibGVkIGluZGljZXMgc28gd2VcbiAgICAgICAgICAvLyBkb24ndCBlbmQgdXAgaW4gdGhlbVxuICAgICAgICAgIGRpc2FibGVkSW5kaWNlczogZ2V0Q2VsbEluZGljZXMoWy4uLihkaXNhYmxlZEluZGljZXMgfHwgW10pLCB1bmRlZmluZWRdLCBjZWxsTWFwKSxcbiAgICAgICAgICBtaW5JbmRleDogbWluR3JpZEluZGV4LFxuICAgICAgICAgIG1heEluZGV4OiBtYXhHcmlkSW5kZXgsXG4gICAgICAgICAgcHJldkluZGV4OiBnZXRDZWxsSW5kZXhPZkNvcm5lcihpbmRleFJlZi5jdXJyZW50LCBzaXplcywgY2VsbE1hcCwgY29scyxcbiAgICAgICAgICAvLyB1c2UgYSBjb3JuZXIgbWF0Y2hpbmcgdGhlIGVkZ2UgY2xvc2VzdCB0byB0aGUgZGlyZWN0aW9uXG4gICAgICAgICAgLy8gd2UncmUgbW92aW5nIGluIHNvIHdlIGRvbid0IGVuZCB1cCBpbiB0aGUgc2FtZSBpdGVtLiBQcmVmZXJcbiAgICAgICAgICAvLyB0b3AvbGVmdCBvdmVyIGJvdHRvbS9yaWdodC5cbiAgICAgICAgICBldmVudC5rZXkgPT09IEFSUk9XX0RPV04gPyAnYmwnIDogZXZlbnQua2V5ID09PSBBUlJPV19SSUdIVCA/ICd0cicgOiAndGwnKSxcbiAgICAgICAgICBzdG9wRXZlbnQ6IHRydWVcbiAgICAgICAgfSldOyAvLyBuYXZpZ2F0ZWQgY2VsbCB3aWxsIG5ldmVyIGJlIG51bGxpc2hcblxuICAgICAgICBvbk5hdmlnYXRlKGluZGV4UmVmLmN1cnJlbnQpO1xuICAgICAgICBpZiAob3JpZW50YXRpb24gPT09ICdib3RoJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzTWFpbk9yaWVudGF0aW9uS2V5KGV2ZW50LmtleSwgb3JpZW50YXRpb24pKSB7XG4gICAgICAgIHN0b3BFdmVudChldmVudCk7XG5cbiAgICAgICAgLy8gUmVzZXQgdGhlIGluZGV4IGlmIG5vIGl0ZW0gaXMgZm9jdXNlZC5cbiAgICAgICAgaWYgKG9wZW4gJiYgIXZpcnR1YWwgJiYgYWN0aXZlRWxlbWVudChldmVudC5jdXJyZW50VGFyZ2V0Lm93bmVyRG9jdW1lbnQpID09PSBldmVudC5jdXJyZW50VGFyZ2V0KSB7XG4gICAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IGlzTWFpbk9yaWVudGF0aW9uVG9FbmRLZXkoZXZlbnQua2V5LCBvcmllbnRhdGlvbiwgcnRsKSA/IG1pbkluZGV4IDogbWF4SW5kZXg7XG4gICAgICAgICAgb25OYXZpZ2F0ZShpbmRleFJlZi5jdXJyZW50KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTWFpbk9yaWVudGF0aW9uVG9FbmRLZXkoZXZlbnQua2V5LCBvcmllbnRhdGlvbiwgcnRsKSkge1xuICAgICAgICAgIGlmIChsb29wKSB7XG4gICAgICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gY3VycmVudEluZGV4ID49IG1heEluZGV4ID8gYWxsb3dFc2NhcGUgJiYgY3VycmVudEluZGV4ICE9PSBsaXN0UmVmLmN1cnJlbnQubGVuZ3RoID8gLTEgOiBtaW5JbmRleCA6IGZpbmROb25EaXNhYmxlZEluZGV4KGxpc3RSZWYsIHtcbiAgICAgICAgICAgICAgc3RhcnRpbmdJbmRleDogY3VycmVudEluZGV4LFxuICAgICAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gTWF0aC5taW4obWF4SW5kZXgsIGZpbmROb25EaXNhYmxlZEluZGV4KGxpc3RSZWYsIHtcbiAgICAgICAgICAgICAgc3RhcnRpbmdJbmRleDogY3VycmVudEluZGV4LFxuICAgICAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGxvb3ApIHtcbiAgICAgICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBjdXJyZW50SW5kZXggPD0gbWluSW5kZXggPyBhbGxvd0VzY2FwZSAmJiBjdXJyZW50SW5kZXggIT09IC0xID8gbGlzdFJlZi5jdXJyZW50Lmxlbmd0aCA6IG1heEluZGV4IDogZmluZE5vbkRpc2FibGVkSW5kZXgobGlzdFJlZiwge1xuICAgICAgICAgICAgICBzdGFydGluZ0luZGV4OiBjdXJyZW50SW5kZXgsXG4gICAgICAgICAgICAgIGRlY3JlbWVudDogdHJ1ZSxcbiAgICAgICAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IE1hdGgubWF4KG1pbkluZGV4LCBmaW5kTm9uRGlzYWJsZWRJbmRleChsaXN0UmVmLCB7XG4gICAgICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IGN1cnJlbnRJbmRleCxcbiAgICAgICAgICAgICAgZGVjcmVtZW50OiB0cnVlLFxuICAgICAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzSW5kZXhPdXRPZkJvdW5kcyhsaXN0UmVmLCBpbmRleFJlZi5jdXJyZW50KSkge1xuICAgICAgICAgIG9uTmF2aWdhdGUobnVsbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb25OYXZpZ2F0ZShpbmRleFJlZi5jdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja1ZpcnR1YWxNb3VzZShldmVudCkge1xuICAgICAgaWYgKGZvY3VzSXRlbU9uT3BlbiA9PT0gJ2F1dG8nICYmIGlzVmlydHVhbENsaWNrKGV2ZW50Lm5hdGl2ZUV2ZW50KSkge1xuICAgICAgICBmb2N1c0l0ZW1Pbk9wZW5SZWYuY3VycmVudCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrVmlydHVhbFBvaW50ZXIoZXZlbnQpIHtcbiAgICAgIC8vIGBwb2ludGVyZG93bmAgZmlyZXMgZmlyc3QsIHJlc2V0IHRoZSBzdGF0ZSB0aGVuIHBlcmZvcm0gdGhlIGNoZWNrcy5cbiAgICAgIGZvY3VzSXRlbU9uT3BlblJlZi5jdXJyZW50ID0gZm9jdXNJdGVtT25PcGVuO1xuICAgICAgaWYgKGZvY3VzSXRlbU9uT3BlbiA9PT0gJ2F1dG8nICYmIGlzVmlydHVhbFBvaW50ZXJFdmVudChldmVudC5uYXRpdmVFdmVudCkpIHtcbiAgICAgICAgZm9jdXNJdGVtT25PcGVuUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBhcmlhQWN0aXZlRGVzY2VuZGFudFByb3AgPSB2aXJ0dWFsICYmIG9wZW4gJiYgaGFzQWN0aXZlSW5kZXggJiYge1xuICAgICAgJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCc6IHZpcnR1YWxJZCB8fCBhY3RpdmVJZFxuICAgIH07XG4gICAgY29uc3QgYWN0aXZlSXRlbSA9IGxpc3RSZWYuY3VycmVudC5maW5kKGl0ZW0gPT4gKGl0ZW0gPT0gbnVsbCA/IHZvaWQgMCA6IGl0ZW0uaWQpID09PSBhY3RpdmVJZCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZmVyZW5jZToge1xuICAgICAgICAuLi5hcmlhQWN0aXZlRGVzY2VuZGFudFByb3AsXG4gICAgICAgIG9uS2V5RG93bihldmVudCkge1xuICAgICAgICAgIGlzUG9pbnRlck1vZGFsaXR5UmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICBjb25zdCBpc0Fycm93S2V5ID0gZXZlbnQua2V5LmluZGV4T2YoJ0Fycm93JykgPT09IDA7XG4gICAgICAgICAgY29uc3QgaXNDcm9zc09wZW5LZXkgPSBpc0Nyb3NzT3JpZW50YXRpb25PcGVuS2V5KGV2ZW50LmtleSwgb3JpZW50YXRpb24sIHJ0bCk7XG4gICAgICAgICAgY29uc3QgaXNDcm9zc0Nsb3NlS2V5ID0gaXNDcm9zc09yaWVudGF0aW9uQ2xvc2VLZXkoZXZlbnQua2V5LCBvcmllbnRhdGlvbiwgcnRsKTtcbiAgICAgICAgICBjb25zdCBpc01haW5LZXkgPSBpc01haW5PcmllbnRhdGlvbktleShldmVudC5rZXksIG9yaWVudGF0aW9uKTtcbiAgICAgICAgICBjb25zdCBpc05hdmlnYXRpb25LZXkgPSAobmVzdGVkID8gaXNDcm9zc09wZW5LZXkgOiBpc01haW5LZXkpIHx8IGV2ZW50LmtleSA9PT0gJ0VudGVyJyB8fCBldmVudC5rZXkudHJpbSgpID09PSAnJztcbiAgICAgICAgICBpZiAodmlydHVhbCAmJiBvcGVuKSB7XG4gICAgICAgICAgICBjb25zdCByb290Tm9kZSA9IHRyZWUgPT0gbnVsbCA/IHZvaWQgMCA6IHRyZWUubm9kZXNSZWYuY3VycmVudC5maW5kKG5vZGUgPT4gbm9kZS5wYXJlbnRJZCA9PSBudWxsKTtcbiAgICAgICAgICAgIGNvbnN0IGRlZXBlc3ROb2RlID0gdHJlZSAmJiByb290Tm9kZSA/IGdldERlZXBlc3ROb2RlKHRyZWUubm9kZXNSZWYuY3VycmVudCwgcm9vdE5vZGUuaWQpIDogbnVsbDtcbiAgICAgICAgICAgIGlmIChpc0Fycm93S2V5ICYmIGRlZXBlc3ROb2RlICYmIHZpcnR1YWxJdGVtUmVmKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGV2ZW50T2JqZWN0ID0gbmV3IEtleWJvYXJkRXZlbnQoJ2tleWRvd24nLCB7XG4gICAgICAgICAgICAgICAga2V5OiBldmVudC5rZXksXG4gICAgICAgICAgICAgICAgYnViYmxlczogdHJ1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKGlzQ3Jvc3NPcGVuS2V5IHx8IGlzQ3Jvc3NDbG9zZUtleSkge1xuICAgICAgICAgICAgICAgIHZhciBfZGVlcGVzdE5vZGUkY29udGV4dCwgX2RlZXBlc3ROb2RlJGNvbnRleHQyO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzQ3VycmVudFRhcmdldCA9ICgoX2RlZXBlc3ROb2RlJGNvbnRleHQgPSBkZWVwZXN0Tm9kZS5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX2RlZXBlc3ROb2RlJGNvbnRleHQuZWxlbWVudHMuZG9tUmVmZXJlbmNlKSA9PT0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXNwYXRjaEl0ZW0gPSBpc0Nyb3NzQ2xvc2VLZXkgJiYgIWlzQ3VycmVudFRhcmdldCA/IChfZGVlcGVzdE5vZGUkY29udGV4dDIgPSBkZWVwZXN0Tm9kZS5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX2RlZXBlc3ROb2RlJGNvbnRleHQyLmVsZW1lbnRzLmRvbVJlZmVyZW5jZSA6IGlzQ3Jvc3NPcGVuS2V5ID8gYWN0aXZlSXRlbSA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGRpc3BhdGNoSXRlbSkge1xuICAgICAgICAgICAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgIGRpc3BhdGNoSXRlbS5kaXNwYXRjaEV2ZW50KGV2ZW50T2JqZWN0KTtcbiAgICAgICAgICAgICAgICAgIHNldFZpcnR1YWxJZCh1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXNNYWluS2V5ICYmIGRlZXBlc3ROb2RlLmNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVlcGVzdE5vZGUuY29udGV4dC5vcGVuICYmIGRlZXBlc3ROb2RlLnBhcmVudElkICYmIGV2ZW50LmN1cnJlbnRUYXJnZXQgIT09IGRlZXBlc3ROb2RlLmNvbnRleHQuZWxlbWVudHMuZG9tUmVmZXJlbmNlKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgX2RlZXBlc3ROb2RlJGNvbnRleHQkO1xuICAgICAgICAgICAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgIChfZGVlcGVzdE5vZGUkY29udGV4dCQgPSBkZWVwZXN0Tm9kZS5jb250ZXh0LmVsZW1lbnRzLmRvbVJlZmVyZW5jZSkgPT0gbnVsbCB8fCBfZGVlcGVzdE5vZGUkY29udGV4dCQuZGlzcGF0Y2hFdmVudChldmVudE9iamVjdCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb25LZXlEb3duKGV2ZW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiBhIGZsb2F0aW5nIGVsZW1lbnQgc2hvdWxkIG5vdCBvcGVuIG9uIGFycm93IGtleSBkb3duLCBhdm9pZFxuICAgICAgICAgIC8vIHNldHRpbmcgYGFjdGl2ZUluZGV4YCB3aGlsZSBpdCdzIGNsb3NlZC5cbiAgICAgICAgICBpZiAoIW9wZW4gJiYgIW9wZW5PbkFycm93S2V5RG93biAmJiBpc0Fycm93S2V5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc05hdmlnYXRpb25LZXkpIHtcbiAgICAgICAgICAgIGtleVJlZi5jdXJyZW50ID0gbmVzdGVkICYmIGlzTWFpbktleSA/IG51bGwgOiBldmVudC5rZXk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChuZXN0ZWQpIHtcbiAgICAgICAgICAgIGlmIChpc0Nyb3NzT3BlbktleSkge1xuICAgICAgICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgICBpZiAob3Blbikge1xuICAgICAgICAgICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBnZXRNaW5JbmRleChsaXN0UmVmLCBkaXNhYmxlZEluZGljZXMpO1xuICAgICAgICAgICAgICAgIG9uTmF2aWdhdGUoaW5kZXhSZWYuY3VycmVudCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb25PcGVuQ2hhbmdlKHRydWUsIGV2ZW50Lm5hdGl2ZUV2ZW50LCAnbGlzdC1uYXZpZ2F0aW9uJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzTWFpbktleSkge1xuICAgICAgICAgICAgaWYgKHNlbGVjdGVkSW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICAgICAgICBpZiAoIW9wZW4gJiYgb3Blbk9uQXJyb3dLZXlEb3duKSB7XG4gICAgICAgICAgICAgIG9uT3BlbkNoYW5nZSh0cnVlLCBldmVudC5uYXRpdmVFdmVudCwgJ2xpc3QtbmF2aWdhdGlvbicpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb25LZXlEb3duKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgICAgIG9uTmF2aWdhdGUoaW5kZXhSZWYuY3VycmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbkZvY3VzKCkge1xuICAgICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgICBvbk5hdmlnYXRlKG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25Qb2ludGVyRG93bjogY2hlY2tWaXJ0dWFsUG9pbnRlcixcbiAgICAgICAgb25Nb3VzZURvd246IGNoZWNrVmlydHVhbE1vdXNlLFxuICAgICAgICBvbkNsaWNrOiBjaGVja1ZpcnR1YWxNb3VzZVxuICAgICAgfSxcbiAgICAgIGZsb2F0aW5nOiB7XG4gICAgICAgICdhcmlhLW9yaWVudGF0aW9uJzogb3JpZW50YXRpb24gPT09ICdib3RoJyA/IHVuZGVmaW5lZCA6IG9yaWVudGF0aW9uLFxuICAgICAgICAuLi4oIWlzVHlwZWFibGVDb21ib2JveChkb21SZWZlcmVuY2UpICYmIGFyaWFBY3RpdmVEZXNjZW5kYW50UHJvcCksXG4gICAgICAgIG9uS2V5RG93bixcbiAgICAgICAgb25Qb2ludGVyTW92ZSgpIHtcbiAgICAgICAgICBpc1BvaW50ZXJNb2RhbGl0eVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGl0ZW1cbiAgICB9O1xuICB9LCBbZG9tUmVmZXJlbmNlLCByZWZzLCBhY3RpdmVJZCwgdmlydHVhbElkLCBkaXNhYmxlZEluZGljZXNSZWYsIGxhdGVzdE9wZW5SZWYsIGxpc3RSZWYsIGVuYWJsZWQsIG9yaWVudGF0aW9uLCBydGwsIHZpcnR1YWwsIG9wZW4sIGhhc0FjdGl2ZUluZGV4LCBuZXN0ZWQsIHNlbGVjdGVkSW5kZXgsIG9wZW5PbkFycm93S2V5RG93biwgYWxsb3dFc2NhcGUsIGNvbHMsIGxvb3AsIGZvY3VzSXRlbU9uT3Blbiwgb25OYXZpZ2F0ZSwgb25PcGVuQ2hhbmdlLCBpdGVtLCB0cmVlLCB2aXJ0dWFsSXRlbVJlZiwgaXRlbVNpemVzLCBkZW5zZV0pO1xufVxuXG5jb25zdCBjb21wb25lbnRSb2xlVG9BcmlhUm9sZU1hcCA9IC8qI19fUFVSRV9fKi9uZXcgTWFwKFtbJ3NlbGVjdCcsICdsaXN0Ym94J10sIFsnY29tYm9ib3gnLCAnbGlzdGJveCddLCBbJ2xhYmVsJywgZmFsc2VdXSk7XG5cbi8qKlxuICogQWRkcyBiYXNlIHNjcmVlbiByZWFkZXIgcHJvcHMgdG8gdGhlIHJlZmVyZW5jZSBhbmQgZmxvYXRpbmcgZWxlbWVudHMgZm9yIGFcbiAqIGdpdmVuIGZsb2F0aW5nIGVsZW1lbnQgYHJvbGVgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3VzZVJvbGVcbiAqL1xuZnVuY3Rpb24gdXNlUm9sZShjb250ZXh0LCBwcm9wcykge1xuICB2YXIgX2NvbXBvbmVudFJvbGVUb0FyaWFSO1xuICBpZiAocHJvcHMgPT09IHZvaWQgMCkge1xuICAgIHByb3BzID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIG9wZW4sXG4gICAgZmxvYXRpbmdJZFxuICB9ID0gY29udGV4dDtcbiAgY29uc3Qge1xuICAgIGVuYWJsZWQgPSB0cnVlLFxuICAgIHJvbGUgPSAnZGlhbG9nJ1xuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGFyaWFSb2xlID0gKF9jb21wb25lbnRSb2xlVG9BcmlhUiA9IGNvbXBvbmVudFJvbGVUb0FyaWFSb2xlTWFwLmdldChyb2xlKSkgIT0gbnVsbCA/IF9jb21wb25lbnRSb2xlVG9BcmlhUiA6IHJvbGU7XG4gIGNvbnN0IHJlZmVyZW5jZUlkID0gdXNlSWQoKTtcbiAgY29uc3QgcGFyZW50SWQgPSB1c2VGbG9hdGluZ1BhcmVudE5vZGVJZCgpO1xuICBjb25zdCBpc05lc3RlZCA9IHBhcmVudElkICE9IG51bGw7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHJldHVybiB7fTtcbiAgICBjb25zdCBmbG9hdGluZ1Byb3BzID0ge1xuICAgICAgaWQ6IGZsb2F0aW5nSWQsXG4gICAgICAuLi4oYXJpYVJvbGUgJiYge1xuICAgICAgICByb2xlOiBhcmlhUm9sZVxuICAgICAgfSlcbiAgICB9O1xuICAgIGlmIChhcmlhUm9sZSA9PT0gJ3Rvb2x0aXAnIHx8IHJvbGUgPT09ICdsYWJlbCcpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlZmVyZW5jZToge1xuICAgICAgICAgIFtcImFyaWEtXCIgKyAocm9sZSA9PT0gJ2xhYmVsJyA/ICdsYWJlbGxlZGJ5JyA6ICdkZXNjcmliZWRieScpXTogb3BlbiA/IGZsb2F0aW5nSWQgOiB1bmRlZmluZWRcbiAgICAgICAgfSxcbiAgICAgICAgZmxvYXRpbmc6IGZsb2F0aW5nUHJvcHNcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICByZWZlcmVuY2U6IHtcbiAgICAgICAgJ2FyaWEtZXhwYW5kZWQnOiBvcGVuID8gJ3RydWUnIDogJ2ZhbHNlJyxcbiAgICAgICAgJ2FyaWEtaGFzcG9wdXAnOiBhcmlhUm9sZSA9PT0gJ2FsZXJ0ZGlhbG9nJyA/ICdkaWFsb2cnIDogYXJpYVJvbGUsXG4gICAgICAgICdhcmlhLWNvbnRyb2xzJzogb3BlbiA/IGZsb2F0aW5nSWQgOiB1bmRlZmluZWQsXG4gICAgICAgIC4uLihhcmlhUm9sZSA9PT0gJ2xpc3Rib3gnICYmIHtcbiAgICAgICAgICByb2xlOiAnY29tYm9ib3gnXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4oYXJpYVJvbGUgPT09ICdtZW51JyAmJiB7XG4gICAgICAgICAgaWQ6IHJlZmVyZW5jZUlkXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4oYXJpYVJvbGUgPT09ICdtZW51JyAmJiBpc05lc3RlZCAmJiB7XG4gICAgICAgICAgcm9sZTogJ21lbnVpdGVtJ1xuICAgICAgICB9KSxcbiAgICAgICAgLi4uKHJvbGUgPT09ICdzZWxlY3QnICYmIHtcbiAgICAgICAgICAnYXJpYS1hdXRvY29tcGxldGUnOiAnbm9uZSdcbiAgICAgICAgfSksXG4gICAgICAgIC4uLihyb2xlID09PSAnY29tYm9ib3gnICYmIHtcbiAgICAgICAgICAnYXJpYS1hdXRvY29tcGxldGUnOiAnbGlzdCdcbiAgICAgICAgfSlcbiAgICAgIH0sXG4gICAgICBmbG9hdGluZzoge1xuICAgICAgICAuLi5mbG9hdGluZ1Byb3BzLFxuICAgICAgICAuLi4oYXJpYVJvbGUgPT09ICdtZW51JyAmJiB7XG4gICAgICAgICAgJ2FyaWEtbGFiZWxsZWRieSc6IHJlZmVyZW5jZUlkXG4gICAgICAgIH0pXG4gICAgICB9LFxuICAgICAgaXRlbShfcmVmKSB7XG4gICAgICAgIGxldCB7XG4gICAgICAgICAgYWN0aXZlLFxuICAgICAgICAgIHNlbGVjdGVkXG4gICAgICAgIH0gPSBfcmVmO1xuICAgICAgICBjb25zdCBjb21tb25Qcm9wcyA9IHtcbiAgICAgICAgICByb2xlOiAnb3B0aW9uJyxcbiAgICAgICAgICAuLi4oYWN0aXZlICYmIHtcbiAgICAgICAgICAgIGlkOiBmbG9hdGluZ0lkICsgXCItb3B0aW9uXCJcbiAgICAgICAgICB9KVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEZvciBgbWVudWAsIHdlIGFyZSB1bmFibGUgdG8gdGVsbCBpZiB0aGUgaXRlbSBpcyBhIGBtZW51aXRlbXJhZGlvYFxuICAgICAgICAvLyBvciBgbWVudWl0ZW1jaGVja2JveGAuIEZvciBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSByZWFzb25zLCBhbHNvXG4gICAgICAgIC8vIGF2b2lkIGRlZmF1bHRpbmcgdG8gYG1lbnVpdGVtYCBhcyBpdCBtYXkgb3ZlcndyaXRlIGN1c3RvbSByb2xlIHByb3BzLlxuICAgICAgICBzd2l0Y2ggKHJvbGUpIHtcbiAgICAgICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLi4uY29tbW9uUHJvcHMsXG4gICAgICAgICAgICAgICdhcmlhLXNlbGVjdGVkJzogYWN0aXZlICYmIHNlbGVjdGVkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIGNhc2UgJ2NvbWJvYm94JzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5jb21tb25Qcm9wcyxcbiAgICAgICAgICAgICAgICAuLi4oYWN0aXZlICYmIHtcbiAgICAgICAgICAgICAgICAgICdhcmlhLXNlbGVjdGVkJzogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtlbmFibGVkLCByb2xlLCBhcmlhUm9sZSwgb3BlbiwgZmxvYXRpbmdJZCwgcmVmZXJlbmNlSWQsIGlzTmVzdGVkXSk7XG59XG5cbi8vIENvbnZlcnRzIGEgSlMgc3R5bGUga2V5IGxpa2UgYGJhY2tncm91bmRDb2xvcmAgdG8gYSBDU1MgdHJhbnNpdGlvbi1wcm9wZXJ0eVxuLy8gbGlrZSBgYmFja2dyb3VuZC1jb2xvcmAuXG5jb25zdCBjYW1lbENhc2VUb0tlYmFiQ2FzZSA9IHN0ciA9PiBzdHIucmVwbGFjZSgvW0EtWl0rKD8hW2Etel0pfFtBLVpdL2csICgkLCBvZnMpID0+IChvZnMgPyAnLScgOiAnJykgKyAkLnRvTG93ZXJDYXNlKCkpO1xuZnVuY3Rpb24gZXhlY1dpdGhBcmdzT3JSZXR1cm4odmFsdWVPckZuLCBhcmdzKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWVPckZuID09PSAnZnVuY3Rpb24nID8gdmFsdWVPckZuKGFyZ3MpIDogdmFsdWVPckZuO1xufVxuZnVuY3Rpb24gdXNlRGVsYXlVbm1vdW50KG9wZW4sIGR1cmF0aW9uTXMpIHtcbiAgY29uc3QgW2lzTW91bnRlZCwgc2V0SXNNb3VudGVkXSA9IFJlYWN0LnVzZVN0YXRlKG9wZW4pO1xuICBpZiAob3BlbiAmJiAhaXNNb3VudGVkKSB7XG4gICAgc2V0SXNNb3VudGVkKHRydWUpO1xuICB9XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFvcGVuKSB7XG4gICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiBzZXRJc01vdW50ZWQoZmFsc2UpLCBkdXJhdGlvbk1zKTtcbiAgICAgIHJldHVybiAoKSA9PiBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgfVxuICB9LCBbb3BlbiwgZHVyYXRpb25Nc10pO1xuICByZXR1cm4gaXNNb3VudGVkO1xufVxuLyoqXG4gKiBQcm92aWRlcyBhIHN0YXR1cyBzdHJpbmcgdG8gYXBwbHkgQ1NTIHRyYW5zaXRpb25zIHRvIGEgZmxvYXRpbmcgZWxlbWVudCxcbiAqIGNvcnJlY3RseSBoYW5kbGluZyBwbGFjZW1lbnQtYXdhcmUgdHJhbnNpdGlvbnMuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlVHJhbnNpdGlvbiN1c2V0cmFuc2l0aW9uc3RhdHVzXG4gKi9cbmZ1bmN0aW9uIHVzZVRyYW5zaXRpb25TdGF0dXMoY29udGV4dCwgcHJvcHMpIHtcbiAgaWYgKHByb3BzID09PSB2b2lkIDApIHtcbiAgICBwcm9wcyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBvcGVuLFxuICAgIGVsZW1lbnRzOiB7XG4gICAgICBmbG9hdGluZ1xuICAgIH1cbiAgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IHtcbiAgICBkdXJhdGlvbiA9IDI1MFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGlzTnVtYmVyRHVyYXRpb24gPSB0eXBlb2YgZHVyYXRpb24gPT09ICdudW1iZXInO1xuICBjb25zdCBjbG9zZUR1cmF0aW9uID0gKGlzTnVtYmVyRHVyYXRpb24gPyBkdXJhdGlvbiA6IGR1cmF0aW9uLmNsb3NlKSB8fCAwO1xuICBjb25zdCBbaW5pdGlhdGVkLCBzZXRJbml0aWF0ZWRdID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbc3RhdHVzLCBzZXRTdGF0dXNdID0gUmVhY3QudXNlU3RhdGUoJ3VubW91bnRlZCcpO1xuICBjb25zdCBpc01vdW50ZWQgPSB1c2VEZWxheVVubW91bnQob3BlbiwgY2xvc2VEdXJhdGlvbik7XG5cbiAgLy8gYGluaXRpYXRlZGAgY2hlY2sgcHJldmVudHMgdGhpcyBgc2V0U3RhdGVgIGNhbGwgZnJvbSBicmVha2luZ1xuICAvLyA8RmxvYXRpbmdQb3J0YWwgLz4uIFRoaXMgY2FsbCBpcyBuZWNlc3NhcnkgdG8gZW5zdXJlIHN1YnNlcXVlbnQgb3BlbnNcbiAgLy8gYWZ0ZXIgdGhlIGluaXRpYWwgb25lIGFsbG93cyB0aGUgY29ycmVjdCBzaWRlIGFuaW1hdGlvbiB0byBwbGF5IHdoZW4gdGhlXG4gIC8vIHBsYWNlbWVudCBoYXMgY2hhbmdlZC5cbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmIChpbml0aWF0ZWQgJiYgIWlzTW91bnRlZCkge1xuICAgICAgc2V0U3RhdHVzKCd1bm1vdW50ZWQnKTtcbiAgICB9XG4gIH0sIFtpbml0aWF0ZWQsIGlzTW91bnRlZF0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKCFmbG9hdGluZykgcmV0dXJuO1xuICAgIGlmIChvcGVuKSB7XG4gICAgICBzZXRTdGF0dXMoJ2luaXRpYWwnKTtcbiAgICAgIGNvbnN0IGZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgc2V0U3RhdHVzKCdvcGVuJyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGZyYW1lKTtcbiAgICAgIH07XG4gICAgfVxuICAgIHNldEluaXRpYXRlZCh0cnVlKTtcbiAgICBzZXRTdGF0dXMoJ2Nsb3NlJyk7XG4gIH0sIFtvcGVuLCBmbG9hdGluZ10pO1xuICByZXR1cm4ge1xuICAgIGlzTW91bnRlZCxcbiAgICBzdGF0dXNcbiAgfTtcbn1cbi8qKlxuICogUHJvdmlkZXMgc3R5bGVzIHRvIGFwcGx5IENTUyB0cmFuc2l0aW9ucyB0byBhIGZsb2F0aW5nIGVsZW1lbnQsIGNvcnJlY3RseVxuICogaGFuZGxpbmcgcGxhY2VtZW50LWF3YXJlIHRyYW5zaXRpb25zLiBXcmFwcGVyIGFyb3VuZCBgdXNlVHJhbnNpdGlvblN0YXR1c2AuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlVHJhbnNpdGlvbiN1c2V0cmFuc2l0aW9uc3R5bGVzXG4gKi9cbmZ1bmN0aW9uIHVzZVRyYW5zaXRpb25TdHlsZXMoY29udGV4dCwgcHJvcHMpIHtcbiAgaWYgKHByb3BzID09PSB2b2lkIDApIHtcbiAgICBwcm9wcyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBpbml0aWFsOiB1bnN0YWJsZV9pbml0aWFsID0ge1xuICAgICAgb3BhY2l0eTogMFxuICAgIH0sXG4gICAgb3BlbjogdW5zdGFibGVfb3BlbixcbiAgICBjbG9zZTogdW5zdGFibGVfY2xvc2UsXG4gICAgY29tbW9uOiB1bnN0YWJsZV9jb21tb24sXG4gICAgZHVyYXRpb24gPSAyNTBcbiAgfSA9IHByb3BzO1xuICBjb25zdCBwbGFjZW1lbnQgPSBjb250ZXh0LnBsYWNlbWVudDtcbiAgY29uc3Qgc2lkZSA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICBjb25zdCBmbkFyZ3MgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgc2lkZSxcbiAgICBwbGFjZW1lbnRcbiAgfSksIFtzaWRlLCBwbGFjZW1lbnRdKTtcbiAgY29uc3QgaXNOdW1iZXJEdXJhdGlvbiA9IHR5cGVvZiBkdXJhdGlvbiA9PT0gJ251bWJlcic7XG4gIGNvbnN0IG9wZW5EdXJhdGlvbiA9IChpc051bWJlckR1cmF0aW9uID8gZHVyYXRpb24gOiBkdXJhdGlvbi5vcGVuKSB8fCAwO1xuICBjb25zdCBjbG9zZUR1cmF0aW9uID0gKGlzTnVtYmVyRHVyYXRpb24gPyBkdXJhdGlvbiA6IGR1cmF0aW9uLmNsb3NlKSB8fCAwO1xuICBjb25zdCBbc3R5bGVzLCBzZXRTdHlsZXNdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gKHtcbiAgICAuLi5leGVjV2l0aEFyZ3NPclJldHVybih1bnN0YWJsZV9jb21tb24sIGZuQXJncyksXG4gICAgLi4uZXhlY1dpdGhBcmdzT3JSZXR1cm4odW5zdGFibGVfaW5pdGlhbCwgZm5BcmdzKVxuICB9KSk7XG4gIGNvbnN0IHtcbiAgICBpc01vdW50ZWQsXG4gICAgc3RhdHVzXG4gIH0gPSB1c2VUcmFuc2l0aW9uU3RhdHVzKGNvbnRleHQsIHtcbiAgICBkdXJhdGlvblxuICB9KTtcbiAgY29uc3QgaW5pdGlhbFJlZiA9IHVzZUxhdGVzdFJlZih1bnN0YWJsZV9pbml0aWFsKTtcbiAgY29uc3Qgb3BlblJlZiA9IHVzZUxhdGVzdFJlZih1bnN0YWJsZV9vcGVuKTtcbiAgY29uc3QgY2xvc2VSZWYgPSB1c2VMYXRlc3RSZWYodW5zdGFibGVfY2xvc2UpO1xuICBjb25zdCBjb21tb25SZWYgPSB1c2VMYXRlc3RSZWYodW5zdGFibGVfY29tbW9uKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGNvbnN0IGluaXRpYWxTdHlsZXMgPSBleGVjV2l0aEFyZ3NPclJldHVybihpbml0aWFsUmVmLmN1cnJlbnQsIGZuQXJncyk7XG4gICAgY29uc3QgY2xvc2VTdHlsZXMgPSBleGVjV2l0aEFyZ3NPclJldHVybihjbG9zZVJlZi5jdXJyZW50LCBmbkFyZ3MpO1xuICAgIGNvbnN0IGNvbW1vblN0eWxlcyA9IGV4ZWNXaXRoQXJnc09yUmV0dXJuKGNvbW1vblJlZi5jdXJyZW50LCBmbkFyZ3MpO1xuICAgIGNvbnN0IG9wZW5TdHlsZXMgPSBleGVjV2l0aEFyZ3NPclJldHVybihvcGVuUmVmLmN1cnJlbnQsIGZuQXJncykgfHwgT2JqZWN0LmtleXMoaW5pdGlhbFN0eWxlcykucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgICAgYWNjW2tleV0gPSAnJztcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuICAgIGlmIChzdGF0dXMgPT09ICdpbml0aWFsJykge1xuICAgICAgc2V0U3R5bGVzKHN0eWxlcyA9PiAoe1xuICAgICAgICB0cmFuc2l0aW9uUHJvcGVydHk6IHN0eWxlcy50cmFuc2l0aW9uUHJvcGVydHksXG4gICAgICAgIC4uLmNvbW1vblN0eWxlcyxcbiAgICAgICAgLi4uaW5pdGlhbFN0eWxlc1xuICAgICAgfSkpO1xuICAgIH1cbiAgICBpZiAoc3RhdHVzID09PSAnb3BlbicpIHtcbiAgICAgIHNldFN0eWxlcyh7XG4gICAgICAgIHRyYW5zaXRpb25Qcm9wZXJ0eTogT2JqZWN0LmtleXMob3BlblN0eWxlcykubWFwKGNhbWVsQ2FzZVRvS2ViYWJDYXNlKS5qb2luKCcsJyksXG4gICAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogb3BlbkR1cmF0aW9uICsgXCJtc1wiLFxuICAgICAgICAuLi5jb21tb25TdHlsZXMsXG4gICAgICAgIC4uLm9wZW5TdHlsZXNcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc3RhdHVzID09PSAnY2xvc2UnKSB7XG4gICAgICBjb25zdCBzdHlsZXMgPSBjbG9zZVN0eWxlcyB8fCBpbml0aWFsU3R5bGVzO1xuICAgICAgc2V0U3R5bGVzKHtcbiAgICAgICAgdHJhbnNpdGlvblByb3BlcnR5OiBPYmplY3Qua2V5cyhzdHlsZXMpLm1hcChjYW1lbENhc2VUb0tlYmFiQ2FzZSkuam9pbignLCcpLFxuICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb246IGNsb3NlRHVyYXRpb24gKyBcIm1zXCIsXG4gICAgICAgIC4uLmNvbW1vblN0eWxlcyxcbiAgICAgICAgLi4uc3R5bGVzXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFtjbG9zZUR1cmF0aW9uLCBjbG9zZVJlZiwgaW5pdGlhbFJlZiwgb3BlblJlZiwgY29tbW9uUmVmLCBvcGVuRHVyYXRpb24sIHN0YXR1cywgZm5BcmdzXSk7XG4gIHJldHVybiB7XG4gICAgaXNNb3VudGVkLFxuICAgIHN0eWxlc1xuICB9O1xufVxuXG4vKipcbiAqIFByb3ZpZGVzIGEgbWF0Y2hpbmcgY2FsbGJhY2sgdGhhdCBjYW4gYmUgdXNlZCB0byBmb2N1cyBhbiBpdGVtIGFzIHRoZSB1c2VyXG4gKiB0eXBlcywgb2Z0ZW4gdXNlZCBpbiB0YW5kZW0gd2l0aCBgdXNlTGlzdE5hdmlnYXRpb24oKWAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlVHlwZWFoZWFkXG4gKi9cbmZ1bmN0aW9uIHVzZVR5cGVhaGVhZChjb250ZXh0LCBwcm9wcykge1xuICB2YXIgX3JlZjtcbiAgY29uc3Qge1xuICAgIG9wZW4sXG4gICAgZGF0YVJlZlxuICB9ID0gY29udGV4dDtcbiAgY29uc3Qge1xuICAgIGxpc3RSZWYsXG4gICAgYWN0aXZlSW5kZXgsXG4gICAgb25NYXRjaDogdW5zdGFibGVfb25NYXRjaCxcbiAgICBvblR5cGluZ0NoYW5nZTogdW5zdGFibGVfb25UeXBpbmdDaGFuZ2UsXG4gICAgZW5hYmxlZCA9IHRydWUsXG4gICAgZmluZE1hdGNoID0gbnVsbCxcbiAgICByZXNldE1zID0gNzUwLFxuICAgIGlnbm9yZUtleXMgPSBbXSxcbiAgICBzZWxlY3RlZEluZGV4ID0gbnVsbFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHRpbWVvdXRJZFJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICBjb25zdCBzdHJpbmdSZWYgPSBSZWFjdC51c2VSZWYoJycpO1xuICBjb25zdCBwcmV2SW5kZXhSZWYgPSBSZWFjdC51c2VSZWYoKF9yZWYgPSBzZWxlY3RlZEluZGV4ICE9IG51bGwgPyBzZWxlY3RlZEluZGV4IDogYWN0aXZlSW5kZXgpICE9IG51bGwgPyBfcmVmIDogLTEpO1xuICBjb25zdCBtYXRjaEluZGV4UmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBvbk1hdGNoID0gdXNlRWZmZWN0RXZlbnQodW5zdGFibGVfb25NYXRjaCk7XG4gIGNvbnN0IG9uVHlwaW5nQ2hhbmdlID0gdXNlRWZmZWN0RXZlbnQodW5zdGFibGVfb25UeXBpbmdDaGFuZ2UpO1xuICBjb25zdCBmaW5kTWF0Y2hSZWYgPSB1c2VMYXRlc3RSZWYoZmluZE1hdGNoKTtcbiAgY29uc3QgaWdub3JlS2V5c1JlZiA9IHVzZUxhdGVzdFJlZihpZ25vcmVLZXlzKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmIChvcGVuKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkUmVmLmN1cnJlbnQpO1xuICAgICAgbWF0Y2hJbmRleFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIHN0cmluZ1JlZi5jdXJyZW50ID0gJyc7XG4gICAgfVxuICB9LCBbb3Blbl0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgLy8gU3luYyBhcnJvdyBrZXkgbmF2aWdhdGlvbiBidXQgbm90IHR5cGVhaGVhZCBuYXZpZ2F0aW9uLlxuICAgIGlmIChvcGVuICYmIHN0cmluZ1JlZi5jdXJyZW50ID09PSAnJykge1xuICAgICAgdmFyIF9yZWYyO1xuICAgICAgcHJldkluZGV4UmVmLmN1cnJlbnQgPSAoX3JlZjIgPSBzZWxlY3RlZEluZGV4ICE9IG51bGwgPyBzZWxlY3RlZEluZGV4IDogYWN0aXZlSW5kZXgpICE9IG51bGwgPyBfcmVmMiA6IC0xO1xuICAgIH1cbiAgfSwgW29wZW4sIHNlbGVjdGVkSW5kZXgsIGFjdGl2ZUluZGV4XSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0VHlwaW5nQ2hhbmdlKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCFkYXRhUmVmLmN1cnJlbnQudHlwaW5nKSB7XG4gICAgICAgICAgZGF0YVJlZi5jdXJyZW50LnR5cGluZyA9IHZhbHVlO1xuICAgICAgICAgIG9uVHlwaW5nQ2hhbmdlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGRhdGFSZWYuY3VycmVudC50eXBpbmcpIHtcbiAgICAgICAgICBkYXRhUmVmLmN1cnJlbnQudHlwaW5nID0gdmFsdWU7XG4gICAgICAgICAgb25UeXBpbmdDaGFuZ2UodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldE1hdGNoaW5nSW5kZXgobGlzdCwgb3JkZXJlZExpc3QsIHN0cmluZykge1xuICAgICAgY29uc3Qgc3RyID0gZmluZE1hdGNoUmVmLmN1cnJlbnQgPyBmaW5kTWF0Y2hSZWYuY3VycmVudChvcmRlcmVkTGlzdCwgc3RyaW5nKSA6IG9yZGVyZWRMaXN0LmZpbmQodGV4dCA9PiAodGV4dCA9PSBudWxsID8gdm9pZCAwIDogdGV4dC50b0xvY2FsZUxvd2VyQ2FzZSgpLmluZGV4T2Yoc3RyaW5nLnRvTG9jYWxlTG93ZXJDYXNlKCkpKSA9PT0gMCk7XG4gICAgICByZXR1cm4gc3RyID8gbGlzdC5pbmRleE9mKHN0cikgOiAtMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25LZXlEb3duKGV2ZW50KSB7XG4gICAgICBjb25zdCBsaXN0Q29udGVudCA9IGxpc3RSZWYuY3VycmVudDtcbiAgICAgIGlmIChzdHJpbmdSZWYuY3VycmVudC5sZW5ndGggPiAwICYmIHN0cmluZ1JlZi5jdXJyZW50WzBdICE9PSAnICcpIHtcbiAgICAgICAgaWYgKGdldE1hdGNoaW5nSW5kZXgobGlzdENvbnRlbnQsIGxpc3RDb250ZW50LCBzdHJpbmdSZWYuY3VycmVudCkgPT09IC0xKSB7XG4gICAgICAgICAgc2V0VHlwaW5nQ2hhbmdlKGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudC5rZXkgPT09ICcgJykge1xuICAgICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsaXN0Q29udGVudCA9PSBudWxsIHx8IGlnbm9yZUtleXNSZWYuY3VycmVudC5pbmNsdWRlcyhldmVudC5rZXkpIHx8XG4gICAgICAvLyBDaGFyYWN0ZXIga2V5LlxuICAgICAgZXZlbnQua2V5Lmxlbmd0aCAhPT0gMSB8fFxuICAgICAgLy8gTW9kaWZpZXIga2V5LlxuICAgICAgZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5IHx8IGV2ZW50LmFsdEtleSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAob3BlbiAmJiBldmVudC5rZXkgIT09ICcgJykge1xuICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgICBzZXRUeXBpbmdDaGFuZ2UodHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEJhaWwgb3V0IGlmIHRoZSBsaXN0IGNvbnRhaW5zIGEgd29yZCBsaWtlIFwibGxhbWFcIiBvciBcImFhcm9uXCIuIFRPRE86XG4gICAgICAvLyBhbGxvdyBpdCBpbiB0aGlzIGNhc2UsIHRvby5cbiAgICAgIGNvbnN0IGFsbG93UmFwaWRTdWNjZXNzaW9uT2ZGaXJzdExldHRlciA9IGxpc3RDb250ZW50LmV2ZXJ5KHRleHQgPT4ge1xuICAgICAgICB2YXIgX3RleHQkLCBfdGV4dCQyO1xuICAgICAgICByZXR1cm4gdGV4dCA/ICgoX3RleHQkID0gdGV4dFswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90ZXh0JC50b0xvY2FsZUxvd2VyQ2FzZSgpKSAhPT0gKChfdGV4dCQyID0gdGV4dFsxXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90ZXh0JDIudG9Mb2NhbGVMb3dlckNhc2UoKSkgOiB0cnVlO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEFsbG93cyB0aGUgdXNlciB0byBjeWNsZSB0aHJvdWdoIGl0ZW1zIHRoYXQgc3RhcnQgd2l0aCB0aGUgc2FtZSBsZXR0ZXJcbiAgICAgIC8vIGluIHJhcGlkIHN1Y2Nlc3Npb24uXG4gICAgICBpZiAoYWxsb3dSYXBpZFN1Y2Nlc3Npb25PZkZpcnN0TGV0dGVyICYmIHN0cmluZ1JlZi5jdXJyZW50ID09PSBldmVudC5rZXkpIHtcbiAgICAgICAgc3RyaW5nUmVmLmN1cnJlbnQgPSAnJztcbiAgICAgICAgcHJldkluZGV4UmVmLmN1cnJlbnQgPSBtYXRjaEluZGV4UmVmLmN1cnJlbnQ7XG4gICAgICB9XG4gICAgICBzdHJpbmdSZWYuY3VycmVudCArPSBldmVudC5rZXk7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkUmVmLmN1cnJlbnQpO1xuICAgICAgdGltZW91dElkUmVmLmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgc3RyaW5nUmVmLmN1cnJlbnQgPSAnJztcbiAgICAgICAgcHJldkluZGV4UmVmLmN1cnJlbnQgPSBtYXRjaEluZGV4UmVmLmN1cnJlbnQ7XG4gICAgICAgIHNldFR5cGluZ0NoYW5nZShmYWxzZSk7XG4gICAgICB9LCByZXNldE1zKTtcbiAgICAgIGNvbnN0IHByZXZJbmRleCA9IHByZXZJbmRleFJlZi5jdXJyZW50O1xuICAgICAgY29uc3QgaW5kZXggPSBnZXRNYXRjaGluZ0luZGV4KGxpc3RDb250ZW50LCBbLi4ubGlzdENvbnRlbnQuc2xpY2UoKHByZXZJbmRleCB8fCAwKSArIDEpLCAuLi5saXN0Q29udGVudC5zbGljZSgwLCAocHJldkluZGV4IHx8IDApICsgMSldLCBzdHJpbmdSZWYuY3VycmVudCk7XG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIG9uTWF0Y2goaW5kZXgpO1xuICAgICAgICBtYXRjaEluZGV4UmVmLmN1cnJlbnQgPSBpbmRleDtcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5ICE9PSAnICcpIHtcbiAgICAgICAgc3RyaW5nUmVmLmN1cnJlbnQgPSAnJztcbiAgICAgICAgc2V0VHlwaW5nQ2hhbmdlKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZmVyZW5jZToge1xuICAgICAgICBvbktleURvd25cbiAgICAgIH0sXG4gICAgICBmbG9hdGluZzoge1xuICAgICAgICBvbktleURvd24sXG4gICAgICAgIG9uS2V5VXAoZXZlbnQpIHtcbiAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnICcpIHtcbiAgICAgICAgICAgIHNldFR5cGluZ0NoYW5nZShmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2VuYWJsZWQsIG9wZW4sIGRhdGFSZWYsIGxpc3RSZWYsIHJlc2V0TXMsIGlnbm9yZUtleXNSZWYsIGZpbmRNYXRjaFJlZiwgb25NYXRjaCwgb25UeXBpbmdDaGFuZ2VdKTtcbn1cblxuZnVuY3Rpb24gZ2V0QXJnc1dpdGhDdXN0b21GbG9hdGluZ0hlaWdodChzdGF0ZSwgaGVpZ2h0KSB7XG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgcmVjdHM6IHtcbiAgICAgIC4uLnN0YXRlLnJlY3RzLFxuICAgICAgZmxvYXRpbmc6IHtcbiAgICAgICAgLi4uc3RhdGUucmVjdHMuZmxvYXRpbmcsXG4gICAgICAgIGhlaWdodFxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbi8qKlxuICogUG9zaXRpb25zIHRoZSBmbG9hdGluZyBlbGVtZW50IHN1Y2ggdGhhdCBhbiBpbm5lciBlbGVtZW50IGluc2lkZVxuICogb2YgaXQgaXMgYW5jaG9yZWQgdG8gdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2lubmVyXG4gKi9cbmNvbnN0IGlubmVyID0gcHJvcHMgPT4gKHtcbiAgbmFtZTogJ2lubmVyJyxcbiAgb3B0aW9uczogcHJvcHMsXG4gIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgY29uc3Qge1xuICAgICAgbGlzdFJlZixcbiAgICAgIG92ZXJmbG93UmVmLFxuICAgICAgb25GYWxsYmFja0NoYW5nZSxcbiAgICAgIG9mZnNldDogaW5uZXJPZmZzZXQgPSAwLFxuICAgICAgaW5kZXggPSAwLFxuICAgICAgbWluSXRlbXNWaXNpYmxlID0gNCxcbiAgICAgIHJlZmVyZW5jZU92ZXJmbG93VGhyZXNob2xkID0gMCxcbiAgICAgIHNjcm9sbFJlZixcbiAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9uc1xuICAgIH0gPSBwcm9wcztcbiAgICBjb25zdCB7XG4gICAgICByZWN0cyxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIGZsb2F0aW5nXG4gICAgICB9XG4gICAgfSA9IHN0YXRlO1xuICAgIGNvbnN0IGl0ZW0gPSBsaXN0UmVmLmN1cnJlbnRbaW5kZXhdO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGlmICghc3RhdGUucGxhY2VtZW50LnN0YXJ0c1dpdGgoJ2JvdHRvbScpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihbJ0Zsb2F0aW5nIFVJOiBgcGxhY2VtZW50YCBzaWRlIG11c3QgYmUgXCJib3R0b21cIiB3aGVuIHVzaW5nIHRoZScsICdgaW5uZXJgIG1pZGRsZXdhcmUuJ10uam9pbignICcpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpdGVtKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGNvbnN0IG5leHRBcmdzID0ge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICAuLi4oYXdhaXQgb2Zmc2V0KC1pdGVtLm9mZnNldFRvcCAtIGZsb2F0aW5nLmNsaWVudFRvcCAtIHJlY3RzLnJlZmVyZW5jZS5oZWlnaHQgLyAyIC0gaXRlbS5vZmZzZXRIZWlnaHQgLyAyIC0gaW5uZXJPZmZzZXQpLmZuKHN0YXRlKSlcbiAgICB9O1xuICAgIGNvbnN0IGVsID0gKHNjcm9sbFJlZiA9PSBudWxsID8gdm9pZCAwIDogc2Nyb2xsUmVmLmN1cnJlbnQpIHx8IGZsb2F0aW5nO1xuICAgIGNvbnN0IG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coZ2V0QXJnc1dpdGhDdXN0b21GbG9hdGluZ0hlaWdodChuZXh0QXJncywgZWwuc2Nyb2xsSGVpZ2h0KSwgZGV0ZWN0T3ZlcmZsb3dPcHRpb25zKTtcbiAgICBjb25zdCByZWZPdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KG5leHRBcmdzLCB7XG4gICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnMsXG4gICAgICBlbGVtZW50Q29udGV4dDogJ3JlZmVyZW5jZSdcbiAgICB9KTtcbiAgICBjb25zdCBkaWZmWSA9IE1hdGgubWF4KDAsIG92ZXJmbG93LnRvcCk7XG4gICAgY29uc3QgbmV4dFkgPSBuZXh0QXJncy55ICsgZGlmZlk7XG4gICAgY29uc3QgbWF4SGVpZ2h0ID0gTWF0aC5tYXgoMCwgZWwuc2Nyb2xsSGVpZ2h0IC0gZGlmZlkgLSBNYXRoLm1heCgwLCBvdmVyZmxvdy5ib3R0b20pKTtcbiAgICBlbC5zdHlsZS5tYXhIZWlnaHQgPSBtYXhIZWlnaHQgKyBcInB4XCI7XG4gICAgZWwuc2Nyb2xsVG9wID0gZGlmZlk7XG5cbiAgICAvLyBUaGVyZSBpcyBub3QgZW5vdWdoIHNwYWNlLCBmYWxsYmFjayB0byBzdGFuZGFyZCBhbmNob3JlZCBwb3NpdGlvbmluZ1xuICAgIGlmIChvbkZhbGxiYWNrQ2hhbmdlKSB7XG4gICAgICBpZiAoZWwub2Zmc2V0SGVpZ2h0IDwgaXRlbS5vZmZzZXRIZWlnaHQgKiBNYXRoLm1pbihtaW5JdGVtc1Zpc2libGUsIGxpc3RSZWYuY3VycmVudC5sZW5ndGggLSAxKSAtIDEgfHwgcmVmT3ZlcmZsb3cudG9wID49IC1yZWZlcmVuY2VPdmVyZmxvd1RocmVzaG9sZCB8fCByZWZPdmVyZmxvdy5ib3R0b20gPj0gLXJlZmVyZW5jZU92ZXJmbG93VGhyZXNob2xkKSB7XG4gICAgICAgIGZsdXNoU3luYygoKSA9PiBvbkZhbGxiYWNrQ2hhbmdlKHRydWUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZsdXNoU3luYygoKSA9PiBvbkZhbGxiYWNrQ2hhbmdlKGZhbHNlKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvdmVyZmxvd1JlZikge1xuICAgICAgb3ZlcmZsb3dSZWYuY3VycmVudCA9IGF3YWl0IGRldGVjdE92ZXJmbG93KGdldEFyZ3NXaXRoQ3VzdG9tRmxvYXRpbmdIZWlnaHQoe1xuICAgICAgICAuLi5uZXh0QXJncyxcbiAgICAgICAgeTogbmV4dFlcbiAgICAgIH0sIGVsLm9mZnNldEhlaWdodCksIGRldGVjdE92ZXJmbG93T3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB5OiBuZXh0WVxuICAgIH07XG4gIH1cbn0pO1xuLyoqXG4gKiBDaGFuZ2VzIHRoZSBgaW5uZXJgIG1pZGRsZXdhcmUncyBgb2Zmc2V0YCB1cG9uIGEgYHdoZWVsYCBldmVudCB0b1xuICogZXhwYW5kIHRoZSBmbG9hdGluZyBlbGVtZW50J3MgaGVpZ2h0LCByZXZlYWxpbmcgbW9yZSBsaXN0IGl0ZW1zLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2lubmVyXG4gKi9cbmZ1bmN0aW9uIHVzZUlubmVyT2Zmc2V0KGNvbnRleHQsIHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBvcGVuLFxuICAgIGVsZW1lbnRzXG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCB7XG4gICAgZW5hYmxlZCA9IHRydWUsXG4gICAgb3ZlcmZsb3dSZWYsXG4gICAgc2Nyb2xsUmVmLFxuICAgIG9uQ2hhbmdlOiB1bnN0YWJsZV9vbkNoYW5nZVxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IG9uQ2hhbmdlID0gdXNlRWZmZWN0RXZlbnQodW5zdGFibGVfb25DaGFuZ2UpO1xuICBjb25zdCBjb250cm9sbGVkU2Nyb2xsaW5nUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgcHJldlNjcm9sbFRvcFJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgaW5pdGlhbE92ZXJmbG93UmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbldoZWVsKGUpIHtcbiAgICAgIGlmIChlLmN0cmxLZXkgfHwgIWVsIHx8IG92ZXJmbG93UmVmLmN1cnJlbnQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBkWSA9IGUuZGVsdGFZO1xuICAgICAgY29uc3QgaXNBdFRvcCA9IG92ZXJmbG93UmVmLmN1cnJlbnQudG9wID49IC0wLjU7XG4gICAgICBjb25zdCBpc0F0Qm90dG9tID0gb3ZlcmZsb3dSZWYuY3VycmVudC5ib3R0b20gPj0gLTAuNTtcbiAgICAgIGNvbnN0IHJlbWFpbmluZ1Njcm9sbCA9IGVsLnNjcm9sbEhlaWdodCAtIGVsLmNsaWVudEhlaWdodDtcbiAgICAgIGNvbnN0IHNpZ24gPSBkWSA8IDAgPyAtMSA6IDE7XG4gICAgICBjb25zdCBtZXRob2QgPSBkWSA8IDAgPyAnbWF4JyA6ICdtaW4nO1xuICAgICAgaWYgKGVsLnNjcm9sbEhlaWdodCA8PSBlbC5jbGllbnRIZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0F0VG9wICYmIGRZID4gMCB8fCAhaXNBdEJvdHRvbSAmJiBkWSA8IDApIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBmbHVzaFN5bmMoKCkgPT4ge1xuICAgICAgICAgIG9uQ2hhbmdlKGQgPT4gZCArIE1hdGhbbWV0aG9kXShkWSwgcmVtYWluaW5nU2Nyb2xsICogc2lnbikpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoL2ZpcmVmb3gvaS50ZXN0KGdldFVzZXJBZ2VudCgpKSkge1xuICAgICAgICAvLyBOZWVkZWQgdG8gcHJvcGFnYXRlIHNjcm9sbGluZyBkdXJpbmcgbW9tZW50dW0gc2Nyb2xsaW5nIHBoYXNlIG9uY2VcbiAgICAgICAgLy8gaXQgZ2V0cyBsaW1pdGVkIGJ5IHRoZSBib3VuZGFyeS4gVVggaW1wcm92ZW1lbnQsIG5vdCBjcml0aWNhbC5cbiAgICAgICAgZWwuc2Nyb2xsVG9wICs9IGRZO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBlbCA9IChzY3JvbGxSZWYgPT0gbnVsbCA/IHZvaWQgMCA6IHNjcm9sbFJlZi5jdXJyZW50KSB8fCBlbGVtZW50cy5mbG9hdGluZztcbiAgICBpZiAob3BlbiAmJiBlbCkge1xuICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCBvbldoZWVsKTtcblxuICAgICAgLy8gV2FpdCBmb3IgdGhlIHBvc2l0aW9uIHRvIGJlIHJlYWR5LlxuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgcHJldlNjcm9sbFRvcFJlZi5jdXJyZW50ID0gZWwuc2Nyb2xsVG9wO1xuICAgICAgICBpZiAob3ZlcmZsb3dSZWYuY3VycmVudCAhPSBudWxsKSB7XG4gICAgICAgICAgaW5pdGlhbE92ZXJmbG93UmVmLmN1cnJlbnQgPSB7XG4gICAgICAgICAgICAuLi5vdmVyZmxvd1JlZi5jdXJyZW50XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBwcmV2U2Nyb2xsVG9wUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICBpbml0aWFsT3ZlcmZsb3dSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3doZWVsJywgb25XaGVlbCk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW2VuYWJsZWQsIG9wZW4sIGVsZW1lbnRzLmZsb2F0aW5nLCBvdmVyZmxvd1JlZiwgc2Nyb2xsUmVmLCBvbkNoYW5nZV0pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBmbG9hdGluZzoge1xuICAgICAgICBvbktleURvd24oKSB7XG4gICAgICAgICAgY29udHJvbGxlZFNjcm9sbGluZ1JlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgb25XaGVlbCgpIHtcbiAgICAgICAgICBjb250cm9sbGVkU2Nyb2xsaW5nUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Qb2ludGVyTW92ZSgpIHtcbiAgICAgICAgICBjb250cm9sbGVkU2Nyb2xsaW5nUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgb25TY3JvbGwoKSB7XG4gICAgICAgICAgY29uc3QgZWwgPSAoc2Nyb2xsUmVmID09IG51bGwgPyB2b2lkIDAgOiBzY3JvbGxSZWYuY3VycmVudCkgfHwgZWxlbWVudHMuZmxvYXRpbmc7XG4gICAgICAgICAgaWYgKCFvdmVyZmxvd1JlZi5jdXJyZW50IHx8ICFlbCB8fCAhY29udHJvbGxlZFNjcm9sbGluZ1JlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcmV2U2Nyb2xsVG9wUmVmLmN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjcm9sbERpZmYgPSBlbC5zY3JvbGxUb3AgLSBwcmV2U2Nyb2xsVG9wUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICBpZiAob3ZlcmZsb3dSZWYuY3VycmVudC5ib3R0b20gPCAtMC41ICYmIHNjcm9sbERpZmYgPCAtMSB8fCBvdmVyZmxvd1JlZi5jdXJyZW50LnRvcCA8IC0wLjUgJiYgc2Nyb2xsRGlmZiA+IDEpIHtcbiAgICAgICAgICAgICAgZmx1c2hTeW5jKCgpID0+IG9uQ2hhbmdlKGQgPT4gZCArIHNjcm9sbERpZmYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBbRmlyZWZveF0gV2FpdCBmb3IgdGhlIGhlaWdodCBjaGFuZ2UgdG8gaGF2ZSBiZWVuIGFwcGxpZWQuXG4gICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIHByZXZTY3JvbGxUb3BSZWYuY3VycmVudCA9IGVsLnNjcm9sbFRvcDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0sIFtlbmFibGVkLCBvdmVyZmxvd1JlZiwgZWxlbWVudHMuZmxvYXRpbmcsIHNjcm9sbFJlZiwgb25DaGFuZ2VdKTtcbn1cblxuZnVuY3Rpb24gaXNQb2ludEluUG9seWdvbihwb2ludCwgcG9seWdvbikge1xuICBjb25zdCBbeCwgeV0gPSBwb2ludDtcbiAgbGV0IGlzSW5zaWRlID0gZmFsc2U7XG4gIGNvbnN0IGxlbmd0aCA9IHBvbHlnb24ubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMCwgaiA9IGxlbmd0aCAtIDE7IGkgPCBsZW5ndGg7IGogPSBpKyspIHtcbiAgICBjb25zdCBbeGksIHlpXSA9IHBvbHlnb25baV0gfHwgWzAsIDBdO1xuICAgIGNvbnN0IFt4aiwgeWpdID0gcG9seWdvbltqXSB8fCBbMCwgMF07XG4gICAgY29uc3QgaW50ZXJzZWN0ID0geWkgPj0geSAhPT0geWogPj0geSAmJiB4IDw9ICh4aiAtIHhpKSAqICh5IC0geWkpIC8gKHlqIC0geWkpICsgeGk7XG4gICAgaWYgKGludGVyc2VjdCkge1xuICAgICAgaXNJbnNpZGUgPSAhaXNJbnNpZGU7XG4gICAgfVxuICB9XG4gIHJldHVybiBpc0luc2lkZTtcbn1cbmZ1bmN0aW9uIGlzSW5zaWRlKHBvaW50LCByZWN0KSB7XG4gIHJldHVybiBwb2ludFswXSA+PSByZWN0LnggJiYgcG9pbnRbMF0gPD0gcmVjdC54ICsgcmVjdC53aWR0aCAmJiBwb2ludFsxXSA+PSByZWN0LnkgJiYgcG9pbnRbMV0gPD0gcmVjdC55ICsgcmVjdC5oZWlnaHQ7XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhIHNhZmUgcG9seWdvbiBhcmVhIHRoYXQgdGhlIHVzZXIgY2FuIHRyYXZlcnNlIHdpdGhvdXQgY2xvc2luZyB0aGVcbiAqIGZsb2F0aW5nIGVsZW1lbnQgb25jZSBsZWF2aW5nIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VIb3ZlciNzYWZlcG9seWdvblxuICovXG5mdW5jdGlvbiBzYWZlUG9seWdvbihvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIGJ1ZmZlciA9IDAuNSxcbiAgICBibG9ja1BvaW50ZXJFdmVudHMgPSBmYWxzZSxcbiAgICByZXF1aXJlSW50ZW50ID0gdHJ1ZVxuICB9ID0gb3B0aW9ucztcbiAgbGV0IHRpbWVvdXRJZDtcbiAgbGV0IGhhc0xhbmRlZCA9IGZhbHNlO1xuICBsZXQgbGFzdFggPSBudWxsO1xuICBsZXQgbGFzdFkgPSBudWxsO1xuICBsZXQgbGFzdEN1cnNvclRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgZnVuY3Rpb24gZ2V0Q3Vyc29yU3BlZWQoeCwgeSkge1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgY29uc3QgZWxhcHNlZFRpbWUgPSBjdXJyZW50VGltZSAtIGxhc3RDdXJzb3JUaW1lO1xuICAgIGlmIChsYXN0WCA9PT0gbnVsbCB8fCBsYXN0WSA9PT0gbnVsbCB8fCBlbGFwc2VkVGltZSA9PT0gMCkge1xuICAgICAgbGFzdFggPSB4O1xuICAgICAgbGFzdFkgPSB5O1xuICAgICAgbGFzdEN1cnNvclRpbWUgPSBjdXJyZW50VGltZTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBkZWx0YVggPSB4IC0gbGFzdFg7XG4gICAgY29uc3QgZGVsdGFZID0geSAtIGxhc3RZO1xuICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KGRlbHRhWCAqIGRlbHRhWCArIGRlbHRhWSAqIGRlbHRhWSk7XG4gICAgY29uc3Qgc3BlZWQgPSBkaXN0YW5jZSAvIGVsYXBzZWRUaW1lOyAvLyBweCAvIG1zXG5cbiAgICBsYXN0WCA9IHg7XG4gICAgbGFzdFkgPSB5O1xuICAgIGxhc3RDdXJzb3JUaW1lID0gY3VycmVudFRpbWU7XG4gICAgcmV0dXJuIHNwZWVkO1xuICB9XG4gIGNvbnN0IGZuID0gX3JlZiA9PiB7XG4gICAgbGV0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgcGxhY2VtZW50LFxuICAgICAgZWxlbWVudHMsXG4gICAgICBvbkNsb3NlLFxuICAgICAgbm9kZUlkLFxuICAgICAgdHJlZVxuICAgIH0gPSBfcmVmO1xuICAgIHJldHVybiBmdW5jdGlvbiBvbk1vdXNlTW92ZShldmVudCkge1xuICAgICAgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICBvbkNsb3NlKCk7XG4gICAgICB9XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgIGlmICghZWxlbWVudHMuZG9tUmVmZXJlbmNlIHx8ICFlbGVtZW50cy5mbG9hdGluZyB8fCBwbGFjZW1lbnQgPT0gbnVsbCB8fCB4ID09IG51bGwgfHwgeSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY2xpZW50WCxcbiAgICAgICAgY2xpZW50WVxuICAgICAgfSA9IGV2ZW50O1xuICAgICAgY29uc3QgY2xpZW50UG9pbnQgPSBbY2xpZW50WCwgY2xpZW50WV07XG4gICAgICBjb25zdCB0YXJnZXQgPSBnZXRUYXJnZXQoZXZlbnQpO1xuICAgICAgY29uc3QgaXNMZWF2ZSA9IGV2ZW50LnR5cGUgPT09ICdtb3VzZWxlYXZlJztcbiAgICAgIGNvbnN0IGlzT3ZlckZsb2F0aW5nRWwgPSBjb250YWlucyhlbGVtZW50cy5mbG9hdGluZywgdGFyZ2V0KTtcbiAgICAgIGNvbnN0IGlzT3ZlclJlZmVyZW5jZUVsID0gY29udGFpbnMoZWxlbWVudHMuZG9tUmVmZXJlbmNlLCB0YXJnZXQpO1xuICAgICAgY29uc3QgcmVmUmVjdCA9IGVsZW1lbnRzLmRvbVJlZmVyZW5jZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IHJlY3QgPSBlbGVtZW50cy5mbG9hdGluZy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IHNpZGUgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgICAgIGNvbnN0IGN1cnNvckxlYXZlRnJvbVJpZ2h0ID0geCA+IHJlY3QucmlnaHQgLSByZWN0LndpZHRoIC8gMjtcbiAgICAgIGNvbnN0IGN1cnNvckxlYXZlRnJvbUJvdHRvbSA9IHkgPiByZWN0LmJvdHRvbSAtIHJlY3QuaGVpZ2h0IC8gMjtcbiAgICAgIGNvbnN0IGlzT3ZlclJlZmVyZW5jZVJlY3QgPSBpc0luc2lkZShjbGllbnRQb2ludCwgcmVmUmVjdCk7XG4gICAgICBjb25zdCBpc0Zsb2F0aW5nV2lkZXIgPSByZWN0LndpZHRoID4gcmVmUmVjdC53aWR0aDtcbiAgICAgIGNvbnN0IGlzRmxvYXRpbmdUYWxsZXIgPSByZWN0LmhlaWdodCA+IHJlZlJlY3QuaGVpZ2h0O1xuICAgICAgY29uc3QgbGVmdCA9IChpc0Zsb2F0aW5nV2lkZXIgPyByZWZSZWN0IDogcmVjdCkubGVmdDtcbiAgICAgIGNvbnN0IHJpZ2h0ID0gKGlzRmxvYXRpbmdXaWRlciA/IHJlZlJlY3QgOiByZWN0KS5yaWdodDtcbiAgICAgIGNvbnN0IHRvcCA9IChpc0Zsb2F0aW5nVGFsbGVyID8gcmVmUmVjdCA6IHJlY3QpLnRvcDtcbiAgICAgIGNvbnN0IGJvdHRvbSA9IChpc0Zsb2F0aW5nVGFsbGVyID8gcmVmUmVjdCA6IHJlY3QpLmJvdHRvbTtcbiAgICAgIGlmIChpc092ZXJGbG9hdGluZ0VsKSB7XG4gICAgICAgIGhhc0xhbmRlZCA9IHRydWU7XG4gICAgICAgIGlmICghaXNMZWF2ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzT3ZlclJlZmVyZW5jZUVsKSB7XG4gICAgICAgIGhhc0xhbmRlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGlzT3ZlclJlZmVyZW5jZUVsICYmICFpc0xlYXZlKSB7XG4gICAgICAgIGhhc0xhbmRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gUHJldmVudCBvdmVybGFwcGluZyBmbG9hdGluZyBlbGVtZW50IGZyb20gYmVpbmcgc3R1Y2sgaW4gYW4gb3Blbi1jbG9zZVxuICAgICAgLy8gbG9vcDogaHR0cHM6Ly9naXRodWIuY29tL2Zsb2F0aW5nLXVpL2Zsb2F0aW5nLXVpL2lzc3Vlcy8xOTEwXG4gICAgICBpZiAoaXNMZWF2ZSAmJiBpc0VsZW1lbnQoZXZlbnQucmVsYXRlZFRhcmdldCkgJiYgY29udGFpbnMoZWxlbWVudHMuZmxvYXRpbmcsIGV2ZW50LnJlbGF0ZWRUYXJnZXQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgYW55IG5lc3RlZCBjaGlsZCBpcyBvcGVuLCBhYm9ydC5cbiAgICAgIGlmICh0cmVlICYmIGdldENoaWxkcmVuKHRyZWUubm9kZXNSZWYuY3VycmVudCwgbm9kZUlkKS5zb21lKF9yZWYyID0+IHtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBjb250ZXh0XG4gICAgICAgIH0gPSBfcmVmMjtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRleHQub3BlbjtcbiAgICAgIH0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIHBvaW50ZXIgaXMgbGVhdmluZyBmcm9tIHRoZSBvcHBvc2l0ZSBzaWRlLCB0aGUgXCJidWZmZXJcIiBsb2dpY1xuICAgICAgLy8gY3JlYXRlcyBhIHBvaW50IHdoZXJlIHRoZSBmbG9hdGluZyBlbGVtZW50IHJlbWFpbnMgb3BlbiwgYnV0IHNob3VsZCBiZVxuICAgICAgLy8gaWdub3JlZC5cbiAgICAgIC8vIEEgY29uc3RhbnQgb2YgMSBoYW5kbGVzIGZsb2F0aW5nIHBvaW50IHJvdW5kaW5nIGVycm9ycy5cbiAgICAgIGlmIChzaWRlID09PSAndG9wJyAmJiB5ID49IHJlZlJlY3QuYm90dG9tIC0gMSB8fCBzaWRlID09PSAnYm90dG9tJyAmJiB5IDw9IHJlZlJlY3QudG9wICsgMSB8fCBzaWRlID09PSAnbGVmdCcgJiYgeCA+PSByZWZSZWN0LnJpZ2h0IC0gMSB8fCBzaWRlID09PSAncmlnaHQnICYmIHggPD0gcmVmUmVjdC5sZWZ0ICsgMSkge1xuICAgICAgICByZXR1cm4gY2xvc2UoKTtcbiAgICAgIH1cblxuICAgICAgLy8gSWdub3JlIHdoZW4gdGhlIGN1cnNvciBpcyB3aXRoaW4gdGhlIHJlY3Rhbmd1bGFyIHRyb3VnaCBiZXR3ZWVuIHRoZVxuICAgICAgLy8gdHdvIGVsZW1lbnRzLiBTaW5jZSB0aGUgdHJpYW5nbGUgaXMgY3JlYXRlZCBmcm9tIHRoZSBjdXJzb3IgcG9pbnQsXG4gICAgICAvLyB3aGljaCBjYW4gc3RhcnQgYmV5b25kIHRoZSByZWYgZWxlbWVudCdzIGVkZ2UsIHRyYXZlcnNpbmcgYmFjayBhbmRcbiAgICAgIC8vIGZvcnRoIGZyb20gdGhlIHJlZiB0byB0aGUgZmxvYXRpbmcgZWxlbWVudCBjYW4gY2F1c2UgaXQgdG8gY2xvc2UuIFRoaXNcbiAgICAgIC8vIGVuc3VyZXMgaXQgYWx3YXlzIHJlbWFpbnMgb3BlbiBpbiB0aGF0IGNhc2UuXG4gICAgICBsZXQgcmVjdFBvbHkgPSBbXTtcbiAgICAgIHN3aXRjaCAoc2lkZSkge1xuICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgIHJlY3RQb2x5ID0gW1tsZWZ0LCByZWZSZWN0LnRvcCArIDFdLCBbbGVmdCwgcmVjdC5ib3R0b20gLSAxXSwgW3JpZ2h0LCByZWN0LmJvdHRvbSAtIDFdLCBbcmlnaHQsIHJlZlJlY3QudG9wICsgMV1dO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgIHJlY3RQb2x5ID0gW1tsZWZ0LCByZWN0LnRvcCArIDFdLCBbbGVmdCwgcmVmUmVjdC5ib3R0b20gLSAxXSwgW3JpZ2h0LCByZWZSZWN0LmJvdHRvbSAtIDFdLCBbcmlnaHQsIHJlY3QudG9wICsgMV1dO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICByZWN0UG9seSA9IFtbcmVjdC5yaWdodCAtIDEsIGJvdHRvbV0sIFtyZWN0LnJpZ2h0IC0gMSwgdG9wXSwgW3JlZlJlY3QubGVmdCArIDEsIHRvcF0sIFtyZWZSZWN0LmxlZnQgKyAxLCBib3R0b21dXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgIHJlY3RQb2x5ID0gW1tyZWZSZWN0LnJpZ2h0IC0gMSwgYm90dG9tXSwgW3JlZlJlY3QucmlnaHQgLSAxLCB0b3BdLCBbcmVjdC5sZWZ0ICsgMSwgdG9wXSwgW3JlY3QubGVmdCArIDEsIGJvdHRvbV1dO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZ2V0UG9seWdvbihfcmVmMykge1xuICAgICAgICBsZXQgW3gsIHldID0gX3JlZjM7XG4gICAgICAgIHN3aXRjaCAoc2lkZSkge1xuICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IGN1cnNvclBvaW50T25lID0gW2lzRmxvYXRpbmdXaWRlciA/IHggKyBidWZmZXIgLyAyIDogY3Vyc29yTGVhdmVGcm9tUmlnaHQgPyB4ICsgYnVmZmVyICogNCA6IHggLSBidWZmZXIgKiA0LCB5ICsgYnVmZmVyICsgMV07XG4gICAgICAgICAgICAgIGNvbnN0IGN1cnNvclBvaW50VHdvID0gW2lzRmxvYXRpbmdXaWRlciA/IHggLSBidWZmZXIgLyAyIDogY3Vyc29yTGVhdmVGcm9tUmlnaHQgPyB4ICsgYnVmZmVyICogNCA6IHggLSBidWZmZXIgKiA0LCB5ICsgYnVmZmVyICsgMV07XG4gICAgICAgICAgICAgIGNvbnN0IGNvbW1vblBvaW50cyA9IFtbcmVjdC5sZWZ0LCBjdXJzb3JMZWF2ZUZyb21SaWdodCA/IHJlY3QuYm90dG9tIC0gYnVmZmVyIDogaXNGbG9hdGluZ1dpZGVyID8gcmVjdC5ib3R0b20gLSBidWZmZXIgOiByZWN0LnRvcF0sIFtyZWN0LnJpZ2h0LCBjdXJzb3JMZWF2ZUZyb21SaWdodCA/IGlzRmxvYXRpbmdXaWRlciA/IHJlY3QuYm90dG9tIC0gYnVmZmVyIDogcmVjdC50b3AgOiByZWN0LmJvdHRvbSAtIGJ1ZmZlcl1dO1xuICAgICAgICAgICAgICByZXR1cm4gW2N1cnNvclBvaW50T25lLCBjdXJzb3JQb2ludFR3bywgLi4uY29tbW9uUG9pbnRzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb25zdCBjdXJzb3JQb2ludE9uZSA9IFtpc0Zsb2F0aW5nV2lkZXIgPyB4ICsgYnVmZmVyIC8gMiA6IGN1cnNvckxlYXZlRnJvbVJpZ2h0ID8geCArIGJ1ZmZlciAqIDQgOiB4IC0gYnVmZmVyICogNCwgeSAtIGJ1ZmZlcl07XG4gICAgICAgICAgICAgIGNvbnN0IGN1cnNvclBvaW50VHdvID0gW2lzRmxvYXRpbmdXaWRlciA/IHggLSBidWZmZXIgLyAyIDogY3Vyc29yTGVhdmVGcm9tUmlnaHQgPyB4ICsgYnVmZmVyICogNCA6IHggLSBidWZmZXIgKiA0LCB5IC0gYnVmZmVyXTtcbiAgICAgICAgICAgICAgY29uc3QgY29tbW9uUG9pbnRzID0gW1tyZWN0LmxlZnQsIGN1cnNvckxlYXZlRnJvbVJpZ2h0ID8gcmVjdC50b3AgKyBidWZmZXIgOiBpc0Zsb2F0aW5nV2lkZXIgPyByZWN0LnRvcCArIGJ1ZmZlciA6IHJlY3QuYm90dG9tXSwgW3JlY3QucmlnaHQsIGN1cnNvckxlYXZlRnJvbVJpZ2h0ID8gaXNGbG9hdGluZ1dpZGVyID8gcmVjdC50b3AgKyBidWZmZXIgOiByZWN0LmJvdHRvbSA6IHJlY3QudG9wICsgYnVmZmVyXV07XG4gICAgICAgICAgICAgIHJldHVybiBbY3Vyc29yUG9pbnRPbmUsIGN1cnNvclBvaW50VHdvLCAuLi5jb21tb25Qb2ludHNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb25zdCBjdXJzb3JQb2ludE9uZSA9IFt4ICsgYnVmZmVyICsgMSwgaXNGbG9hdGluZ1RhbGxlciA/IHkgKyBidWZmZXIgLyAyIDogY3Vyc29yTGVhdmVGcm9tQm90dG9tID8geSArIGJ1ZmZlciAqIDQgOiB5IC0gYnVmZmVyICogNF07XG4gICAgICAgICAgICAgIGNvbnN0IGN1cnNvclBvaW50VHdvID0gW3ggKyBidWZmZXIgKyAxLCBpc0Zsb2F0aW5nVGFsbGVyID8geSAtIGJ1ZmZlciAvIDIgOiBjdXJzb3JMZWF2ZUZyb21Cb3R0b20gPyB5ICsgYnVmZmVyICogNCA6IHkgLSBidWZmZXIgKiA0XTtcbiAgICAgICAgICAgICAgY29uc3QgY29tbW9uUG9pbnRzID0gW1tjdXJzb3JMZWF2ZUZyb21Cb3R0b20gPyByZWN0LnJpZ2h0IC0gYnVmZmVyIDogaXNGbG9hdGluZ1RhbGxlciA/IHJlY3QucmlnaHQgLSBidWZmZXIgOiByZWN0LmxlZnQsIHJlY3QudG9wXSwgW2N1cnNvckxlYXZlRnJvbUJvdHRvbSA/IGlzRmxvYXRpbmdUYWxsZXIgPyByZWN0LnJpZ2h0IC0gYnVmZmVyIDogcmVjdC5sZWZ0IDogcmVjdC5yaWdodCAtIGJ1ZmZlciwgcmVjdC5ib3R0b21dXTtcbiAgICAgICAgICAgICAgcmV0dXJuIFsuLi5jb21tb25Qb2ludHMsIGN1cnNvclBvaW50T25lLCBjdXJzb3JQb2ludFR3b107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb25zdCBjdXJzb3JQb2ludE9uZSA9IFt4IC0gYnVmZmVyLCBpc0Zsb2F0aW5nVGFsbGVyID8geSArIGJ1ZmZlciAvIDIgOiBjdXJzb3JMZWF2ZUZyb21Cb3R0b20gPyB5ICsgYnVmZmVyICogNCA6IHkgLSBidWZmZXIgKiA0XTtcbiAgICAgICAgICAgICAgY29uc3QgY3Vyc29yUG9pbnRUd28gPSBbeCAtIGJ1ZmZlciwgaXNGbG9hdGluZ1RhbGxlciA/IHkgLSBidWZmZXIgLyAyIDogY3Vyc29yTGVhdmVGcm9tQm90dG9tID8geSArIGJ1ZmZlciAqIDQgOiB5IC0gYnVmZmVyICogNF07XG4gICAgICAgICAgICAgIGNvbnN0IGNvbW1vblBvaW50cyA9IFtbY3Vyc29yTGVhdmVGcm9tQm90dG9tID8gcmVjdC5sZWZ0ICsgYnVmZmVyIDogaXNGbG9hdGluZ1RhbGxlciA/IHJlY3QubGVmdCArIGJ1ZmZlciA6IHJlY3QucmlnaHQsIHJlY3QudG9wXSwgW2N1cnNvckxlYXZlRnJvbUJvdHRvbSA/IGlzRmxvYXRpbmdUYWxsZXIgPyByZWN0LmxlZnQgKyBidWZmZXIgOiByZWN0LnJpZ2h0IDogcmVjdC5sZWZ0ICsgYnVmZmVyLCByZWN0LmJvdHRvbV1dO1xuICAgICAgICAgICAgICByZXR1cm4gW2N1cnNvclBvaW50T25lLCBjdXJzb3JQb2ludFR3bywgLi4uY29tbW9uUG9pbnRzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzUG9pbnRJblBvbHlnb24oW2NsaWVudFgsIGNsaWVudFldLCByZWN0UG9seSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGhhc0xhbmRlZCAmJiAhaXNPdmVyUmVmZXJlbmNlUmVjdCkge1xuICAgICAgICByZXR1cm4gY2xvc2UoKTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNMZWF2ZSAmJiByZXF1aXJlSW50ZW50KSB7XG4gICAgICAgIGNvbnN0IGN1cnNvclNwZWVkID0gZ2V0Q3Vyc29yU3BlZWQoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgICAgIGNvbnN0IGN1cnNvclNwZWVkVGhyZXNob2xkID0gMC4xO1xuICAgICAgICBpZiAoY3Vyc29yU3BlZWQgIT09IG51bGwgJiYgY3Vyc29yU3BlZWQgPCBjdXJzb3JTcGVlZFRocmVzaG9sZCkge1xuICAgICAgICAgIHJldHVybiBjbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWlzUG9pbnRJblBvbHlnb24oW2NsaWVudFgsIGNsaWVudFldLCBnZXRQb2x5Z29uKFt4LCB5XSkpKSB7XG4gICAgICAgIGNsb3NlKCk7XG4gICAgICB9IGVsc2UgaWYgKCFoYXNMYW5kZWQgJiYgcmVxdWlyZUludGVudCkge1xuICAgICAgICB0aW1lb3V0SWQgPSB3aW5kb3cuc2V0VGltZW91dChjbG9zZSwgNDApO1xuICAgICAgfVxuICAgIH07XG4gIH07XG4gIGZuLl9fb3B0aW9ucyA9IHtcbiAgICBibG9ja1BvaW50ZXJFdmVudHNcbiAgfTtcbiAgcmV0dXJuIGZuO1xufVxuXG5leHBvcnQgeyBDb21wb3NpdGUsIENvbXBvc2l0ZUl0ZW0sIEZsb2F0aW5nQXJyb3csIEZsb2F0aW5nRGVsYXlHcm91cCwgRmxvYXRpbmdGb2N1c01hbmFnZXIsIEZsb2F0aW5nTGlzdCwgRmxvYXRpbmdOb2RlLCBGbG9hdGluZ092ZXJsYXksIEZsb2F0aW5nUG9ydGFsLCBGbG9hdGluZ1RyZWUsIGlubmVyLCBzYWZlUG9seWdvbiwgdXNlQ2xpY2ssIHVzZUNsaWVudFBvaW50LCB1c2VEZWxheUdyb3VwLCB1c2VEZWxheUdyb3VwQ29udGV4dCwgdXNlRGlzbWlzcywgdXNlRmxvYXRpbmcsIHVzZUZsb2F0aW5nTm9kZUlkLCB1c2VGbG9hdGluZ1BhcmVudE5vZGVJZCwgdXNlRmxvYXRpbmdQb3J0YWxOb2RlLCB1c2VGbG9hdGluZ1RyZWUsIHVzZUZvY3VzLCB1c2VIb3ZlciwgdXNlSWQsIHVzZUlubmVyT2Zmc2V0LCB1c2VJbnRlcmFjdGlvbnMsIHVzZUxpc3RJdGVtLCB1c2VMaXN0TmF2aWdhdGlvbiwgdXNlTWVyZ2VSZWZzLCB1c2VSb2xlLCB1c2VUcmFuc2l0aW9uU3RhdHVzLCB1c2VUcmFuc2l0aW9uU3R5bGVzLCB1c2VUeXBlYWhlYWQgfTtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZUxheW91dEVmZmVjdCIsInVzZUVmZmVjdCIsInVzZVJlZiIsInN0b3BFdmVudCIsImdldERvY3VtZW50IiwiaXNNb3VzZUxpa2VQb2ludGVyVHlwZSIsImNvbnRhaW5zIiwiYWN0aXZlRWxlbWVudCIsImlzU2FmYXJpIiwiaXNUeXBlYWJsZUNvbWJvYm94IiwiaXNWaXJ0dWFsQ2xpY2siLCJpc1ZpcnR1YWxQb2ludGVyRXZlbnQiLCJnZXRUYXJnZXQiLCJnZXRQbGF0Zm9ybSIsImlzVHlwZWFibGVFbGVtZW50IiwiaXNSZWFjdEV2ZW50IiwiaXNSb290RWxlbWVudCIsImlzRXZlbnRUYXJnZXRXaXRoaW4iLCJpc01hYyIsImdldFVzZXJBZ2VudCIsImZsb29yIiwicGxhdGZvcm0iLCJnZXRPdmVyZmxvd0FuY2VzdG9ycyIsInVzZUZsb2F0aW5nIiwidXNlRmxvYXRpbmckMSIsIm9mZnNldCIsImRldGVjdE92ZXJmbG93IiwiYXJyb3ciLCJhdXRvUGxhY2VtZW50IiwiYXV0b1VwZGF0ZSIsImNvbXB1dGVQb3NpdGlvbiIsImZsaXAiLCJoaWRlIiwiaW5saW5lIiwibGltaXRTaGlmdCIsInNoaWZ0Iiwic2l6ZSIsImlzRWxlbWVudCIsImlzSFRNTEVsZW1lbnQiLCJnZXROb2RlTmFtZSIsImdldFdpbmRvdyIsImlzTGFzdFRyYXZlcnNhYmxlTm9kZSIsImdldFBhcmVudE5vZGUiLCJnZXRDb21wdXRlZFN0eWxlIiwidGFiYmFibGUiLCJpc1RhYmJhYmxlIiwiY3JlYXRlUG9ydGFsIiwiZmx1c2hTeW5jIiwidXNlTWVyZ2VSZWZzIiwicmVmcyIsInVzZU1lbW8iLCJldmVyeSIsInJlZiIsInZhbHVlIiwiZm9yRWFjaCIsImN1cnJlbnQiLCJ1c2VJbnNlcnRpb25FZmZlY3QiLCJ0b1N0cmluZyIsInVzZVNhZmVJbnNlcnRpb25FZmZlY3QiLCJmbiIsInVzZUVmZmVjdEV2ZW50IiwiY2FsbGJhY2siLCJFcnJvciIsInVzZUNhbGxiYWNrIiwiX2xlbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsIl9rZXkiLCJBUlJPV19VUCIsIkFSUk9XX0RPV04iLCJBUlJPV19MRUZUIiwiQVJST1dfUklHSFQiLCJpc0RpZmZlcmVudFJvdyIsImluZGV4IiwiY29scyIsInByZXZSb3ciLCJNYXRoIiwiaXNJbmRleE91dE9mQm91bmRzIiwibGlzdFJlZiIsImdldE1pbkluZGV4IiwiZGlzYWJsZWRJbmRpY2VzIiwiZmluZE5vbkRpc2FibGVkSW5kZXgiLCJnZXRNYXhJbmRleCIsImRlY3JlbWVudCIsInN0YXJ0aW5nSW5kZXgiLCJfdGVtcCIsImFtb3VudCIsImxpc3QiLCJpc0Rpc2FibGVkSW5kZXgiLCJpbmNsdWRlcyIsImVsZW1lbnQiLCJoYXNBdHRyaWJ1dGUiLCJnZXRBdHRyaWJ1dGUiLCJnZXRHcmlkTmF2aWdhdGVkSW5kZXgiLCJlbGVtZW50c1JlZiIsIl9yZWYiLCJldmVudCIsIm9yaWVudGF0aW9uIiwibG9vcCIsIm1pbkluZGV4IiwibWF4SW5kZXgiLCJwcmV2SW5kZXgiLCJzdG9wIiwibmV4dEluZGV4Iiwia2V5IiwiY29sIiwibWF4Q29sIiwibGFzdFJvdyIsImJ1aWxkQ2VsbE1hcCIsInNpemVzIiwiZGVuc2UiLCJjZWxsTWFwIiwic3RhcnRJbmRleCIsIl9yZWYyIiwid2lkdGgiLCJoZWlnaHQiLCJpdGVtUGxhY2VkIiwidGFyZ2V0Q2VsbHMiLCJpIiwiaiIsInB1c2giLCJjZWxsIiwiZ2V0Q2VsbEluZGV4T2ZDb3JuZXIiLCJjb3JuZXIiLCJmaXJzdENlbGxJbmRleCIsImluZGV4T2YiLCJsYXN0SW5kZXhPZiIsImdldENlbGxJbmRpY2VzIiwiaW5kaWNlcyIsImZsYXRNYXAiLCJjZWxsSW5kZXgiLCJyYWZJZCIsImVucXVldWVGb2N1cyIsImVsIiwib3B0aW9ucyIsInByZXZlbnRTY3JvbGwiLCJjYW5jZWxQcmV2aW91cyIsInN5bmMiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImV4ZWMiLCJmb2N1cyIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImRvY3VtZW50Iiwic29ydEJ5RG9jdW1lbnRQb3NpdGlvbiIsImEiLCJiIiwicG9zaXRpb24iLCJjb21wYXJlRG9jdW1lbnRQb3NpdGlvbiIsIk5vZGUiLCJET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkciLCJET0NVTUVOVF9QT1NJVElPTl9DT05UQUlORURfQlkiLCJET0NVTUVOVF9QT1NJVElPTl9QUkVDRURJTkciLCJET0NVTUVOVF9QT1NJVElPTl9DT05UQUlOUyIsImFyZU1hcHNFcXVhbCIsIm1hcDEiLCJtYXAyIiwiZW50cmllcyIsImdldCIsIkZsb2F0aW5nTGlzdENvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwicmVnaXN0ZXIiLCJ1bnJlZ2lzdGVyIiwibWFwIiwiTWFwIiwiRmxvYXRpbmdMaXN0IiwiY2hpbGRyZW4iLCJsYWJlbHNSZWYiLCJzZXRNYXAiLCJ1c2VTdGF0ZSIsIm5vZGUiLCJwcmV2TWFwIiwic2V0IiwiZGVsZXRlIiwibmV3TWFwIiwibm9kZXMiLCJmcm9tIiwia2V5cyIsInNvcnQiLCJjcmVhdGVFbGVtZW50IiwiUHJvdmlkZXIiLCJ1c2VMaXN0SXRlbSIsImxhYmVsIiwiaW5kZXgkMSIsInNldEluZGV4IiwiY29tcG9uZW50UmVmIiwidXNlQ29udGV4dCIsIl9ub2RlJHRleHRDb250ZW50IiwiaXNMYWJlbERlZmluZWQiLCJ1bmRlZmluZWQiLCJ0ZXh0Q29udGVudCIsInJlbmRlckpzeCIsInJlbmRlciIsImNvbXB1dGVkUHJvcHMiLCJjbG9uZUVsZW1lbnQiLCJDb21wb3NpdGVDb250ZXh0IiwiYWN0aXZlSW5kZXgiLCJvbk5hdmlnYXRlIiwiaG9yaXpvbnRhbEtleXMiLCJ2ZXJ0aWNhbEtleXMiLCJhbGxLZXlzIiwiQ29tcG9zaXRlIiwiZm9yd2FyZFJlZiIsImZvcndhcmRlZFJlZiIsImV4dGVybmFsQWN0aXZlSW5kZXgiLCJleHRlcm5hbFNldEFjdGl2ZUluZGV4IiwiaXRlbVNpemVzIiwicHJvcHMiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiLCJfZXhjbHVkZWQiLCJpbnRlcm5hbEFjdGl2ZUluZGV4IiwiaW50ZXJuYWxTZXRBY3RpdmVJbmRleCIsInJlbmRlckVsZW1lbnRQcm9wcyIsImNvbnRleHRWYWx1ZSIsImlzR3JpZCIsImhhbmRsZUtleURvd24iLCJtaW5HcmlkSW5kZXgiLCJmaW5kSW5kZXgiLCJtYXhHcmlkSW5kZXgiLCJyZWR1Y2UiLCJmb3VuZEluZGV4IiwiaXRlbUluZGV4IiwidG9FbmRLZXlzIiwiaG9yaXpvbnRhbCIsInZlcnRpY2FsIiwiYm90aCIsInRvU3RhcnRLZXlzIiwicHJldmVudGVkS2V5cyIsInN0b3BQcm9wYWdhdGlvbiIsInByZXZlbnREZWZhdWx0IiwicXVldWVNaWNyb3Rhc2siLCJfb2JqZWN0U3ByZWFkIiwib25LZXlEb3duIiwiZSIsIkNvbXBvc2l0ZUl0ZW0iLCJfZXhjbHVkZWQyIiwibWVyZ2VkUmVmIiwiaXNBY3RpdmUiLCJ0YWJJbmRleCIsIm9uRm9jdXMiLCJfZXh0ZW5kcyIsIk9iamVjdCIsImFzc2lnbiIsImJpbmQiLCJ0YXJnZXQiLCJzb3VyY2UiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJhcHBseSIsInNlcnZlckhhbmRvZmZDb21wbGV0ZSIsImNvdW50IiwiZ2VuSWQiLCJ1c2VGbG9hdGluZ0lkIiwiaWQiLCJzZXRJZCIsInVzZVJlYWN0SWQiLCJ1c2VJZCIsIkZsb2F0aW5nQXJyb3ciLCJjb250ZXh0IiwicGxhY2VtZW50IiwiZWxlbWVudHMiLCJmbG9hdGluZyIsIm1pZGRsZXdhcmVEYXRhIiwidGlwUmFkaXVzIiwic3Ryb2tlV2lkdGgiLCJzdGF0aWNPZmZzZXQiLCJzdHJva2UiLCJkIiwic3R5bGUiLCJ0cmFuc2Zvcm0iLCJyZXN0U3R5bGUiLCJfZXhjbHVkZWQzIiwicmVzdCIsIl9leGNsdWRlZDQiLCJjb25zb2xlIiwid2FybiIsImNsaXBQYXRoSWQiLCJoYWxmU3Ryb2tlV2lkdGgiLCJzdmdYIiwic3ZnWSIsInNpZGUiLCJhbGlnbm1lbnQiLCJzcGxpdCIsImlzUlRMIiwiaXNDdXN0b21TaGFwZSIsImlzVmVydGljYWxTaWRlIiwieU9mZnNldFByb3AiLCJ4T2Zmc2V0UHJvcCIsImFycm93WCIsIngiLCJhcnJvd1kiLCJ5IiwiZFZhbHVlIiwicm90YXRpb24iLCJ0b3AiLCJsZWZ0IiwiYm90dG9tIiwicmlnaHQiLCJ2aWV3Qm94IiwicG9pbnRlckV2ZW50cyIsImNsaXBQYXRoIiwiZmlsbCIsImNyZWF0ZVB1YlN1YiIsImVtaXQiLCJkYXRhIiwiX21hcCRnZXQiLCJoYW5kbGVyIiwib24iLCJsaXN0ZW5lciIsIm9mZiIsIl9tYXAkZ2V0MiIsImZpbHRlciIsImwiLCJGbG9hdGluZ05vZGVDb250ZXh0IiwiRmxvYXRpbmdUcmVlQ29udGV4dCIsInVzZUZsb2F0aW5nUGFyZW50Tm9kZUlkIiwiX1JlYWN0JHVzZUNvbnRleHQiLCJ1c2VGbG9hdGluZ1RyZWUiLCJ1c2VGbG9hdGluZ05vZGVJZCIsImN1c3RvbVBhcmVudElkIiwidHJlZSIsInJlYWN0UGFyZW50SWQiLCJwYXJlbnRJZCIsImFkZE5vZGUiLCJyZW1vdmVOb2RlIiwiRmxvYXRpbmdOb2RlIiwiRmxvYXRpbmdUcmVlIiwibm9kZXNSZWYiLCJuIiwiZXZlbnRzIiwiY3JlYXRlQXR0cmlidXRlIiwibmFtZSIsInVzZUxhdGVzdFJlZiIsInNhZmVQb2x5Z29uSWRlbnRpZmllciIsImdldERlbGF5IiwicHJvcCIsInBvaW50ZXJUeXBlIiwidXNlSG92ZXIiLCJvcGVuIiwib25PcGVuQ2hhbmdlIiwiZGF0YVJlZiIsImRvbVJlZmVyZW5jZSIsImVuYWJsZWQiLCJkZWxheSIsImhhbmRsZUNsb3NlIiwibW91c2VPbmx5IiwicmVzdE1zIiwibW92ZSIsImhhbmRsZUNsb3NlUmVmIiwiZGVsYXlSZWYiLCJwb2ludGVyVHlwZVJlZiIsInRpbWVvdXRSZWYiLCJoYW5kbGVyUmVmIiwicmVzdFRpbWVvdXRSZWYiLCJibG9ja01vdXNlTW92ZVJlZiIsInBlcmZvcm1lZFBvaW50ZXJFdmVudHNNdXRhdGlvblJlZiIsInVuYmluZE1vdXNlTW92ZVJlZiIsImlzSG92ZXJPcGVuIiwiX2RhdGFSZWYkY3VycmVudCRvcGVuIiwidHlwZSIsIm9wZW5FdmVudCIsImNsZWFyVGltZW91dCIsIm9uTGVhdmUiLCJodG1sIiwiZG9jdW1lbnRFbGVtZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjbG9zZVdpdGhEZWxheSIsInJ1bkVsc2VCcmFuY2giLCJyZWFzb24iLCJjbG9zZURlbGF5Iiwic2V0VGltZW91dCIsImNsZWFudXBNb3VzZU1vdmVIYW5kbGVyIiwiY2xlYXJQb2ludGVyRXZlbnRzIiwiYm9keSIsInJlbW92ZUF0dHJpYnV0ZSIsImlzQ2xpY2tMaWtlT3BlbkV2ZW50Iiwib25Nb3VzZUVudGVyIiwib3BlbkRlbGF5Iiwib25Nb3VzZUxlYXZlIiwiZG9jIiwiY2xpZW50WCIsImNsaWVudFkiLCJvbkNsb3NlIiwic2hvdWxkQ2xvc2UiLCJyZWxhdGVkVGFyZ2V0Iiwib25TY3JvbGxNb3VzZUxlYXZlIiwib25jZSIsIl9oYW5kbGVDbG9zZVJlZiRjdXJyZSIsIl9fb3B0aW9ucyIsImJsb2NrUG9pbnRlckV2ZW50cyIsInNldEF0dHJpYnV0ZSIsIl90cmVlJG5vZGVzUmVmJGN1cnJlbiIsInBhcmVudEZsb2F0aW5nIiwiZmluZCIsInNldFBvaW50ZXJSZWYiLCJyZWZlcmVuY2UiLCJvblBvaW50ZXJEb3duIiwib25Qb2ludGVyRW50ZXIiLCJvbk1vdXNlTW92ZSIsIm5hdGl2ZUV2ZW50IiwiRmxvYXRpbmdEZWxheUdyb3VwQ29udGV4dCIsImluaXRpYWxEZWxheSIsInRpbWVvdXRNcyIsImN1cnJlbnRJZCIsInNldEN1cnJlbnRJZCIsInNldFN0YXRlIiwiaXNJbnN0YW50UGhhc2UiLCJ1c2VEZWxheUdyb3VwQ29udGV4dCIsIkZsb2F0aW5nRGVsYXlHcm91cCIsInN0YXRlIiwidXNlUmVkdWNlciIsInByZXYiLCJuZXh0IiwiaW5pdGlhbEN1cnJlbnRJZFJlZiIsInVzZURlbGF5R3JvdXAiLCJfcmVmMyIsImNsb3NlIiwidW5zZXQiLCJ0aW1lb3V0Iiwid2luZG93IiwiZ2V0QW5jZXN0b3JzIiwiX25vZGVzJGZpbmQiLCJhbGxBbmNlc3RvcnMiLCJjdXJyZW50UGFyZW50SWQiLCJjdXJyZW50Tm9kZSIsImNvbmNhdCIsImdldENoaWxkcmVuIiwiYWxsQ2hpbGRyZW4iLCJfbm9kZSRjb250ZXh0IiwiY3VycmVudENoaWxkcmVuIiwiX2N1cnJlbnRDaGlsZHJlbiIsInNvbWUiLCJfbm9kZSRjb250ZXh0MiIsImdldERlZXBlc3ROb2RlIiwiZGVlcGVzdE5vZGVJZCIsIm1heERlcHRoIiwiZmluZERlZXBlc3QiLCJub2RlSWQiLCJkZXB0aCIsImNoaWxkIiwiY291bnRlck1hcCIsIldlYWtNYXAiLCJ1bmNvbnRyb2xsZWRFbGVtZW50c1NldCIsIldlYWtTZXQiLCJtYXJrZXJNYXAiLCJsb2NrQ291bnQiLCJzdXBwb3J0c0luZXJ0IiwiSFRNTEVsZW1lbnQiLCJ1bndyYXBIb3N0IiwiaG9zdCIsInBhcmVudE5vZGUiLCJjb3JyZWN0RWxlbWVudHMiLCJwYXJlbnQiLCJ0YXJnZXRzIiwiY29ycmVjdGVkVGFyZ2V0IiwiYXBwbHlBdHRyaWJ1dGVUb090aGVycyIsInVuY29ycmVjdGVkQXZvaWRFbGVtZW50cyIsImFyaWFIaWRkZW4iLCJpbmVydCIsIm1hcmtlck5hbWUiLCJjb250cm9sQXR0cmlidXRlIiwiYXZvaWRFbGVtZW50cyIsImVsZW1lbnRzVG9LZWVwIiwiU2V0IiwiZWxlbWVudHNUb1N0b3AiLCJoaWRkZW5FbGVtZW50cyIsIm1hcmtlckNvdW50ZXIiLCJrZWVwIiwiZGVlcCIsImNsZWFyIiwiaGFzIiwiYWRkIiwiYXR0ciIsImFscmVhZHlIaWRkZW4iLCJjb3VudGVyVmFsdWUiLCJtYXJrZXJWYWx1ZSIsIm1hcmtPdGhlcnMiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZ2V0VGFiYmFibGVPcHRpb25zIiwiZ2V0U2hhZG93Um9vdCIsImRpc3BsYXlDaGVjayIsIlJlc2l6ZU9ic2VydmVyIiwiZ2V0VGFiYmFibGVJbiIsImNvbnRhaW5lciIsImRpcmVjdGlvbiIsImFsbFRhYmJhYmxlIiwicmV2ZXJzZSIsIm5leHRUYWJiYWJsZUVsZW1lbnRzIiwic2xpY2UiLCJnZXROZXh0VGFiYmFibGUiLCJnZXRQcmV2aW91c1RhYmJhYmxlIiwiaXNPdXRzaWRlRXZlbnQiLCJjb250YWluZXJFbGVtZW50IiwiY3VycmVudFRhcmdldCIsImRpc2FibGVGb2N1c0luc2lkZSIsInRhYmJhYmxlRWxlbWVudHMiLCJkYXRhc2V0IiwidGFiaW5kZXgiLCJlbmFibGVGb2N1c0luc2lkZSIsIkhJRERFTl9TVFlMRVMiLCJib3JkZXIiLCJjbGlwIiwibWFyZ2luIiwib3ZlcmZsb3ciLCJwYWRkaW5nIiwid2hpdGVTcGFjZSIsInRpbWVvdXRJZCIsInNldEFjdGl2ZUVsZW1lbnRPblRhYiIsIkZvY3VzR3VhcmQiLCJyb2xlIiwic2V0Um9sZSIsInJlc3RQcm9wcyIsIlBvcnRhbENvbnRleHQiLCJ1c2VGbG9hdGluZ1BvcnRhbE5vZGUiLCJyb290IiwicG9ydGFsTm9kZSIsInNldFBvcnRhbE5vZGUiLCJ1bmlxdWVJZCIsInBvcnRhbENvbnRleHQiLCJ1c2VQb3J0YWxDb250ZXh0IiwicG9ydGFsTm9kZVJlZiIsInJlbW92ZSIsImV4aXN0aW5nSWRSb290IiwiZ2V0RWxlbWVudEJ5SWQiLCJzdWJSb290IiwiYXBwZW5kQ2hpbGQiLCJpZFdyYXBwZXIiLCJGbG9hdGluZ1BvcnRhbCIsInByZXNlcnZlVGFiT3JkZXIiLCJmb2N1c01hbmFnZXJTdGF0ZSIsInNldEZvY3VzTWFuYWdlclN0YXRlIiwiYmVmb3JlT3V0c2lkZVJlZiIsImFmdGVyT3V0c2lkZVJlZiIsImJlZm9yZUluc2lkZVJlZiIsImFmdGVySW5zaWRlUmVmIiwic2hvdWxkUmVuZGVyR3VhcmRzIiwibW9kYWwiLCJmb2N1c2luZyIsIm1hbmFnZUZvY3VzIiwiX2JlZm9yZUluc2lkZVJlZiRjdXJyIiwicHJldlRhYmJhYmxlIiwiX2FmdGVySW5zaWRlUmVmJGN1cnJlIiwibmV4dFRhYmJhYmxlIiwiY2xvc2VPbkZvY3VzT3V0IiwiTElTVF9MSU1JVCIsInByZXZpb3VzbHlGb2N1c2VkRWxlbWVudHMiLCJhZGRQcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQiLCJpc0Nvbm5lY3RlZCIsInRhYmJhYmxlRWwiLCJ0YWJiYWJsZUNoaWxkIiwiZ2V0UHJldmlvdXNseUZvY3VzZWRFbGVtZW50IiwiVmlzdWFsbHlIaWRkZW5EaXNtaXNzIiwiRmxvYXRpbmdGb2N1c01hbmFnZXIiLCJkaXNhYmxlZCIsIm9yZGVyIiwiZ3VhcmRzIiwiX2d1YXJkcyIsImluaXRpYWxGb2N1cyIsInJldHVybkZvY3VzIiwidmlzdWFsbHlIaWRkZW5EaXNtaXNzIiwiaWdub3JlSW5pdGlhbEZvY3VzIiwiaXNVbnRyYXBwZWRUeXBlYWJsZUNvbWJvYm94Iiwib3JkZXJSZWYiLCJpbml0aWFsRm9jdXNSZWYiLCJyZXR1cm5Gb2N1c1JlZiIsInN0YXJ0RGlzbWlzc0J1dHRvblJlZiIsImVuZERpc21pc3NCdXR0b25SZWYiLCJwcmV2ZW50UmV0dXJuRm9jdXNSZWYiLCJpc1BvaW50ZXJEb3duUmVmIiwiaXNJbnNpZGVQb3J0YWwiLCJnZXRUYWJiYWJsZUNvbnRlbnQiLCJnZXRUYWJiYWJsZUVsZW1lbnRzIiwiY29udGVudCIsIkJvb2xlYW4iLCJmbGF0IiwiZWxzIiwic2hpZnRLZXkiLCJoYW5kbGVQb2ludGVyRG93biIsImhhbmRsZUZvY3VzT3V0c2lkZSIsIm1vdmVkVG9VbnJlbGF0ZWROb2RlIiwiX25vZGUkY29udGV4dDMiLCJfbm9kZSRjb250ZXh0NCIsIl9wb3J0YWxDb250ZXh0JHBvcnRhbCIsInBvcnRhbE5vZGVzIiwiaW5zaWRlRWxlbWVudHMiLCJjbGVhbnVwIiwicHJldmlvdXNseUZvY3VzZWRFbGVtZW50IiwiZm9jdXNhYmxlRWxlbWVudHMiLCJpbml0aWFsRm9jdXNWYWx1ZSIsImVsVG9Gb2N1cyIsImZvY3VzQWxyZWFkeUluc2lkZUZsb2F0aW5nRWwiLCJwcmV2ZW50UmV0dXJuRm9jdXNTY3JvbGwiLCJjb250ZXh0RGF0YSIsIm5lc3RlZCIsImFjdGl2ZUVsIiwiaXNGb2N1c0luc2lkZUZsb2F0aW5nVHJlZSIsIl9ub2RlJGNvbnRleHQ1Iiwic2hvdWxkRm9jdXNSZWZlcmVuY2UiLCJyZXR1cm5FbGVtZW50IiwiTXV0YXRpb25PYnNlcnZlciIsImhhbmRsZU11dGF0aW9uIiwib2JzZXJ2ZXIiLCJvYnNlcnZlIiwiY2hpbGRMaXN0Iiwic3VidHJlZSIsImF0dHJpYnV0ZXMiLCJkaXNjb25uZWN0IiwicmVuZGVyRGlzbWlzc0J1dHRvbiIsImxvY2F0aW9uIiwib25DbGljayIsIkZyYWdtZW50IiwiX3BvcnRhbENvbnRleHQkYmVmb3JlIiwiX3BvcnRhbENvbnRleHQkYWZ0ZXJPIiwiYWN0aXZlTG9ja3MiLCJGbG9hdGluZ092ZXJsYXkiLCJsb2NrU2Nyb2xsIiwiX2V4Y2x1ZGVkNSIsImxvY2tJZCIsImlzSU9TIiwidGVzdCIsImJvZHlTdHlsZSIsInNjcm9sbGJhclgiLCJyb3VuZCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInNjcm9sbExlZnQiLCJwYWRkaW5nUHJvcCIsInNjcm9sbGJhcldpZHRoIiwiaW5uZXJXaWR0aCIsImNsaWVudFdpZHRoIiwic2Nyb2xsWCIsInBhcnNlRmxvYXQiLCJwYWdlWE9mZnNldCIsInNjcm9sbFkiLCJwYWdlWU9mZnNldCIsIl93aW5kb3ckdmlzdWFsVmlld3BvciIsIl93aW5kb3ckdmlzdWFsVmlld3BvcjIiLCJvZmZzZXRMZWZ0IiwidmlzdWFsVmlld3BvcnQiLCJvZmZzZXRUb3AiLCJzY3JvbGxUbyIsImlzQnV0dG9uVGFyZ2V0IiwidGFnTmFtZSIsImlzU3BhY2VJZ25vcmVkIiwidXNlQ2xpY2siLCJldmVudE9wdGlvbiIsInRvZ2dsZSIsImlnbm9yZU1vdXNlIiwia2V5Ym9hcmRIYW5kbGVycyIsImRpZEtleURvd25SZWYiLCJvbk1vdXNlRG93biIsImJ1dHRvbiIsImRlZmF1bHRQcmV2ZW50ZWQiLCJvbktleVVwIiwiY3JlYXRlVmlydHVhbEVsZW1lbnQiLCJkb21SZWYiLCJvZmZzZXRYIiwib2Zmc2V0WSIsImlzQXV0b1VwZGF0ZUV2ZW50IiwiY29udGV4dEVsZW1lbnQiLCJfZG9tUmVmJGN1cnJlbnQiLCJfZGF0YSRkYXRhUmVmJGN1cnJlbnQiLCJkb21SZWN0IiwiaXNYQXhpcyIsImF4aXMiLCJpc1lBeGlzIiwiY2FuVHJhY2tDdXJzb3JPbkF1dG9VcGRhdGUiLCJpc01vdXNlQmFzZWRFdmVudCIsInVzZUNsaWVudFBvaW50IiwiaW5pdGlhbFJlZiIsImNsZWFudXBMaXN0ZW5lclJlZiIsInNldFBvaW50ZXJUeXBlIiwicmVhY3RpdmUiLCJzZXRSZWFjdGl2ZSIsInNldFJlZmVyZW5jZSIsInNldFBvc2l0aW9uUmVmZXJlbmNlIiwiaGFuZGxlUmVmZXJlbmNlRW50ZXJPck1vdmUiLCJvcGVuQ2hlY2siLCJhZGRMaXN0ZW5lciIsIndpbiIsImhhbmRsZU1vdXNlTW92ZSIsInNldFBvaW50ZXJUeXBlUmVmIiwiYnViYmxlSGFuZGxlcktleXMiLCJwb2ludGVyZG93biIsIm1vdXNlZG93biIsImNsaWNrIiwiY2FwdHVyZUhhbmRsZXJLZXlzIiwibm9ybWFsaXplUHJvcCIsIm5vcm1hbGl6YWJsZSIsIl9ub3JtYWxpemFibGUkZXNjYXBlSyIsIl9ub3JtYWxpemFibGUkb3V0c2lkZSIsImVzY2FwZUtleSIsIm91dHNpZGVQcmVzcyIsInVzZURpc21pc3MiLCJ1bnN0YWJsZV9vdXRzaWRlUHJlc3MiLCJvdXRzaWRlUHJlc3NFdmVudCIsInJlZmVyZW5jZVByZXNzIiwicmVmZXJlbmNlUHJlc3NFdmVudCIsImFuY2VzdG9yU2Nyb2xsIiwiYnViYmxlcyIsImNhcHR1cmUiLCJvdXRzaWRlUHJlc3NGbiIsImluc2lkZVJlYWN0VHJlZVJlZiIsImVuZGVkT3JTdGFydGVkSW5zaWRlUmVmIiwiZXNjYXBlS2V5QnViYmxlcyIsIm91dHNpZGVQcmVzc0J1YmJsZXMiLCJlc2NhcGVLZXlDYXB0dXJlIiwib3V0c2lkZVByZXNzQ2FwdHVyZSIsImNsb3NlT25Fc2NhcGVLZXlEb3duIiwic2hvdWxkRGlzbWlzcyIsIl9jaGlsZCRjb250ZXh0IiwiX19lc2NhcGVLZXlCdWJibGVzIiwiY2xvc2VPbkVzY2FwZUtleURvd25DYXB0dXJlIiwiX2dldFRhcmdldDIiLCJfZ2V0VGFyZ2V0IiwiY2xvc2VPblByZXNzT3V0c2lkZSIsImluc2lkZVJlYWN0VHJlZSIsImVuZGVkT3JTdGFydGVkSW5zaWRlIiwiaW5lcnRTZWxlY3RvciIsIm1hcmtlcnMiLCJ0YXJnZXRSb290QW5jZXN0b3IiLCJuZXh0UGFyZW50IiwibWFya2VyIiwiY2FuU2Nyb2xsWCIsInNjcm9sbFdpZHRoIiwiY2FuU2Nyb2xsWSIsImNsaWVudEhlaWdodCIsInNjcm9sbEhlaWdodCIsInhDb25kIiwib2Zmc2V0V2lkdGgiLCJ0YXJnZXRJc0luc2lkZUNoaWxkcmVuIiwiX2NoaWxkJGNvbnRleHQyIiwiX19vdXRzaWRlUHJlc3NCdWJibGVzIiwiY2xvc2VPblByZXNzT3V0c2lkZUNhcHR1cmUiLCJfZ2V0VGFyZ2V0NCIsIl9nZXRUYXJnZXQzIiwib25TY3JvbGwiLCJhbmNlc3RvcnMiLCJhbmNlc3RvciIsIl9kb2MkZGVmYXVsdFZpZXciLCJkZWZhdWx0VmlldyIsInBhc3NpdmUiLCJvbk1vdXNlVXAiLCJkZXZNZXNzYWdlU2V0IiwiX29wdGlvbnMkZWxlbWVudHMyIiwidW5zdGFibGVfb25PcGVuQ2hhbmdlIiwiX29wdGlvbnMkZWxlbWVudHMiLCJlcnIiLCJfZGV2TWVzc2FnZVNldCIsIl9kZXZNZXNzYWdlU2V0MiIsImVycm9yIiwiX2RvbVJlZmVyZW5jZSIsInNldERvbVJlZmVyZW5jZSIsImRvbVJlZmVyZW5jZVJlZiIsImZsb2F0aW5nSWQiLCJwb3NpdGlvblJlZmVyZW5jZSIsInVzZUZvY3VzIiwidmlzaWJsZU9ubHkiLCJibG9ja0ZvY3VzUmVmIiwia2V5Ym9hcmRNb2RhbGl0eVJlZiIsIm9uQmx1ciIsIm1hdGNoZXMiLCJtb3ZlZFRvRm9jdXNHdWFyZCIsIm93bmVyRG9jdW1lbnQiLCJBQ1RJVkVfS0VZIiwiU0VMRUNURURfS0VZIiwibWVyZ2VQcm9wcyIsInVzZXJQcm9wcyIsInByb3BzTGlzdCIsImVsZW1lbnRLZXkiLCJpc0l0ZW0iLCJkb21Vc2VyUHJvcHMiLCJfIiwiX18iLCJ2YWxpZFByb3BzIiwiX3RvUHJvcGVydHlLZXkiLCJwcm9wc09yR2V0UHJvcHMiLCJhY2MiLCJ2YWwiLCJ1c2VJbnRlcmFjdGlvbnMiLCJkZXBzIiwiZ2V0UmVmZXJlbmNlUHJvcHMiLCJnZXRGbG9hdGluZ1Byb3BzIiwiZ2V0SXRlbVByb3BzIiwiaXRlbSIsImlzUHJldmVudFNjcm9sbFN1cHBvcnRlZCIsImRvU3dpdGNoIiwiaXNNYWluT3JpZW50YXRpb25LZXkiLCJpc01haW5PcmllbnRhdGlvblRvRW5kS2V5IiwicnRsIiwiaXNDcm9zc09yaWVudGF0aW9uT3BlbktleSIsImlzQ3Jvc3NPcmllbnRhdGlvbkNsb3NlS2V5IiwidXNlTGlzdE5hdmlnYXRpb24iLCJ1bnN0YWJsZV9vbk5hdmlnYXRlIiwic2VsZWN0ZWRJbmRleCIsImFsbG93RXNjYXBlIiwidmlydHVhbCIsImZvY3VzSXRlbU9uT3BlbiIsImZvY3VzSXRlbU9uSG92ZXIiLCJvcGVuT25BcnJvd0tleURvd24iLCJzY3JvbGxJdGVtSW50b1ZpZXciLCJ2aXJ0dWFsSXRlbVJlZiIsImpvaW4iLCJmb2N1c0l0ZW1Pbk9wZW5SZWYiLCJpbmRleFJlZiIsImtleVJlZiIsImlzUG9pbnRlck1vZGFsaXR5UmVmIiwicHJldmlvdXNPbk5hdmlnYXRlUmVmIiwicHJldmlvdXNNb3VudGVkUmVmIiwiZm9yY2VTeW5jRm9jdXMiLCJmb3JjZVNjcm9sbEludG9WaWV3UmVmIiwiZGlzYWJsZWRJbmRpY2VzUmVmIiwibGF0ZXN0T3BlblJlZiIsInNjcm9sbEl0ZW1JbnRvVmlld1JlZiIsImFjdGl2ZUlkIiwic2V0QWN0aXZlSWQiLCJ2aXJ0dWFsSWQiLCJzZXRWaXJ0dWFsSWQiLCJmb2N1c0l0ZW0iLCJmb3JjZVNjcm9sbEludG9WaWV3Iiwic2Nyb2xsSW50b1ZpZXdPcHRpb25zIiwic2hvdWxkU2Nyb2xsSW50b1ZpZXciLCJzY3JvbGxJbnRvVmlldyIsImJsb2NrIiwicnVucyIsIndhaXRGb3JMaXN0UG9wdWxhdGVkIiwic2NoZWR1bGVyIiwidHJlZUNvbnRhaW5zQWN0aXZlRWwiLCJoYW5kbGVWaXJ0dWFsRm9jdXMiLCJoYXNBY3RpdmVJbmRleCIsInN5bmNDdXJyZW50VGFyZ2V0Iiwib25Qb2ludGVyTGVhdmUiLCJfcmVmNCIsImN1cnJlbnRJbmRleCIsIm1pbiIsIm1heCIsImNoZWNrVmlydHVhbE1vdXNlIiwiY2hlY2tWaXJ0dWFsUG9pbnRlciIsImFyaWFBY3RpdmVEZXNjZW5kYW50UHJvcCIsImFjdGl2ZUl0ZW0iLCJpc0Fycm93S2V5IiwiaXNDcm9zc09wZW5LZXkiLCJpc0Nyb3NzQ2xvc2VLZXkiLCJpc01haW5LZXkiLCJpc05hdmlnYXRpb25LZXkiLCJ0cmltIiwicm9vdE5vZGUiLCJkZWVwZXN0Tm9kZSIsImV2ZW50T2JqZWN0IiwiS2V5Ym9hcmRFdmVudCIsIl9kZWVwZXN0Tm9kZSRjb250ZXh0IiwiX2RlZXBlc3ROb2RlJGNvbnRleHQyIiwiaXNDdXJyZW50VGFyZ2V0IiwiZGlzcGF0Y2hJdGVtIiwiZGlzcGF0Y2hFdmVudCIsIl9kZWVwZXN0Tm9kZSRjb250ZXh0JCIsIm9uUG9pbnRlck1vdmUiLCJjb21wb25lbnRSb2xlVG9BcmlhUm9sZU1hcCIsInVzZVJvbGUiLCJfY29tcG9uZW50Um9sZVRvQXJpYVIiLCJhcmlhUm9sZSIsInJlZmVyZW5jZUlkIiwiaXNOZXN0ZWQiLCJmbG9hdGluZ1Byb3BzIiwiYWN0aXZlIiwic2VsZWN0ZWQiLCJjb21tb25Qcm9wcyIsImNhbWVsQ2FzZVRvS2ViYWJDYXNlIiwic3RyIiwicmVwbGFjZSIsIiQiLCJvZnMiLCJ0b0xvd2VyQ2FzZSIsImV4ZWNXaXRoQXJnc09yUmV0dXJuIiwidmFsdWVPckZuIiwidXNlRGVsYXlVbm1vdW50IiwiZHVyYXRpb25NcyIsImlzTW91bnRlZCIsInNldElzTW91bnRlZCIsInVzZVRyYW5zaXRpb25TdGF0dXMiLCJkdXJhdGlvbiIsImlzTnVtYmVyRHVyYXRpb24iLCJjbG9zZUR1cmF0aW9uIiwiaW5pdGlhdGVkIiwic2V0SW5pdGlhdGVkIiwic3RhdHVzIiwic2V0U3RhdHVzIiwiZnJhbWUiLCJ1c2VUcmFuc2l0aW9uU3R5bGVzIiwiaW5pdGlhbCIsInVuc3RhYmxlX2luaXRpYWwiLCJvcGFjaXR5IiwidW5zdGFibGVfb3BlbiIsInVuc3RhYmxlX2Nsb3NlIiwiY29tbW9uIiwidW5zdGFibGVfY29tbW9uIiwiZm5BcmdzIiwib3BlbkR1cmF0aW9uIiwic3R5bGVzIiwic2V0U3R5bGVzIiwib3BlblJlZiIsImNsb3NlUmVmIiwiY29tbW9uUmVmIiwiaW5pdGlhbFN0eWxlcyIsImNsb3NlU3R5bGVzIiwiY29tbW9uU3R5bGVzIiwib3BlblN0eWxlcyIsInRyYW5zaXRpb25Qcm9wZXJ0eSIsInRyYW5zaXRpb25EdXJhdGlvbiIsInVzZVR5cGVhaGVhZCIsIm9uTWF0Y2giLCJ1bnN0YWJsZV9vbk1hdGNoIiwib25UeXBpbmdDaGFuZ2UiLCJ1bnN0YWJsZV9vblR5cGluZ0NoYW5nZSIsImZpbmRNYXRjaCIsInJlc2V0TXMiLCJpZ25vcmVLZXlzIiwidGltZW91dElkUmVmIiwic3RyaW5nUmVmIiwicHJldkluZGV4UmVmIiwibWF0Y2hJbmRleFJlZiIsImZpbmRNYXRjaFJlZiIsImlnbm9yZUtleXNSZWYiLCJzZXRUeXBpbmdDaGFuZ2UiLCJ0eXBpbmciLCJnZXRNYXRjaGluZ0luZGV4Iiwib3JkZXJlZExpc3QiLCJzdHJpbmciLCJ0ZXh0IiwidG9Mb2NhbGVMb3dlckNhc2UiLCJsaXN0Q29udGVudCIsImN0cmxLZXkiLCJtZXRhS2V5IiwiYWx0S2V5IiwiYWxsb3dSYXBpZFN1Y2Nlc3Npb25PZkZpcnN0TGV0dGVyIiwiX3RleHQkIiwiX3RleHQkMiIsImdldEFyZ3NXaXRoQ3VzdG9tRmxvYXRpbmdIZWlnaHQiLCJyZWN0cyIsImlubmVyIiwib3ZlcmZsb3dSZWYiLCJvbkZhbGxiYWNrQ2hhbmdlIiwiaW5uZXJPZmZzZXQiLCJtaW5JdGVtc1Zpc2libGUiLCJyZWZlcmVuY2VPdmVyZmxvd1RocmVzaG9sZCIsInNjcm9sbFJlZiIsImRldGVjdE92ZXJmbG93T3B0aW9ucyIsIl9leGNsdWRlZDYiLCJzdGFydHNXaXRoIiwibmV4dEFyZ3MiLCJjbGllbnRUb3AiLCJvZmZzZXRIZWlnaHQiLCJyZWZPdmVyZmxvdyIsImVsZW1lbnRDb250ZXh0IiwiZGlmZlkiLCJuZXh0WSIsIm1heEhlaWdodCIsInNjcm9sbFRvcCIsInVzZUlubmVyT2Zmc2V0Iiwib25DaGFuZ2UiLCJ1bnN0YWJsZV9vbkNoYW5nZSIsImNvbnRyb2xsZWRTY3JvbGxpbmdSZWYiLCJwcmV2U2Nyb2xsVG9wUmVmIiwiaW5pdGlhbE92ZXJmbG93UmVmIiwib25XaGVlbCIsImRZIiwiZGVsdGFZIiwiaXNBdFRvcCIsImlzQXRCb3R0b20iLCJyZW1haW5pbmdTY3JvbGwiLCJzaWduIiwibWV0aG9kIiwic2Nyb2xsRGlmZiIsImlzUG9pbnRJblBvbHlnb24iLCJwb2ludCIsInBvbHlnb24iLCJpc0luc2lkZSIsInhpIiwieWkiLCJ4aiIsInlqIiwiaW50ZXJzZWN0IiwicmVjdCIsInNhZmVQb2x5Z29uIiwiYnVmZmVyIiwicmVxdWlyZUludGVudCIsImhhc0xhbmRlZCIsImxhc3RYIiwibGFzdFkiLCJsYXN0Q3Vyc29yVGltZSIsInBlcmZvcm1hbmNlIiwibm93IiwiZ2V0Q3Vyc29yU3BlZWQiLCJjdXJyZW50VGltZSIsImVsYXBzZWRUaW1lIiwiZGVsdGFYIiwiZGlzdGFuY2UiLCJzcXJ0Iiwic3BlZWQiLCJjbGllbnRQb2ludCIsImlzTGVhdmUiLCJpc092ZXJGbG9hdGluZ0VsIiwiaXNPdmVyUmVmZXJlbmNlRWwiLCJyZWZSZWN0IiwiY3Vyc29yTGVhdmVGcm9tUmlnaHQiLCJjdXJzb3JMZWF2ZUZyb21Cb3R0b20iLCJpc092ZXJSZWZlcmVuY2VSZWN0IiwiaXNGbG9hdGluZ1dpZGVyIiwiaXNGbG9hdGluZ1RhbGxlciIsInJlY3RQb2x5IiwiZ2V0UG9seWdvbiIsImN1cnNvclBvaW50T25lIiwiY3Vyc29yUG9pbnRUd28iLCJjb21tb25Qb2ludHMiLCJjdXJzb3JTcGVlZCIsImN1cnNvclNwZWVkVGhyZXNob2xkIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/react/dist/floating-ui.react.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@floating-ui/react/dist/floating-ui.react.utils.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/@floating-ui/react/dist/floating-ui.react.utils.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TYPEABLE_SELECTOR: () => (/* binding */ TYPEABLE_SELECTOR),\n/* harmony export */   activeElement: () => (/* binding */ activeElement),\n/* harmony export */   contains: () => (/* binding */ contains),\n/* harmony export */   getDocument: () => (/* binding */ getDocument),\n/* harmony export */   getPlatform: () => (/* binding */ getPlatform),\n/* harmony export */   getTarget: () => (/* binding */ getTarget),\n/* harmony export */   getUserAgent: () => (/* binding */ getUserAgent),\n/* harmony export */   isAndroid: () => (/* binding */ isAndroid),\n/* harmony export */   isEventTargetWithin: () => (/* binding */ isEventTargetWithin),\n/* harmony export */   isJSDOM: () => (/* binding */ isJSDOM),\n/* harmony export */   isMac: () => (/* binding */ isMac),\n/* harmony export */   isMouseLikePointerType: () => (/* binding */ isMouseLikePointerType),\n/* harmony export */   isReactEvent: () => (/* binding */ isReactEvent),\n/* harmony export */   isRootElement: () => (/* binding */ isRootElement),\n/* harmony export */   isSafari: () => (/* binding */ isSafari),\n/* harmony export */   isTypeableCombobox: () => (/* binding */ isTypeableCombobox),\n/* harmony export */   isTypeableElement: () => (/* binding */ isTypeableElement),\n/* harmony export */   isVirtualClick: () => (/* binding */ isVirtualClick),\n/* harmony export */   isVirtualPointerEvent: () => (/* binding */ isVirtualPointerEvent),\n/* harmony export */   stopEvent: () => (/* binding */ stopEvent)\n/* harmony export */ });\n/* harmony import */ var _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/utils/dom */ \"(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs\");\n\nfunction activeElement(doc) {\n  let activeElement = doc.activeElement;\n  while (((_activeElement = activeElement) == null || (_activeElement = _activeElement.shadowRoot) == null ? void 0 : _activeElement.activeElement) != null) {\n    var _activeElement;\n    activeElement = activeElement.shadowRoot.activeElement;\n  }\n  return activeElement;\n}\nfunction contains(parent, child) {\n  if (!parent || !child) {\n    return false;\n  }\n  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode();\n\n  // First, attempt with faster native method\n  if (parent.contains(child)) {\n    return true;\n  }\n\n  // then fallback to custom implementation with Shadow DOM support\n  if (rootNode && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isShadowRoot)(rootNode)) {\n    let next = child;\n    while (next) {\n      if (parent === next) {\n        return true;\n      }\n      // @ts-ignore\n      next = next.parentNode || next.host;\n    }\n  }\n\n  // Give up, the result is false\n  return false;\n}\n// Avoid Chrome DevTools blue warning.\nfunction getPlatform() {\n  const uaData = navigator.userAgentData;\n  if (uaData != null && uaData.platform) {\n    return uaData.platform;\n  }\n  return navigator.platform;\n}\nfunction getUserAgent() {\n  const uaData = navigator.userAgentData;\n  if (uaData && Array.isArray(uaData.brands)) {\n    return uaData.brands.map(_ref => {\n      let {\n        brand,\n        version\n      } = _ref;\n      return brand + \"/\" + version;\n    }).join(' ');\n  }\n  return navigator.userAgent;\n}\n\n// License: https://github.com/adobe/react-spectrum/blob/b35d5c02fe900badccd0cf1a8f23bb593419f238/packages/@react-aria/utils/src/isVirtualEvent.ts\nfunction isVirtualClick(event) {\n  // FIXME: Firefox is now emitting a deprecation warning for `mozInputSource`.\n  // Try to find a workaround for this. `react-aria` source still has the check.\n  if (event.mozInputSource === 0 && event.isTrusted) {\n    return true;\n  }\n  if (isAndroid() && event.pointerType) {\n    return event.type === 'click' && event.buttons === 1;\n  }\n  return event.detail === 0 && !event.pointerType;\n}\nfunction isVirtualPointerEvent(event) {\n  if (isJSDOM()) return false;\n  return !isAndroid() && event.width === 0 && event.height === 0 || isAndroid() && event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === 'mouse' ||\n  // iOS VoiceOver returns 0.333• for width/height.\n  event.width < 1 && event.height < 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === 'touch';\n}\nfunction isSafari() {\n  // Chrome DevTools does not complain about navigator.vendor\n  return /apple/i.test(navigator.vendor);\n}\nfunction isAndroid() {\n  const re = /android/i;\n  return re.test(getPlatform()) || re.test(getUserAgent());\n}\nfunction isMac() {\n  return getPlatform().toLowerCase().startsWith('mac') && !navigator.maxTouchPoints;\n}\nfunction isJSDOM() {\n  return getUserAgent().includes('jsdom/');\n}\nfunction isMouseLikePointerType(pointerType, strict) {\n  // On some Linux machines with Chromium, mouse inputs return a `pointerType`\n  // of \"pen\": https://github.com/floating-ui/floating-ui/issues/2015\n  const values = ['mouse', 'pen'];\n  if (!strict) {\n    values.push('', undefined);\n  }\n  return values.includes(pointerType);\n}\nfunction isReactEvent(event) {\n  return 'nativeEvent' in event;\n}\nfunction isRootElement(element) {\n  return element.matches('html,body');\n}\nfunction getDocument(node) {\n  return (node == null ? void 0 : node.ownerDocument) || document;\n}\nfunction isEventTargetWithin(event, node) {\n  if (node == null) {\n    return false;\n  }\n  if ('composedPath' in event) {\n    return event.composedPath().includes(node);\n  }\n\n  // TS thinks `event` is of type never as it assumes all browsers support composedPath, but browsers without shadow dom don't\n  const e = event;\n  return e.target != null && node.contains(e.target);\n}\nfunction getTarget(event) {\n  if ('composedPath' in event) {\n    return event.composedPath()[0];\n  }\n\n  // TS thinks `event` is of type never as it assumes all browsers support\n  // `composedPath()`, but browsers without shadow DOM don't.\n  return event.target;\n}\nconst TYPEABLE_SELECTOR = \"input:not([type='hidden']):not([disabled]),\" + \"[contenteditable]:not([contenteditable='false']),textarea:not([disabled])\";\nfunction isTypeableElement(element) {\n  return (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) && element.matches(TYPEABLE_SELECTOR);\n}\nfunction stopEvent(event) {\n  event.preventDefault();\n  event.stopPropagation();\n}\nfunction isTypeableCombobox(element) {\n  if (!element) return false;\n  return element.getAttribute('role') === 'combobox' && isTypeableElement(element);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3JlYWN0L2Rpc3QvZmxvYXRpbmctdWkucmVhY3QudXRpbHMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFxRTtBQUVyRSxTQUFTRSxhQUFhQSxDQUFDQyxHQUFHLEVBQUU7RUFDMUIsSUFBSUQsYUFBYSxHQUFHQyxHQUFHLENBQUNELGFBQWE7RUFDckMsT0FBTyxDQUFDLENBQUNFLGNBQWMsR0FBR0YsYUFBYSxLQUFLLElBQUksSUFBSSxDQUFDRSxjQUFjLEdBQUdBLGNBQWMsQ0FBQ0MsVUFBVSxLQUFLLElBQUksR0FBRyxLQUFLLENBQUMsR0FBR0QsY0FBYyxDQUFDRixhQUFhLEtBQUssSUFBSSxFQUFFO0lBQ3pKLElBQUlFLGNBQWM7SUFDbEJGLGFBQWEsR0FBR0EsYUFBYSxDQUFDRyxVQUFVLENBQUNILGFBQWE7RUFDeEQ7RUFDQSxPQUFPQSxhQUFhO0FBQ3RCO0FBQ0EsU0FBU0ksUUFBUUEsQ0FBQ0MsTUFBTSxFQUFFQyxLQUFLLEVBQUU7RUFDL0IsSUFBSSxDQUFDRCxNQUFNLElBQUksQ0FBQ0MsS0FBSyxFQUFFO0lBQ3JCLE9BQU8sS0FBSztFQUNkO0VBQ0EsTUFBTUMsUUFBUSxHQUFHRCxLQUFLLENBQUNFLFdBQVcsSUFBSSxJQUFJLEdBQUcsS0FBSyxDQUFDLEdBQUdGLEtBQUssQ0FBQ0UsV0FBVyxDQUFDLENBQUM7O0VBRXpFO0VBQ0EsSUFBSUgsTUFBTSxDQUFDRCxRQUFRLENBQUNFLEtBQUssQ0FBQyxFQUFFO0lBQzFCLE9BQU8sSUFBSTtFQUNiOztFQUVBO0VBQ0EsSUFBSUMsUUFBUSxJQUFJVCxvRUFBWSxDQUFDUyxRQUFRLENBQUMsRUFBRTtJQUN0QyxJQUFJRSxJQUFJLEdBQUdILEtBQUs7SUFDaEIsT0FBT0csSUFBSSxFQUFFO01BQ1gsSUFBSUosTUFBTSxLQUFLSSxJQUFJLEVBQUU7UUFDbkIsT0FBTyxJQUFJO01BQ2I7TUFDQTtNQUNBQSxJQUFJ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QUFNSyxDQUFDLEdBQUdyQyxLQUFLO0VBQ2YsT0FBT3FDLENBQUMsQ0FBQ0MsTUFBTSxJQUFJLElBQUksSUFBSU4sSUFBSSxDQUFDeEQsUUFBUSxDQUFDNkQsQ0FBQyxDQUFDQyxNQUFNLENBQUM7QUFDcEQ7QUFDQSxTQUFTQyxTQUFTQSxDQUFDdkMsS0FBSyxFQUFFO0VBQ3hCLElBQUksY0FBYyxJQUFJQSxLQUFLLEVBQUU7SUFDM0IsT0FBT0EsS0FBSyxDQUFDb0MsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7RUFDaEM7O0VBRUE7RUFDQTtFQUNBLE9BQU9wQyxLQUFLLENBQUNzQyxNQUFNO0FBQ3JCO0FBQ0EsTUFBTUUsaUJBQWlCLEdBQUcsNkNBQTZDLEdBQUcsMkVBQTJFO0FBQ3JKLFNBQVNDLGlCQUFpQkEsQ0FBQ1osT0FBTyxFQUFFO0VBQ2xDLE9BQU8xRCxxRUFBYSxDQUFDMEQsT0FBTyxDQUFDLElBQUlBLE9BQU8sQ0FBQ0MsT0FBTyxDQUFDVSxpQkFBaUIsQ0FBQztBQUNyRTtBQUNBLFNBQVNFLFNBQVNBLENBQUMxQyxLQUFLLEVBQUU7RUFDeEJBLEtBQUssQ0FBQzJDLGNBQWMsQ0FBQyxDQUFDO0VBQ3RCM0MsS0FBSyxDQUFDNEMsZUFBZSxDQUFDLENBQUM7QUFDekI7QUFDQSxTQUFTQyxrQkFBa0JBLENBQUNoQixPQUFPLEVBQUU7RUFDbkMsSUFBSSxDQUFDQSxPQUFPLEVBQUUsT0FBTyxLQUFLO0VBQzFCLE9BQU9BLE9BQU8sQ0FBQ2lCLFlBQVksQ0FBQyxNQUFNLENBQUMsS0FBSyxVQUFVLElBQUlMLGlCQUFpQixDQUFDWixPQUFPLENBQUM7QUFDbEYiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcRXJmYW5cXERlc2t0b3BcXDLZvtix2YjamNmHINuMINmF2K3ZhdivINi52LHZgdin2YYg2LHYttin24zbjFxcRXJmYW5kZXZcXC5mcm9udGVuZFxcbm9kZV9tb2R1bGVzXFxAZmxvYXRpbmctdWlcXHJlYWN0XFxkaXN0XFxmbG9hdGluZy11aS5yZWFjdC51dGlscy5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNTaGFkb3dSb290LCBpc0hUTUxFbGVtZW50IH0gZnJvbSAnQGZsb2F0aW5nLXVpL3V0aWxzL2RvbSc7XG5cbmZ1bmN0aW9uIGFjdGl2ZUVsZW1lbnQoZG9jKSB7XG4gIGxldCBhY3RpdmVFbGVtZW50ID0gZG9jLmFjdGl2ZUVsZW1lbnQ7XG4gIHdoaWxlICgoKF9hY3RpdmVFbGVtZW50ID0gYWN0aXZlRWxlbWVudCkgPT0gbnVsbCB8fCAoX2FjdGl2ZUVsZW1lbnQgPSBfYWN0aXZlRWxlbWVudC5zaGFkb3dSb290KSA9PSBudWxsID8gdm9pZCAwIDogX2FjdGl2ZUVsZW1lbnQuYWN0aXZlRWxlbWVudCkgIT0gbnVsbCkge1xuICAgIHZhciBfYWN0aXZlRWxlbWVudDtcbiAgICBhY3RpdmVFbGVtZW50ID0gYWN0aXZlRWxlbWVudC5zaGFkb3dSb290LmFjdGl2ZUVsZW1lbnQ7XG4gIH1cbiAgcmV0dXJuIGFjdGl2ZUVsZW1lbnQ7XG59XG5mdW5jdGlvbiBjb250YWlucyhwYXJlbnQsIGNoaWxkKSB7XG4gIGlmICghcGFyZW50IHx8ICFjaGlsZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCByb290Tm9kZSA9IGNoaWxkLmdldFJvb3ROb2RlID09IG51bGwgPyB2b2lkIDAgOiBjaGlsZC5nZXRSb290Tm9kZSgpO1xuXG4gIC8vIEZpcnN0LCBhdHRlbXB0IHdpdGggZmFzdGVyIG5hdGl2ZSBtZXRob2RcbiAgaWYgKHBhcmVudC5jb250YWlucyhjaGlsZCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIHRoZW4gZmFsbGJhY2sgdG8gY3VzdG9tIGltcGxlbWVudGF0aW9uIHdpdGggU2hhZG93IERPTSBzdXBwb3J0XG4gIGlmIChyb290Tm9kZSAmJiBpc1NoYWRvd1Jvb3Qocm9vdE5vZGUpKSB7XG4gICAgbGV0IG5leHQgPSBjaGlsZDtcbiAgICB3aGlsZSAobmV4dCkge1xuICAgICAgaWYgKHBhcmVudCA9PT0gbmV4dCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIG5leHQgPSBuZXh0LnBhcmVudE5vZGUgfHwgbmV4dC5ob3N0O1xuICAgIH1cbiAgfVxuXG4gIC8vIEdpdmUgdXAsIHRoZSByZXN1bHQgaXMgZmFsc2VcbiAgcmV0dXJuIGZhbHNlO1xufVxuLy8gQXZvaWQgQ2hyb21lIERldlRvb2xzIGJsdWUgd2FybmluZy5cbmZ1bmN0aW9uIGdldFBsYXRmb3JtKCkge1xuICBjb25zdCB1YURhdGEgPSBuYXZpZ2F0b3IudXNlckFnZW50RGF0YTtcbiAgaWYgKHVhRGF0YSAhPSBudWxsICYmIHVhRGF0YS5wbGF0Zm9ybSkge1xuICAgIHJldHVybiB1YURhdGEucGxhdGZvcm07XG4gIH1cbiAgcmV0dXJuIG5hdmlnYXRvci5wbGF0Zm9ybTtcbn1cbmZ1bmN0aW9uIGdldFVzZXJBZ2VudCgpIHtcbiAgY29uc3QgdWFEYXRhID0gbmF2aWdhdG9yLnVzZXJBZ2VudERhdGE7XG4gIGlmICh1YURhdGEgJiYgQXJyYXkuaXNBcnJheSh1YURhdGEuYnJhbmRzKSkge1xuICAgIHJldHVybiB1YURhdGEuYnJhbmRzLm1hcChfcmVmID0+IHtcbiAgICAgIGxldCB7XG4gICAgICAgIGJyYW5kLFxuICAgICAgICB2ZXJzaW9uXG4gICAgICB9ID0gX3JlZjtcbiAgICAgIHJldHVybiBicmFuZCArIFwiL1wiICsgdmVyc2lvbjtcbiAgICB9KS5qb2luKCcgJyk7XG4gIH1cbiAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQ7XG59XG5cbi8vIExpY2Vuc2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9hZG9iZS9yZWFjdC1zcGVjdHJ1bS9ibG9iL2IzNWQ1YzAyZmU5MDBiYWRjY2QwY2YxYThmMjNiYjU5MzQxOWYyMzgvcGFja2FnZXMvQHJlYWN0LWFyaWEvdXRpbHMvc3JjL2lzVmlydHVhbEV2ZW50LnRzXG5mdW5jdGlvbiBpc1ZpcnR1YWxDbGljayhldmVudCkge1xuICAvLyBGSVhNRTogRmlyZWZveCBpcyBub3cgZW1pdHRpbmcgYSBkZXByZWNhdGlvbiB3YXJuaW5nIGZvciBgbW96SW5wdXRTb3VyY2VgLlxuICAvLyBUcnkgdG8gZmluZCBhIHdvcmthcm91bmQgZm9yIHRoaXMuIGByZWFjdC1hcmlhYCBzb3VyY2Ugc3RpbGwgaGFzIHRoZSBjaGVjay5cbiAgaWYgKGV2ZW50Lm1veklucHV0U291cmNlID09PSAwICYmIGV2ZW50LmlzVHJ1c3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpc0FuZHJvaWQoKSAmJiBldmVudC5wb2ludGVyVHlwZSkge1xuICAgIHJldHVybiBldmVudC50eXBlID09PSAnY2xpY2snICYmIGV2ZW50LmJ1dHRvbnMgPT09IDE7XG4gIH1cbiAgcmV0dXJuIGV2ZW50LmRldGFpbCA9PT0gMCAmJiAhZXZlbnQucG9pbnRlclR5cGU7XG59XG5mdW5jdGlvbiBpc1ZpcnR1YWxQb2ludGVyRXZlbnQoZXZlbnQpIHtcbiAgaWYgKGlzSlNET00oKSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gIWlzQW5kcm9pZCgpICYmIGV2ZW50LndpZHRoID09PSAwICYmIGV2ZW50LmhlaWdodCA9PT0gMCB8fCBpc0FuZHJvaWQoKSAmJiBldmVudC53aWR0aCA9PT0gMSAmJiBldmVudC5oZWlnaHQgPT09IDEgJiYgZXZlbnQucHJlc3N1cmUgPT09IDAgJiYgZXZlbnQuZGV0YWlsID09PSAwICYmIGV2ZW50LnBvaW50ZXJUeXBlID09PSAnbW91c2UnIHx8XG4gIC8vIGlPUyBWb2ljZU92ZXIgcmV0dXJucyAwLjMzM+KAoiBmb3Igd2lkdGgvaGVpZ2h0LlxuICBldmVudC53aWR0aCA8IDEgJiYgZXZlbnQuaGVpZ2h0IDwgMSAmJiBldmVudC5wcmVzc3VyZSA9PT0gMCAmJiBldmVudC5kZXRhaWwgPT09IDAgJiYgZXZlbnQucG9pbnRlclR5cGUgPT09ICd0b3VjaCc7XG59XG5mdW5jdGlvbiBpc1NhZmFyaSgpIHtcbiAgLy8gQ2hyb21lIERldlRvb2xzIGRvZXMgbm90IGNvbXBsYWluIGFib3V0IG5hdmlnYXRvci52ZW5kb3JcbiAgcmV0dXJuIC9hcHBsZS9pLnRlc3QobmF2aWdhdG9yLnZlbmRvcik7XG59XG5mdW5jdGlvbiBpc0FuZHJvaWQoKSB7XG4gIGNvbnN0IHJlID0gL2FuZHJvaWQvaTtcbiAgcmV0dXJuIHJlLnRlc3QoZ2V0UGxhdGZvcm0oKSkgfHwgcmUudGVzdChnZXRVc2VyQWdlbnQoKSk7XG59XG5mdW5jdGlvbiBpc01hYygpIHtcbiAgcmV0dXJuIGdldFBsYXRmb3JtKCkudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCdtYWMnKSAmJiAhbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzO1xufVxuZnVuY3Rpb24gaXNKU0RPTSgpIHtcbiAgcmV0dXJuIGdldFVzZXJBZ2VudCgpLmluY2x1ZGVzKCdqc2RvbS8nKTtcbn1cbmZ1bmN0aW9uIGlzTW91c2VMaWtlUG9pbnRlclR5cGUocG9pbnRlclR5cGUsIHN0cmljdCkge1xuICAvLyBPbiBzb21lIExpbnV4IG1hY2hpbmVzIHdpdGggQ2hyb21pdW0sIG1vdXNlIGlucHV0cyByZXR1cm4gYSBgcG9pbnRlclR5cGVgXG4gIC8vIG9mIFwicGVuXCI6IGh0dHBzOi8vZ2l0aHViLmNvbS9mbG9hdGluZy11aS9mbG9hdGluZy11aS9pc3N1ZXMvMjAxNVxuICBjb25zdCB2YWx1ZXMgPSBbJ21vdXNlJywgJ3BlbiddO1xuICBpZiAoIXN0cmljdCkge1xuICAgIHZhbHVlcy5wdXNoKCcnLCB1bmRlZmluZWQpO1xuICB9XG4gIHJldHVybiB2YWx1ZXMuaW5jbHVkZXMocG9pbnRlclR5cGUpO1xufVxuZnVuY3Rpb24gaXNSZWFjdEV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiAnbmF0aXZlRXZlbnQnIGluIGV2ZW50O1xufVxuZnVuY3Rpb24gaXNSb290RWxlbWVudChlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50Lm1hdGNoZXMoJ2h0bWwsYm9keScpO1xufVxuZnVuY3Rpb24gZ2V0RG9jdW1lbnQobm9kZSkge1xuICByZXR1cm4gKG5vZGUgPT0gbnVsbCA/IHZvaWQgMCA6IG5vZGUub3duZXJEb2N1bWVudCkgfHwgZG9jdW1lbnQ7XG59XG5mdW5jdGlvbiBpc0V2ZW50VGFyZ2V0V2l0aGluKGV2ZW50LCBub2RlKSB7XG4gIGlmIChub2RlID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCdjb21wb3NlZFBhdGgnIGluIGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LmNvbXBvc2VkUGF0aCgpLmluY2x1ZGVzKG5vZGUpO1xuICB9XG5cbiAgLy8gVFMgdGhpbmtzIGBldmVudGAgaXMgb2YgdHlwZSBuZXZlciBhcyBpdCBhc3N1bWVzIGFsbCBicm93c2VycyBzdXBwb3J0IGNvbXBvc2VkUGF0aCwgYnV0IGJyb3dzZXJzIHdpdGhvdXQgc2hhZG93IGRvbSBkb24ndFxuICBjb25zdCBlID0gZXZlbnQ7XG4gIHJldHVybiBlLnRhcmdldCAhPSBudWxsICYmIG5vZGUuY29udGFpbnMoZS50YXJnZXQpO1xufVxuZnVuY3Rpb24gZ2V0VGFyZ2V0KGV2ZW50KSB7XG4gIGlmICgnY29tcG9zZWRQYXRoJyBpbiBldmVudCkge1xuICAgIHJldHVybiBldmVudC5jb21wb3NlZFBhdGgoKVswXTtcbiAgfVxuXG4gIC8vIFRTIHRoaW5rcyBgZXZlbnRgIGlzIG9mIHR5cGUgbmV2ZXIgYXMgaXQgYXNzdW1lcyBhbGwgYnJvd3NlcnMgc3VwcG9ydFxuICAvLyBgY29tcG9zZWRQYXRoKClgLCBidXQgYnJvd3NlcnMgd2l0aG91dCBzaGFkb3cgRE9NIGRvbid0LlxuICByZXR1cm4gZXZlbnQudGFyZ2V0O1xufVxuY29uc3QgVFlQRUFCTEVfU0VMRUNUT1IgPSBcImlucHV0Om5vdChbdHlwZT0naGlkZGVuJ10pOm5vdChbZGlzYWJsZWRdKSxcIiArIFwiW2NvbnRlbnRlZGl0YWJsZV06bm90KFtjb250ZW50ZWRpdGFibGU9J2ZhbHNlJ10pLHRleHRhcmVhOm5vdChbZGlzYWJsZWRdKVwiO1xuZnVuY3Rpb24gaXNUeXBlYWJsZUVsZW1lbnQoZWxlbWVudCkge1xuICByZXR1cm4gaXNIVE1MRWxlbWVudChlbGVtZW50KSAmJiBlbGVtZW50Lm1hdGNoZXMoVFlQRUFCTEVfU0VMRUNUT1IpO1xufVxuZnVuY3Rpb24gc3RvcEV2ZW50KGV2ZW50KSB7XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xufVxuZnVuY3Rpb24gaXNUeXBlYWJsZUNvbWJvYm94KGVsZW1lbnQpIHtcbiAgaWYgKCFlbGVtZW50KSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZSgncm9sZScpID09PSAnY29tYm9ib3gnICYmIGlzVHlwZWFibGVFbGVtZW50KGVsZW1lbnQpO1xufVxuXG5leHBvcnQgeyBUWVBFQUJMRV9TRUxFQ1RPUiwgYWN0aXZlRWxlbWVudCwgY29udGFpbnMsIGdldERvY3VtZW50LCBnZXRQbGF0Zm9ybSwgZ2V0VGFyZ2V0LCBnZXRVc2VyQWdlbnQsIGlzQW5kcm9pZCwgaXNFdmVudFRhcmdldFdpdGhpbiwgaXNKU0RPTSwgaXNNYWMsIGlzTW91c2VMaWtlUG9pbnRlclR5cGUsIGlzUmVhY3RFdmVudCwgaXNSb290RWxlbWVudCwgaXNTYWZhcmksIGlzVHlwZWFibGVDb21ib2JveCwgaXNUeXBlYWJsZUVsZW1lbnQsIGlzVmlydHVhbENsaWNrLCBpc1ZpcnR1YWxQb2ludGVyRXZlbnQsIHN0b3BFdmVudCB9O1xuIl0sIm5hbWVzIjpbImlzU2hhZG93Um9vdCIsImlzSFRNTEVsZW1lbnQiLCJhY3RpdmVFbGVtZW50IiwiZG9jIiwiX2FjdGl2ZUVsZW1lbnQiLCJzaGFkb3dSb290IiwiY29udGFpbnMiLCJwYXJlbnQiLCJjaGlsZCIsInJvb3ROb2RlIiwiZ2V0Um9vdE5vZGUiLCJuZXh0IiwicGFyZW50Tm9kZSIsImhvc3QiLCJnZXRQbGF0Zm9ybSIsInVhRGF0YSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudERhdGEiLCJwbGF0Zm9ybSIsImdldFVzZXJBZ2VudCIsIkFycmF5IiwiaXNBcnJheSIsImJyYW5kcyIsIm1hcCIsIl9yZWYiLCJicmFuZCIsInZlcnNpb24iLCJqb2luIiwidXNlckFnZW50IiwiaXNWaXJ0dWFsQ2xpY2siLCJldmVudCIsIm1veklucHV0U291cmNlIiwiaXNUcnVzdGVkIiwiaXNBbmRyb2lkIiwicG9pbnRlclR5cGUiLCJ0eXBlIiwiYnV0dG9ucyIsImRldGFpbCIsImlzVmlydHVhbFBvaW50ZXJFdmVudCIsImlzSlNET00iLCJ3aWR0aCIsImhlaWdodCIsInByZXNzdXJlIiwiaXNTYWZhcmkiLCJ0ZXN0IiwidmVuZG9yIiwicmUiLCJpc01hYyIsInRvTG93ZXJDYXNlIiwic3RhcnRzV2l0aCIsIm1heFRvdWNoUG9pbnRzIiwiaW5jbHVkZXMiLCJpc01vdXNlTGlrZVBvaW50ZXJUeXBlIiwic3RyaWN0IiwidmFsdWVzIiwicHVzaCIsInVuZGVmaW5lZCIsImlzUmVhY3RFdmVudCIsImlzUm9vdEVsZW1lbnQiLCJlbGVtZW50IiwibWF0Y2hlcyIsImdldERvY3VtZW50Iiwibm9kZSIsIm93bmVyRG9jdW1lbnQiLCJkb2N1bWVudCIsImlzRXZlbnRUYXJnZXRXaXRoaW4iLCJjb21wb3NlZFBhdGgiLCJlIiwidGFyZ2V0IiwiZ2V0VGFyZ2V0IiwiVFlQRUFCTEVfU0VMRUNUT1IiLCJpc1R5cGVhYmxlRWxlbWVudCIsInN0b3BFdmVudCIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwiaXNUeXBlYWJsZUNvbWJvYm94IiwiZ2V0QXR0cmlidXRlIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/react/dist/floating-ui.react.utils.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getComputedStyle: () => (/* binding */ getComputedStyle),\n/* harmony export */   getContainingBlock: () => (/* binding */ getContainingBlock),\n/* harmony export */   getDocumentElement: () => (/* binding */ getDocumentElement),\n/* harmony export */   getFrameElement: () => (/* binding */ getFrameElement),\n/* harmony export */   getNearestOverflowAncestor: () => (/* binding */ getNearestOverflowAncestor),\n/* harmony export */   getNodeName: () => (/* binding */ getNodeName),\n/* harmony export */   getNodeScroll: () => (/* binding */ getNodeScroll),\n/* harmony export */   getOverflowAncestors: () => (/* binding */ getOverflowAncestors),\n/* harmony export */   getParentNode: () => (/* binding */ getParentNode),\n/* harmony export */   getWindow: () => (/* binding */ getWindow),\n/* harmony export */   isContainingBlock: () => (/* binding */ isContainingBlock),\n/* harmony export */   isElement: () => (/* binding */ isElement),\n/* harmony export */   isHTMLElement: () => (/* binding */ isHTMLElement),\n/* harmony export */   isLastTraversableNode: () => (/* binding */ isLastTraversableNode),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   isOverflowElement: () => (/* binding */ isOverflowElement),\n/* harmony export */   isShadowRoot: () => (/* binding */ isShadowRoot),\n/* harmony export */   isTableElement: () => (/* binding */ isTableElement),\n/* harmony export */   isTopLayer: () => (/* binding */ isTopLayer),\n/* harmony export */   isWebKit: () => (/* binding */ isWebKit)\n/* harmony export */ });\nfunction hasWindow() {\n  return false;\n}\nfunction getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  }\n  // Mocked nodes in testing environments may not be instances of Node. By\n  // returning `#document` an infinite loop won't occur.\n  // https://github.com/floating-ui/floating-ui/issues/2317\n  return '#document';\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n  if (!hasWindow() || typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nconst invalidOverflowDisplayValues = /*#__PURE__*/new Set(['inline', 'contents']);\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);\n}\nconst tableElements = /*#__PURE__*/new Set(['table', 'td', 'th']);\nfunction isTableElement(element) {\n  return tableElements.has(getNodeName(element));\n}\nconst topLayerSelectors = [':popover-open', ':modal'];\nfunction isTopLayer(element) {\n  return topLayerSelectors.some(selector => {\n    try {\n      return element.matches(selector);\n    } catch (_e) {\n      return false;\n    }\n  });\n}\nconst transformProperties = ['transform', 'translate', 'scale', 'rotate', 'perspective'];\nconst willChangeValues = ['transform', 'translate', 'scale', 'rotate', 'perspective', 'filter'];\nconst containValues = ['paint', 'layout', 'strict', 'content'];\nfunction isContainingBlock(elementOrCss) {\n  const webkit = isWebKit();\n  const css = isElement(elementOrCss) ? getComputedStyle(elementOrCss) : elementOrCss;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  // https://drafts.csswg.org/css-transforms-2/#individual-transforms\n  return transformProperties.some(value => css[value] ? css[value] !== 'none' : false) || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || willChangeValues.some(value => (css.willChange || '').includes(value)) || containValues.some(value => (css.contain || '').includes(value));\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else if (isTopLayer(currentNode)) {\n      return null;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  return null;\n}\nfunction isWebKit() {\n  if (typeof CSS === 'undefined' || !CSS.supports) return false;\n  return CSS.supports('-webkit-backdrop-filter', 'none');\n}\nconst lastTraversableNodeNames = /*#__PURE__*/new Set(['html', 'body', '#document']);\nfunction isLastTraversableNode(node) {\n  return lastTraversableNodeNames.has(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.scrollX,\n    scrollTop: element.scrollY\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n  var _node$ownerDocument2;\n  if (list === void 0) {\n    list = [];\n  }\n  if (traverseIframes === void 0) {\n    traverseIframes = true;\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    const frameElement = getFrameElement(win);\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\nfunction getFrameElement(win) {\n  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3V0aWxzL2Rpc3QvZmxvYXRpbmctdWkudXRpbHMuZG9tLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLFNBQVNBLFNBQVNBLENBQUEsRUFBRztFQUNuQjtBQUNGO0FBQ0EsU0FBU0MsV0FBV0EsQ0FBQ0MsSUFBSSxFQUFFO0VBQ3pCLElBQUlDLE1BQU0sQ0FBQ0QsSUFBSSxDQUFDLEVBQUU7SUFDaEIsT0FBTyxDQUFDQSxJQUFJLENBQUNFLFFBQVEsSUFBSSxFQUFFLEVBQUVDLFdBQVcsQ0FBQyxDQUFDO0VBQzVDO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsT0FBTyxXQUFXO0FBQ3BCO0FBQ0EsU0FBU0MsU0FBU0EsQ0FBQ0osSUFBSSxFQUFFO0VBQ3ZCLElBQUlLLG1CQUFtQjtFQUN2QixPQUFPLENBQUNMLElBQUksSUFBSSxJQUFJLElBQUksQ0FBQ0ssbUJBQW1CLEdBQUdMLElBQUksQ0FBQ00sYUFBYSxLQUFLLElBQUksR0FBRyxLQUFLLENBQUMsR0FBR0QsbUJBQW1CLENBQUNFLFdBQVcsS0FBS0MsTUFBTTtBQUNsSTtBQUNBLFNBQVNDLGtCQUFrQkEsQ0FBQ1QsSUFBSSxFQUFFO0VBQ2hDLElBQUlVLElBQUk7RUFDUixPQUFPLENBQUNBLElBQUksR0FBRyxDQUFDVCxNQUFNLENBQUNELElBQUksQ0FBQyxHQUFHQSxJQUFJLENBQUNNLGFBQWEsR0FBR04sSUFBSSxDQUFDVyxRQUFRLEtBQUtILE1BQU0sQ0FBQ0csUUFBUSxLQUFLLElBQUksR0FBRyxLQUFLLENBQUMsR0FBR0QsSUFBSSxDQUFDRSxlQUFlO0FBQ2hJO0FBQ0EsU0FBU1gsTUFBTUEsQ0FBQ1ksS0FBSyxFQUFFO0VBQ3JCLElBQUksQ0FBQ2YsU0FBUyxDQUFDLENBQUMsRUFBRTtJQUNoQixPQUFPLEtBQUs7RUFDZDtFQUNBLE9BQU9lLEtBQUssWUFBWUMsSUFBSSxJQUFJRCxLQUFLLFlBQVlULFNBQVMsQ0FB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RSxrQkFBa0IsQ0FBQztFQUN6QyxJQUFJQyxNQUFNLEVBQUU7SUFDVixNQUFNRSxZQUFZLEdBQUdDLGVBQWUsQ0FBQ0YsR0FBRyxDQUFDO0lBQ3pDLE9BQU9MLElBQUksQ0FBQ1EsTUFBTSxDQUFDSCxHQUFHLEVBQUVBLEdBQUcsQ0FBQ0ksY0FBYyxJQUFJLEVBQUUsRUFBRTNELGlCQUFpQixDQUFDcUQsa0JBQWtCLENBQUMsR0FBR0Esa0JBQWtCLEdBQUcsRUFBRSxFQUFFRyxZQUFZLElBQUlMLGVBQWUsR0FBR0Ysb0JBQW9CLENBQUNPLFlBQVksQ0FBQyxHQUFHLEVBQUUsQ0FBQztFQUMvTDtFQUNBLE9BQU9OLElBQUksQ0FBQ1EsTUFBTSxDQUFDTCxrQkFBa0IsRUFBRUosb0JBQW9CLENBQUNJLGtCQUFrQixFQUFFLEVBQUUsRUFBRUYsZUFBZSxDQUFDLENBQUM7QUFDdkc7QUFDQSxTQUFTTSxlQUFlQSxDQUFDRixHQUFHLEVBQUU7RUFDNUIsT0FBT0EsR0FBRyxDQUFDSyxNQUFNLElBQUlDLE1BQU0sQ0FBQ0MsY0FBYyxDQUFDUCxHQUFHLENBQUNLLE1BQU0sQ0FBQyxHQUFHTCxHQUFHLENBQUNDLFlBQVksR0FBRyxJQUFJO0FBQ2xGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEVyZmFuXFxEZXNrdG9wXFwy2b7YsdmI2pjZhyDbjCDZhdit2YXYryDYudix2YHYp9mGINix2LbYp9uM24xcXEVyZmFuZGV2XFwuZnJvbnRlbmRcXG5vZGVfbW9kdWxlc1xcQGZsb2F0aW5nLXVpXFx1dGlsc1xcZGlzdFxcZmxvYXRpbmctdWkudXRpbHMuZG9tLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBoYXNXaW5kb3coKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbn1cbmZ1bmN0aW9uIGdldE5vZGVOYW1lKG5vZGUpIHtcbiAgaWYgKGlzTm9kZShub2RlKSkge1xuICAgIHJldHVybiAobm9kZS5ub2RlTmFtZSB8fCAnJykudG9Mb3dlckNhc2UoKTtcbiAgfVxuICAvLyBNb2NrZWQgbm9kZXMgaW4gdGVzdGluZyBlbnZpcm9ubWVudHMgbWF5IG5vdCBiZSBpbnN0YW5jZXMgb2YgTm9kZS4gQnlcbiAgLy8gcmV0dXJuaW5nIGAjZG9jdW1lbnRgIGFuIGluZmluaXRlIGxvb3Agd29uJ3Qgb2NjdXIuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mbG9hdGluZy11aS9mbG9hdGluZy11aS9pc3N1ZXMvMjMxN1xuICByZXR1cm4gJyNkb2N1bWVudCc7XG59XG5mdW5jdGlvbiBnZXRXaW5kb3cobm9kZSkge1xuICB2YXIgX25vZGUkb3duZXJEb2N1bWVudDtcbiAgcmV0dXJuIChub2RlID09IG51bGwgfHwgKF9ub2RlJG93bmVyRG9jdW1lbnQgPSBub2RlLm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KSB8fCB3aW5kb3c7XG59XG5mdW5jdGlvbiBnZXREb2N1bWVudEVsZW1lbnQobm9kZSkge1xuICB2YXIgX3JlZjtcbiAgcmV0dXJuIChfcmVmID0gKGlzTm9kZShub2RlKSA/IG5vZGUub3duZXJEb2N1bWVudCA6IG5vZGUuZG9jdW1lbnQpIHx8IHdpbmRvdy5kb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yZWYuZG9jdW1lbnRFbGVtZW50O1xufVxuZnVuY3Rpb24gaXNOb2RlKHZhbHVlKSB7XG4gIGlmICghaGFzV2luZG93KCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgTm9kZSB8fCB2YWx1ZSBpbnN0YW5jZW9mIGdldFdpbmRvdyh2YWx1ZSkuTm9kZTtcbn1cbmZ1bmN0aW9uIGlzRWxlbWVudCh2YWx1ZSkge1xuICBpZiAoIWhhc1dpbmRvdygpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEVsZW1lbnQgfHwgdmFsdWUgaW5zdGFuY2VvZiBnZXRXaW5kb3codmFsdWUpLkVsZW1lbnQ7XG59XG5mdW5jdGlvbiBpc0hUTUxFbGVtZW50KHZhbHVlKSB7XG4gIGlmICghaGFzV2luZG93KCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgfHwgdmFsdWUgaW5zdGFuY2VvZiBnZXRXaW5kb3codmFsdWUpLkhUTUxFbGVtZW50O1xufVxuZnVuY3Rpb24gaXNTaGFkb3dSb290KHZhbHVlKSB7XG4gIGlmICghaGFzV2luZG93KCkgfHwgdHlwZW9mIFNoYWRvd1Jvb3QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QgfHwgdmFsdWUgaW5zdGFuY2VvZiBnZXRXaW5kb3codmFsdWUpLlNoYWRvd1Jvb3Q7XG59XG5jb25zdCBpbnZhbGlkT3ZlcmZsb3dEaXNwbGF5VmFsdWVzID0gLyojX19QVVJFX18qL25ldyBTZXQoWydpbmxpbmUnLCAnY29udGVudHMnXSk7XG5mdW5jdGlvbiBpc092ZXJmbG93RWxlbWVudChlbGVtZW50KSB7XG4gIGNvbnN0IHtcbiAgICBvdmVyZmxvdyxcbiAgICBvdmVyZmxvd1gsXG4gICAgb3ZlcmZsb3dZLFxuICAgIGRpc3BsYXlcbiAgfSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gIHJldHVybiAvYXV0b3xzY3JvbGx8b3ZlcmxheXxoaWRkZW58Y2xpcC8udGVzdChvdmVyZmxvdyArIG92ZXJmbG93WSArIG92ZXJmbG93WCkgJiYgIWludmFsaWRPdmVyZmxvd0Rpc3BsYXlWYWx1ZXMuaGFzKGRpc3BsYXkpO1xufVxuY29uc3QgdGFibGVFbGVtZW50cyA9IC8qI19fUFVSRV9fKi9uZXcgU2V0KFsndGFibGUnLCAndGQnLCAndGgnXSk7XG5mdW5jdGlvbiBpc1RhYmxlRWxlbWVudChlbGVtZW50KSB7XG4gIHJldHVybiB0YWJsZUVsZW1lbnRzLmhhcyhnZXROb2RlTmFtZShlbGVtZW50KSk7XG59XG5jb25zdCB0b3BMYXllclNlbGVjdG9ycyA9IFsnOnBvcG92ZXItb3BlbicsICc6bW9kYWwnXTtcbmZ1bmN0aW9uIGlzVG9wTGF5ZXIoZWxlbWVudCkge1xuICByZXR1cm4gdG9wTGF5ZXJTZWxlY3RvcnMuc29tZShzZWxlY3RvciA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBlbGVtZW50Lm1hdGNoZXMoc2VsZWN0b3IpO1xuICAgIH0gY2F0Y2ggKF9lKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9KTtcbn1cbmNvbnN0IHRyYW5zZm9ybVByb3BlcnRpZXMgPSBbJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUnLCAnc2NhbGUnLCAncm90YXRlJywgJ3BlcnNwZWN0aXZlJ107XG5jb25zdCB3aWxsQ2hhbmdlVmFsdWVzID0gWyd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlJywgJ3NjYWxlJywgJ3JvdGF0ZScsICdwZXJzcGVjdGl2ZScsICdmaWx0ZXInXTtcbmNvbnN0IGNvbnRhaW5WYWx1ZXMgPSBbJ3BhaW50JywgJ2xheW91dCcsICdzdHJpY3QnLCAnY29udGVudCddO1xuZnVuY3Rpb24gaXNDb250YWluaW5nQmxvY2soZWxlbWVudE9yQ3NzKSB7XG4gIGNvbnN0IHdlYmtpdCA9IGlzV2ViS2l0KCk7XG4gIGNvbnN0IGNzcyA9IGlzRWxlbWVudChlbGVtZW50T3JDc3MpID8gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50T3JDc3MpIDogZWxlbWVudE9yQ3NzO1xuXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9Db250YWluaW5nX2Jsb2NrI2lkZW50aWZ5aW5nX3RoZV9jb250YWluaW5nX2Jsb2NrXG4gIC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3MtdHJhbnNmb3Jtcy0yLyNpbmRpdmlkdWFsLXRyYW5zZm9ybXNcbiAgcmV0dXJuIHRyYW5zZm9ybVByb3BlcnRpZXMuc29tZSh2YWx1ZSA9PiBjc3NbdmFsdWVdID8gY3NzW3ZhbHVlXSAhPT0gJ25vbmUnIDogZmFsc2UpIHx8IChjc3MuY29udGFpbmVyVHlwZSA/IGNzcy5jb250YWluZXJUeXBlICE9PSAnbm9ybWFsJyA6IGZhbHNlKSB8fCAhd2Via2l0ICYmIChjc3MuYmFja2Ryb3BGaWx0ZXIgPyBjc3MuYmFja2Ryb3BGaWx0ZXIgIT09ICdub25lJyA6IGZhbHNlKSB8fCAhd2Via2l0ICYmIChjc3MuZmlsdGVyID8gY3NzLmZpbHRlciAhPT0gJ25vbmUnIDogZmFsc2UpIHx8IHdpbGxDaGFuZ2VWYWx1ZXMuc29tZSh2YWx1ZSA9PiAoY3NzLndpbGxDaGFuZ2UgfHwgJycpLmluY2x1ZGVzKHZhbHVlKSkgfHwgY29udGFpblZhbHVlcy5zb21lKHZhbHVlID0+IChjc3MuY29udGFpbiB8fCAnJykuaW5jbHVkZXModmFsdWUpKTtcbn1cbmZ1bmN0aW9uIGdldENvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB7XG4gIGxldCBjdXJyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoZWxlbWVudCk7XG4gIHdoaWxlIChpc0hUTUxFbGVtZW50KGN1cnJlbnROb2RlKSAmJiAhaXNMYXN0VHJhdmVyc2FibGVOb2RlKGN1cnJlbnROb2RlKSkge1xuICAgIGlmIChpc0NvbnRhaW5pbmdCbG9jayhjdXJyZW50Tm9kZSkpIHtcbiAgICAgIHJldHVybiBjdXJyZW50Tm9kZTtcbiAgICB9IGVsc2UgaWYgKGlzVG9wTGF5ZXIoY3VycmVudE5vZGUpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY3VycmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGN1cnJlbnROb2RlKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzV2ViS2l0KCkge1xuICBpZiAodHlwZW9mIENTUyA9PT0gJ3VuZGVmaW5lZCcgfHwgIUNTUy5zdXBwb3J0cykgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gQ1NTLnN1cHBvcnRzKCctd2Via2l0LWJhY2tkcm9wLWZpbHRlcicsICdub25lJyk7XG59XG5jb25zdCBsYXN0VHJhdmVyc2FibGVOb2RlTmFtZXMgPSAvKiNfX1BVUkVfXyovbmV3IFNldChbJ2h0bWwnLCAnYm9keScsICcjZG9jdW1lbnQnXSk7XG5mdW5jdGlvbiBpc0xhc3RUcmF2ZXJzYWJsZU5vZGUobm9kZSkge1xuICByZXR1cm4gbGFzdFRyYXZlcnNhYmxlTm9kZU5hbWVzLmhhcyhnZXROb2RlTmFtZShub2RlKSk7XG59XG5mdW5jdGlvbiBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldFdpbmRvdyhlbGVtZW50KS5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xufVxuZnVuY3Rpb24gZ2V0Tm9kZVNjcm9sbChlbGVtZW50KSB7XG4gIGlmIChpc0VsZW1lbnQoZWxlbWVudCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2Nyb2xsTGVmdDogZWxlbWVudC5zY3JvbGxMZWZ0LFxuICAgICAgc2Nyb2xsVG9wOiBlbGVtZW50LnNjcm9sbFRvcFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxMZWZ0OiBlbGVtZW50LnNjcm9sbFgsXG4gICAgc2Nyb2xsVG9wOiBlbGVtZW50LnNjcm9sbFlcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFBhcmVudE5vZGUobm9kZSkge1xuICBpZiAoZ2V0Tm9kZU5hbWUobm9kZSkgPT09ICdodG1sJykge1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9XG4gIC8vIFN0ZXAgaW50byB0aGUgc2hhZG93IERPTSBvZiB0aGUgcGFyZW50IG9mIGEgc2xvdHRlZCBub2RlLlxuICBub2RlLmFzc2lnbmVkU2xvdCB8fFxuICAvLyBET00gRWxlbWVudCBkZXRlY3RlZC5cbiAgbm9kZS5wYXJlbnROb2RlIHx8XG4gIC8vIFNoYWRvd1Jvb3QgZGV0ZWN0ZWQuXG4gIGlzU2hhZG93Um9vdChub2RlKSAmJiBub2RlLmhvc3QgfHxcbiAgLy8gRmFsbGJhY2suXG4gIGdldERvY3VtZW50RWxlbWVudChub2RlKTtcbiAgcmV0dXJuIGlzU2hhZG93Um9vdChyZXN1bHQpID8gcmVzdWx0Lmhvc3QgOiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXROZWFyZXN0T3ZlcmZsb3dBbmNlc3Rvcihub2RlKSB7XG4gIGNvbnN0IHBhcmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKG5vZGUpO1xuICBpZiAoaXNMYXN0VHJhdmVyc2FibGVOb2RlKHBhcmVudE5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGUub3duZXJEb2N1bWVudCA/IG5vZGUub3duZXJEb2N1bWVudC5ib2R5IDogbm9kZS5ib2R5O1xuICB9XG4gIGlmIChpc0hUTUxFbGVtZW50KHBhcmVudE5vZGUpICYmIGlzT3ZlcmZsb3dFbGVtZW50KHBhcmVudE5vZGUpKSB7XG4gICAgcmV0dXJuIHBhcmVudE5vZGU7XG4gIH1cbiAgcmV0dXJuIGdldE5lYXJlc3RPdmVyZmxvd0FuY2VzdG9yKHBhcmVudE5vZGUpO1xufVxuZnVuY3Rpb24gZ2V0T3ZlcmZsb3dBbmNlc3RvcnMobm9kZSwgbGlzdCwgdHJhdmVyc2VJZnJhbWVzKSB7XG4gIHZhciBfbm9kZSRvd25lckRvY3VtZW50MjtcbiAgaWYgKGxpc3QgPT09IHZvaWQgMCkge1xuICAgIGxpc3QgPSBbXTtcbiAgfVxuICBpZiAodHJhdmVyc2VJZnJhbWVzID09PSB2b2lkIDApIHtcbiAgICB0cmF2ZXJzZUlmcmFtZXMgPSB0cnVlO1xuICB9XG4gIGNvbnN0IHNjcm9sbGFibGVBbmNlc3RvciA9IGdldE5lYXJlc3RPdmVyZmxvd0FuY2VzdG9yKG5vZGUpO1xuICBjb25zdCBpc0JvZHkgPSBzY3JvbGxhYmxlQW5jZXN0b3IgPT09ICgoX25vZGUkb3duZXJEb2N1bWVudDIgPSBub2RlLm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRvd25lckRvY3VtZW50Mi5ib2R5KTtcbiAgY29uc3Qgd2luID0gZ2V0V2luZG93KHNjcm9sbGFibGVBbmNlc3Rvcik7XG4gIGlmIChpc0JvZHkpIHtcbiAgICBjb25zdCBmcmFtZUVsZW1lbnQgPSBnZXRGcmFtZUVsZW1lbnQod2luKTtcbiAgICByZXR1cm4gbGlzdC5jb25jYXQod2luLCB3aW4udmlzdWFsVmlld3BvcnQgfHwgW10sIGlzT3ZlcmZsb3dFbGVtZW50KHNjcm9sbGFibGVBbmNlc3RvcikgPyBzY3JvbGxhYmxlQW5jZXN0b3IgOiBbXSwgZnJhbWVFbGVtZW50ICYmIHRyYXZlcnNlSWZyYW1lcyA/IGdldE92ZXJmbG93QW5jZXN0b3JzKGZyYW1lRWxlbWVudCkgOiBbXSk7XG4gIH1cbiAgcmV0dXJuIGxpc3QuY29uY2F0KHNjcm9sbGFibGVBbmNlc3RvciwgZ2V0T3ZlcmZsb3dBbmNlc3RvcnMoc2Nyb2xsYWJsZUFuY2VzdG9yLCBbXSwgdHJhdmVyc2VJZnJhbWVzKSk7XG59XG5mdW5jdGlvbiBnZXRGcmFtZUVsZW1lbnQod2luKSB7XG4gIHJldHVybiB3aW4ucGFyZW50ICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZih3aW4ucGFyZW50KSA/IHdpbi5mcmFtZUVsZW1lbnQgOiBudWxsO1xufVxuXG5leHBvcnQgeyBnZXRDb21wdXRlZFN0eWxlLCBnZXRDb250YWluaW5nQmxvY2ssIGdldERvY3VtZW50RWxlbWVudCwgZ2V0RnJhbWVFbGVtZW50LCBnZXROZWFyZXN0T3ZlcmZsb3dBbmNlc3RvciwgZ2V0Tm9kZU5hbWUsIGdldE5vZGVTY3JvbGwsIGdldE92ZXJmbG93QW5jZXN0b3JzLCBnZXRQYXJlbnROb2RlLCBnZXRXaW5kb3csIGlzQ29udGFpbmluZ0Jsb2NrLCBpc0VsZW1lbnQsIGlzSFRNTEVsZW1lbnQsIGlzTGFzdFRyYXZlcnNhYmxlTm9kZSwgaXNOb2RlLCBpc092ZXJmbG93RWxlbWVudCwgaXNTaGFkb3dSb290LCBpc1RhYmxlRWxlbWVudCwgaXNUb3BMYXllciwgaXNXZWJLaXQgfTtcbiJdLCJuYW1lcyI6WyJoYXNXaW5kb3ciLCJnZXROb2RlTmFtZSIsIm5vZGUiLCJpc05vZGUiLCJub2RlTmFtZSIsInRvTG93ZXJDYXNlIiwiZ2V0V2luZG93IiwiX25vZGUkb3duZXJEb2N1bWVudCIsIm93bmVyRG9jdW1lbnQiLCJkZWZhdWx0VmlldyIsIndpbmRvdyIsImdldERvY3VtZW50RWxlbWVudCIsIl9yZWYiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsInZhbHVlIiwiTm9kZSIsImlzRWxlbWVudCIsIkVsZW1lbnQiLCJpc0hUTUxFbGVtZW50IiwiSFRNTEVsZW1lbnQiLCJpc1NoYWRvd1Jvb3QiLCJTaGFkb3dSb290IiwiaW52YWxpZE92ZXJmbG93RGlzcGxheVZhbHVlcyIsIlNldCIsImlzT3ZlcmZsb3dFbGVtZW50IiwiZWxlbWVudCIsIm92ZXJmbG93Iiwib3ZlcmZsb3dYIiwib3ZlcmZsb3dZIiwiZGlzcGxheSIsImdldENvbXB1dGVkU3R5bGUiLCJ0ZXN0IiwiaGFzIiwidGFibGVFbGVtZW50cyIsImlzVGFibGVFbGVtZW50IiwidG9wTGF5ZXJTZWxlY3RvcnMiLCJpc1RvcExheWVyIiwic29tZSIsInNlbGVjdG9yIiwibWF0Y2hlcyIsIl9lIiwidHJhbnNmb3JtUHJvcGVydGllcyIsIndpbGxDaGFuZ2VWYWx1ZXMiLCJjb250YWluVmFsdWVzIiwiaXNDb250YWluaW5nQmxvY2siLCJlbGVtZW50T3JDc3MiLCJ3ZWJraXQiLCJpc1dlYktpdCIsImNzcyIsImNvbnRhaW5lclR5cGUiLCJiYWNrZHJvcEZpbHRlciIsImZpbHRlciIsIndpbGxDaGFuZ2UiLCJpbmNsdWRlcyIsImNvbnRhaW4iLCJnZXRDb250YWluaW5nQmxvY2siLCJjdXJyZW50Tm9kZSIsImdldFBhcmVudE5vZGUiLCJpc0xhc3RUcmF2ZXJzYWJsZU5vZGUiLCJDU1MiLCJzdXBwb3J0cyIsImxhc3RUcmF2ZXJzYWJsZU5vZGVOYW1lcyIsImdldE5vZGVTY3JvbGwiLCJzY3JvbGxMZWZ0Iiwic2Nyb2xsVG9wIiwic2Nyb2xsWCIsInNjcm9sbFkiLCJyZXN1bHQiLCJhc3NpZ25lZFNsb3QiLCJwYXJlbnROb2RlIiwiaG9zdCIsImdldE5lYXJlc3RPdmVyZmxvd0FuY2VzdG9yIiwiYm9keSIsImdldE92ZXJmbG93QW5jZXN0b3JzIiwibGlzdCIsInRyYXZlcnNlSWZyYW1lcyIsIl9ub2RlJG93bmVyRG9jdW1lbnQyIiwic2Nyb2xsYWJsZUFuY2VzdG9yIiwiaXNCb2R5Iiwid2luIiwiZnJhbWVFbGVtZW50IiwiZ2V0RnJhbWVFbGVtZW50IiwiY29uY2F0IiwidmlzdWFsVmlld3BvcnQiLCJwYXJlbnQiLCJPYmplY3QiLCJnZXRQcm90b3R5cGVPZiJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   alignments: () => (/* binding */ alignments),\n/* harmony export */   clamp: () => (/* binding */ clamp),\n/* harmony export */   createCoords: () => (/* binding */ createCoords),\n/* harmony export */   evaluate: () => (/* binding */ evaluate),\n/* harmony export */   expandPaddingObject: () => (/* binding */ expandPaddingObject),\n/* harmony export */   floor: () => (/* binding */ floor),\n/* harmony export */   getAlignment: () => (/* binding */ getAlignment),\n/* harmony export */   getAlignmentAxis: () => (/* binding */ getAlignmentAxis),\n/* harmony export */   getAlignmentSides: () => (/* binding */ getAlignmentSides),\n/* harmony export */   getAxisLength: () => (/* binding */ getAxisLength),\n/* harmony export */   getExpandedPlacements: () => (/* binding */ getExpandedPlacements),\n/* harmony export */   getOppositeAlignmentPlacement: () => (/* binding */ getOppositeAlignmentPlacement),\n/* harmony export */   getOppositeAxis: () => (/* binding */ getOppositeAxis),\n/* harmony export */   getOppositeAxisPlacements: () => (/* binding */ getOppositeAxisPlacements),\n/* harmony export */   getOppositePlacement: () => (/* binding */ getOppositePlacement),\n/* harmony export */   getPaddingObject: () => (/* binding */ getPaddingObject),\n/* harmony export */   getSide: () => (/* binding */ getSide),\n/* harmony export */   getSideAxis: () => (/* binding */ getSideAxis),\n/* harmony export */   max: () => (/* binding */ max),\n/* harmony export */   min: () => (/* binding */ min),\n/* harmony export */   placements: () => (/* binding */ placements),\n/* harmony export */   rectToClientRect: () => (/* binding */ rectToClientRect),\n/* harmony export */   round: () => (/* binding */ round),\n/* harmony export */   sides: () => (/* binding */ sides)\n/* harmony export */ });\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n/**\n * Custom positioning reference element.\n * @see https://floating-ui.com/docs/virtual-elements\n */\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst alignments = ['start', 'end'];\nconst placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = v => ({\n  x: v,\n  y: v\n});\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === 'function' ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\nfunction getAxisLength(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\nconst yAxisSides = /*#__PURE__*/new Set(['top', 'bottom']);\nfunction getSideAxis(placement) {\n  return yAxisSides.has(getSide(placement)) ? 'y' : 'x';\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\nconst lrPlacement = ['left', 'right'];\nconst rlPlacement = ['right', 'left'];\nconst tbPlacement = ['top', 'bottom'];\nconst btPlacement = ['bottom', 'top'];\nfunction getSideList(side, isStart, rtl) {\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rlPlacement : lrPlacement;\n      return isStart ? lrPlacement : rlPlacement;\n    case 'left':\n    case 'right':\n      return isStart ? tbPlacement : btPlacement;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return _objectSpread({\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  }, padding);\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = rect;\n  return {\n    width,\n    height,\n    top: y,\n    left: x,\n    right: x + width,\n    bottom: y + height,\n    x,\n    y\n  };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3V0aWxzL2Rpc3QvZmxvYXRpbmctdWkudXRpbHMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTUEsS0FBSyxHQUFHLENBQUMsS0FBSyxFQUFFLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxDQUFDO0FBQ2hELE1BQU1DLFVBQVUsR0FBRyxDQUFDLE9BQU8sRUFBRSxLQUFLLENBQUM7QUFDbkMsTUFBTUMsVUFBVSxHQUFHLGFBQWFGLEtBQUssQ0FBQ0csTUFBTSxDQUFDLENBQUNDLEdBQUcsRUFBRUMsSUFBSSxLQUFLRCxHQUFHLENBQUNFLE1BQU0sQ0FBQ0QsSUFBSSxFQUFFQSxJQUFJLEdBQUcsR0FBRyxHQUFHSixVQUFVLENBQUMsQ0FBQyxDQUFDLEVBQUVJLElBQUksR0FBRyxHQUFHLEdBQUdKLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQztBQUN6SSxNQUFNTSxHQUFHLEdBQUdDLElBQUksQ0FBQ0QsR0FBRztBQUNwQixNQUFNRSxHQUFHLEdBQUdELElBQUksQ0FBQ0MsR0FBRztBQUNwQixNQUFNQyxLQUFLLEdBQUdGLElBQUksQ0FBQ0UsS0FBSztBQUN4QixNQUFNQyxLQUFLLEdBQUdILElBQUksQ0FBQ0csS0FBSztBQUN4QixNQUFNQyxZQUFZLEdBQUdDLENBQUMsS0FBSztFQUN6QkMsQ0FBQyxFQUFFRCxDQUFDO0VBQ0pFLENBQUMsRUFBRUY7QUFDTCxDQUFDLENBQUM7QUFDRixNQUFNRyxlQUFlLEdBQUc7RUFDdEJDLElBQUksRUFBRSxPQUFPO0VBQ2JDLEtBQUssRUFBRSxNQUFNO0VBQ2JDLE1BQU0sRUFBRSxLQUFLO0VBQ2JDLEdBQUcsRUFBRTtBQUNQLENBQUM7QUFDRCxNQUFNQyxvQkFBb0IsR0FBRztFQUMzQkMsS0FBSyxFQUFFLEtBQUs7RUFDWkMsR0FBRyxFQUFF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2Ycg24wg2YXYrdmF2K8g2LnYsdmB2KfZhiDYsdi22KfbjNuMXFxFcmZhbmRldlxcLmZyb250ZW5kXFxub2RlX21vZHVsZXNcXEBmbG9hdGluZy11aVxcdXRpbHNcXGRpc3RcXGZsb2F0aW5nLXVpLnV0aWxzLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEN1c3RvbSBwb3NpdGlvbmluZyByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy92aXJ0dWFsLWVsZW1lbnRzXG4gKi9cblxuY29uc3Qgc2lkZXMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddO1xuY29uc3QgYWxpZ25tZW50cyA9IFsnc3RhcnQnLCAnZW5kJ107XG5jb25zdCBwbGFjZW1lbnRzID0gLyojX19QVVJFX18qL3NpZGVzLnJlZHVjZSgoYWNjLCBzaWRlKSA9PiBhY2MuY29uY2F0KHNpZGUsIHNpZGUgKyBcIi1cIiArIGFsaWdubWVudHNbMF0sIHNpZGUgKyBcIi1cIiArIGFsaWdubWVudHNbMV0pLCBbXSk7XG5jb25zdCBtaW4gPSBNYXRoLm1pbjtcbmNvbnN0IG1heCA9IE1hdGgubWF4O1xuY29uc3Qgcm91bmQgPSBNYXRoLnJvdW5kO1xuY29uc3QgZmxvb3IgPSBNYXRoLmZsb29yO1xuY29uc3QgY3JlYXRlQ29vcmRzID0gdiA9PiAoe1xuICB4OiB2LFxuICB5OiB2XG59KTtcbmNvbnN0IG9wcG9zaXRlU2lkZU1hcCA9IHtcbiAgbGVmdDogJ3JpZ2h0JyxcbiAgcmlnaHQ6ICdsZWZ0JyxcbiAgYm90dG9tOiAndG9wJyxcbiAgdG9wOiAnYm90dG9tJ1xufTtcbmNvbnN0IG9wcG9zaXRlQWxpZ25tZW50TWFwID0ge1xuICBzdGFydDogJ2VuZCcsXG4gIGVuZDogJ3N0YXJ0J1xufTtcbmZ1bmN0aW9uIGNsYW1wKHN0YXJ0LCB2YWx1ZSwgZW5kKSB7XG4gIHJldHVybiBtYXgoc3RhcnQsIG1pbih2YWx1ZSwgZW5kKSk7XG59XG5mdW5jdGlvbiBldmFsdWF0ZSh2YWx1ZSwgcGFyYW0pIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IHZhbHVlKHBhcmFtKSA6IHZhbHVlO1xufVxuZnVuY3Rpb24gZ2V0U2lkZShwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xufVxuZnVuY3Rpb24gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG59XG5mdW5jdGlvbiBnZXRPcHBvc2l0ZUF4aXMoYXhpcykge1xuICByZXR1cm4gYXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xufVxuZnVuY3Rpb24gZ2V0QXhpc0xlbmd0aChheGlzKSB7XG4gIHJldHVybiBheGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG59XG5jb25zdCB5QXhpc1NpZGVzID0gLyojX19QVVJFX18qL25ldyBTZXQoWyd0b3AnLCAnYm90dG9tJ10pO1xuZnVuY3Rpb24gZ2V0U2lkZUF4aXMocGxhY2VtZW50KSB7XG4gIHJldHVybiB5QXhpc1NpZGVzLmhhcyhnZXRTaWRlKHBsYWNlbWVudCkpID8gJ3knIDogJ3gnO1xufVxuZnVuY3Rpb24gZ2V0QWxpZ25tZW50QXhpcyhwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIGdldE9wcG9zaXRlQXhpcyhnZXRTaWRlQXhpcyhwbGFjZW1lbnQpKTtcbn1cbmZ1bmN0aW9uIGdldEFsaWdubWVudFNpZGVzKHBsYWNlbWVudCwgcmVjdHMsIHJ0bCkge1xuICBpZiAocnRsID09PSB2b2lkIDApIHtcbiAgICBydGwgPSBmYWxzZTtcbiAgfVxuICBjb25zdCBhbGlnbm1lbnQgPSBnZXRBbGlnbm1lbnQocGxhY2VtZW50KTtcbiAgY29uc3QgYWxpZ25tZW50QXhpcyA9IGdldEFsaWdubWVudEF4aXMocGxhY2VtZW50KTtcbiAgY29uc3QgbGVuZ3RoID0gZ2V0QXhpc0xlbmd0aChhbGlnbm1lbnRBeGlzKTtcbiAgbGV0IG1haW5BbGlnbm1lbnRTaWRlID0gYWxpZ25tZW50QXhpcyA9PT0gJ3gnID8gYWxpZ25tZW50ID09PSAocnRsID8gJ2VuZCcgOiAnc3RhcnQnKSA/ICdyaWdodCcgOiAnbGVmdCcgOiBhbGlnbm1lbnQgPT09ICdzdGFydCcgPyAnYm90dG9tJyA6ICd0b3AnO1xuICBpZiAocmVjdHMucmVmZXJlbmNlW2xlbmd0aF0gPiByZWN0cy5mbG9hdGluZ1tsZW5ndGhdKSB7XG4gICAgbWFpbkFsaWdubWVudFNpZGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChtYWluQWxpZ25tZW50U2lkZSk7XG4gIH1cbiAgcmV0dXJuIFttYWluQWxpZ25tZW50U2lkZSwgZ2V0T3Bwb3NpdGVQbGFjZW1lbnQobWFpbkFsaWdubWVudFNpZGUpXTtcbn1cbmZ1bmN0aW9uIGdldEV4cGFuZGVkUGxhY2VtZW50cyhwbGFjZW1lbnQpIHtcbiAgY29uc3Qgb3Bwb3NpdGVQbGFjZW1lbnQgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICByZXR1cm4gW2dldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50KHBsYWNlbWVudCksIG9wcG9zaXRlUGxhY2VtZW50LCBnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudChvcHBvc2l0ZVBsYWNlbWVudCldO1xufVxuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvc3RhcnR8ZW5kL2csIGFsaWdubWVudCA9PiBvcHBvc2l0ZUFsaWdubWVudE1hcFthbGlnbm1lbnRdKTtcbn1cbmNvbnN0IGxyUGxhY2VtZW50ID0gWydsZWZ0JywgJ3JpZ2h0J107XG5jb25zdCBybFBsYWNlbWVudCA9IFsncmlnaHQnLCAnbGVmdCddO1xuY29uc3QgdGJQbGFjZW1lbnQgPSBbJ3RvcCcsICdib3R0b20nXTtcbmNvbnN0IGJ0UGxhY2VtZW50ID0gWydib3R0b20nLCAndG9wJ107XG5mdW5jdGlvbiBnZXRTaWRlTGlzdChzaWRlLCBpc1N0YXJ0LCBydGwpIHtcbiAgc3dpdGNoIChzaWRlKSB7XG4gICAgY2FzZSAndG9wJzpcbiAgICBjYXNlICdib3R0b20nOlxuICAgICAgaWYgKHJ0bCkgcmV0dXJuIGlzU3RhcnQgPyBybFBsYWNlbWVudCA6IGxyUGxhY2VtZW50O1xuICAgICAgcmV0dXJuIGlzU3RhcnQgPyBsclBsYWNlbWVudCA6IHJsUGxhY2VtZW50O1xuICAgIGNhc2UgJ2xlZnQnOlxuICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgIHJldHVybiBpc1N0YXJ0ID8gdGJQbGFjZW1lbnQgOiBidFBsYWNlbWVudDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFtdO1xuICB9XG59XG5mdW5jdGlvbiBnZXRPcHBvc2l0ZUF4aXNQbGFjZW1lbnRzKHBsYWNlbWVudCwgZmxpcEFsaWdubWVudCwgZGlyZWN0aW9uLCBydGwpIHtcbiAgY29uc3QgYWxpZ25tZW50ID0gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCk7XG4gIGxldCBsaXN0ID0gZ2V0U2lkZUxpc3QoZ2V0U2lkZShwbGFjZW1lbnQpLCBkaXJlY3Rpb24gPT09ICdzdGFydCcsIHJ0bCk7XG4gIGlmIChhbGlnbm1lbnQpIHtcbiAgICBsaXN0ID0gbGlzdC5tYXAoc2lkZSA9PiBzaWRlICsgXCItXCIgKyBhbGlnbm1lbnQpO1xuICAgIGlmIChmbGlwQWxpZ25tZW50KSB7XG4gICAgICBsaXN0ID0gbGlzdC5jb25jYXQobGlzdC5tYXAoZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxpc3Q7XG59XG5mdW5jdGlvbiBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9sZWZ0fHJpZ2h0fGJvdHRvbXx0b3AvZywgc2lkZSA9PiBvcHBvc2l0ZVNpZGVNYXBbc2lkZV0pO1xufVxuZnVuY3Rpb24gZXhwYW5kUGFkZGluZ09iamVjdChwYWRkaW5nKSB7XG4gIHJldHVybiB7XG4gICAgdG9wOiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBsZWZ0OiAwLFxuICAgIC4uLnBhZGRpbmdcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFBhZGRpbmdPYmplY3QocGFkZGluZykge1xuICByZXR1cm4gdHlwZW9mIHBhZGRpbmcgIT09ICdudW1iZXInID8gZXhwYW5kUGFkZGluZ09iamVjdChwYWRkaW5nKSA6IHtcbiAgICB0b3A6IHBhZGRpbmcsXG4gICAgcmlnaHQ6IHBhZGRpbmcsXG4gICAgYm90dG9tOiBwYWRkaW5nLFxuICAgIGxlZnQ6IHBhZGRpbmdcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlY3RUb0NsaWVudFJlY3QocmVjdCkge1xuICBjb25zdCB7XG4gICAgeCxcbiAgICB5LFxuICAgIHdpZHRoLFxuICAgIGhlaWdodFxuICB9ID0gcmVjdDtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgdG9wOiB5LFxuICAgIGxlZnQ6IHgsXG4gICAgcmlnaHQ6IHggKyB3aWR0aCxcbiAgICBib3R0b206IHkgKyBoZWlnaHQsXG4gICAgeCxcbiAgICB5XG4gIH07XG59XG5cbmV4cG9ydCB7IGFsaWdubWVudHMsIGNsYW1wLCBjcmVhdGVDb29yZHMsIGV2YWx1YXRlLCBleHBhbmRQYWRkaW5nT2JqZWN0LCBmbG9vciwgZ2V0QWxpZ25tZW50LCBnZXRBbGlnbm1lbnRBeGlzLCBnZXRBbGlnbm1lbnRTaWRlcywgZ2V0QXhpc0xlbmd0aCwgZ2V0RXhwYW5kZWRQbGFjZW1lbnRzLCBnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudCwgZ2V0T3Bwb3NpdGVBeGlzLCBnZXRPcHBvc2l0ZUF4aXNQbGFjZW1lbnRzLCBnZXRPcHBvc2l0ZVBsYWNlbWVudCwgZ2V0UGFkZGluZ09iamVjdCwgZ2V0U2lkZSwgZ2V0U2lkZUF4aXMsIG1heCwgbWluLCBwbGFjZW1lbnRzLCByZWN0VG9DbGllbnRSZWN0LCByb3VuZCwgc2lkZXMgfTtcbiJdLCJuYW1lcyI6WyJzaWRlcyIsImFsaWdubWVudHMiLCJwbGFjZW1lbnRzIiwicmVkdWNlIiwiYWNjIiwic2lkZSIsImNvbmNhdCIsIm1pbiIsIk1hdGgiLCJtYXgiLCJyb3VuZCIsImZsb29yIiwiY3JlYXRlQ29vcmRzIiwidiIsIngiLCJ5Iiwib3Bwb3NpdGVTaWRlTWFwIiwibGVmdCIsInJpZ2h0IiwiYm90dG9tIiwidG9wIiwib3Bwb3NpdGVBbGlnbm1lbnRNYXAiLCJzdGFydCIsImVuZCIsImNsYW1wIiwidmFsdWUiLCJldmFsdWF0ZSIsInBhcmFtIiwiZ2V0U2lkZSIsInBsYWNlbWVudCIsInNwbGl0IiwiZ2V0QWxpZ25tZW50IiwiZ2V0T3Bwb3NpdGVBeGlzIiwiYXhpcyIsImdldEF4aXNMZW5ndGgiLCJ5QXhpc1NpZGVzIiwiU2V0IiwiZ2V0U2lkZUF4aXMiLCJoYXMiLCJnZXRBbGlnbm1lbnRBeGlzIiwiZ2V0QWxpZ25tZW50U2lkZXMiLCJyZWN0cyIsInJ0bCIsImFsaWdubWVudCIsImFsaWdubWVudEF4aXMiLCJsZW5ndGgiLCJtYWluQWxpZ25tZW50U2lkZSIsInJlZmVyZW5jZSIsImZsb2F0aW5nIiwiZ2V0T3Bwb3NpdGVQbGFjZW1lbnQiLCJnZXRFeHBhbmRlZFBsYWNlbWVudHMiLCJvcHBvc2l0ZVBsYWNlbWVudCIsImdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50IiwicmVwbGFjZSIsImxyUGxhY2VtZW50IiwicmxQbGFjZW1lbnQiLCJ0YlBsYWNlbWVudCIsImJ0UGxhY2VtZW50IiwiZ2V0U2lkZUxpc3QiLCJpc1N0YXJ0IiwiZ2V0T3Bwb3NpdGVBeGlzUGxhY2VtZW50cyIsImZsaXBBbGlnbm1lbnQiLCJkaXJlY3Rpb24iLCJsaXN0IiwibWFwIiwiZXhwYW5kUGFkZGluZ09iamVjdCIsInBhZGRpbmciLCJfb2JqZWN0U3ByZWFkIiwiZ2V0UGFkZGluZ09iamVjdCIsInJlY3RUb0NsaWVudFJlY3QiLCJyZWN0Iiwid2lkdGgiLCJoZWlnaHQiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs\n");

/***/ })

};
;